ApexCharts の `rangeBar` チャート（特に Gantt チャート風の表示など）をステップバイステップで学ぶ際に整理すべき**学習項目リスト**は以下のように構成されます。

---

## 🧭 ApexCharts `rangeBar` 学習項目一覧

### 1. **基本構造と用途理解**

* `rangeBar` の基本構造（start - end の範囲を持つデータ）
* `bar` チャートの中の `rangeBar` との違い
* よく使われるユースケース（例：プロジェクト期間、作業タイムライン、飛行ルート時間 など）

---

### 2. **データ形式の理解**

* **データ構造（x, y: \[start, end]）**

  * `x`: ラベルや分類名
  * `y`: 配列（\[開始時刻, 終了時刻]）
* 日付形式：UNIXタイムスタンプ／ISO8601文字列などのサポート
* カテゴリ vs 時系列 vs 数値軸

---

### 3. **チャートオプションの構成**

* `chart.type: 'rangeBar'`
* `plotOptions.bar`:

  * `horizontal`
  * `barHeight`
  * `rangeBarGroupRows`
* `xaxis`:

  * `type: 'datetime' | 'category'`
  * `labels.format`
* `dataLabels`:

  * `enabled`, `formatter`, `position`
* `tooltip`:

  * カスタムフォーマット（時間帯や差分表示など）

---

### 4. **スタイルと視覚表現**

* 色指定（`colors`, `fill`, `gradient`）
* グループ化（`rangeBarGroupRows: true`）
* カスタム `barHeight`
* ラベルの折り返しや省略（`xaxis.labels.style`）

---

### 5. **インタラクション制御**

* `tooltip`: 日付のカスタマイズ表示
* `dataLabels.formatter`: 開始・終了時間やラベル表示の調整
* `events`: クリックイベント等による行動の拡張

---

### 6. **応用例**

* Gantt チャート風の横棒タイムライン（複数行グループ化）
* フライトの時間軸表示（出発 - 到着）
* 作業者別のスケジュール比較（人ごとに分類）

---

### 7. **Vue / React / その他での統合**

* ApexCharts Vue / React ライブラリの使い方
* コンポーネントとしての`<apexchart>`利用方法
* `options` と `series` のデータバインディング

---

### 8. **よくあるエラー・注意点**

* 時刻データが無効（例: 数値型→Date型変換漏れ）
* グループ化のために必要な `customData` の忘れ
* `xaxis.type` が `datetime` でないと時間軸表示されない

---

### 9. **デバッグ・確認方法**

* `console.log(options)` による構成確認
* `apexcharts.com/docs` にある Playground で試作
* チャートが表示されない場合のチェックリスト

---

このようにステップごとに整理すれば、単なる描画から応用まで網羅的に学ぶことができます。

---

必要であれば、これらの各ステップを「DeepResearch」形式で順番に深掘りしていくことも可能です。
最初にどの項目から詳しく知りたいですか？（例：「データ構造」と「xaxis.type」の関係から知りたい）




了解しました。センサーのオン・オフやアクティブ期間など、周期的なデータを表示するための ApexCharts の rangeBar チャートについて、基本構造と bar チャートとの違い、さらに用途に即したユースケースを含めて深掘り調査します。調査完了後にわかりやすいテンプレート形式でお届けしますので、しばらくお待ちください。


# ApexChartsのrangeBarチャート基本構造の解説

## 1. rangeBarチャートの基本構造とデータ形式

**rangeBarチャートとは何か:**
ApexChartsの**rangeBarチャート**は、各データポイントに「開始値」と「終了値」の区間を持つ棒グラフです。通常の棒グラフが単一の値（棒の長さ）を示すのに対し、rangeBarでは棒が**開始値から終了値までの範囲**を表現します。このチャートタイプを利用すると、あるイベントやタスクの開始時刻と終了時刻など、**時間的な区間**を直感的に可視化できます（ガントチャートのようなタイムラインの描画に便利です）。

**データ形式 (x, y: \[start, end]):**
rangeBarチャートでデータを指定する際には、**`series`** 配列内の各データ点において、`x` プロパティにカテゴリ（ラベル）を、`y` プロパティに `[開始値, 終了値]` の配列を渡します。例えば、数値の範囲を示す場合や時間の区間を示す場合、それぞれ開始と終了の値をペアで与えます。以下は公式ドキュメントの例です：

```js
series: [{
  data: [
    { x: 'TEAM A', y: [65, 96] },   // TEAM Aのデータ区間（65〜96）
    { x: 'TEAM B', y: [55, 78] },   // TEAM Bのデータ区間（55〜78）
    // ...
    { x: 'TEAM C', y: [95, 186] }   // TEAM Cのデータ区間（95〜186）
  ]
}]
```

上記のように、`chart.type: 'rangeBar'` を指定しておけば、各`x`カテゴリについて棒が **yの開始値から終了値まで** 描画されます。特に時間軸のデータを扱う場合は、`y`の配列に\*\*タイムスタンプ（Unixエポックなどの数値）\*\*を入れ、x軸の型を `'datetime'` に設定します。例えば、開始と終了を日時で表すには次のようにします：

```js
series: [{
  data: [
    { x: 'センサーA', y: [ <開始時刻のタイムスタンプ>, <終了時刻のタイムスタンプ> ] },
    // 複数のデータ点を含めることも可能
  ]
}],
xaxis: { type: 'datetime' }
```

このようにすると、x軸が日時スケールとなり、棒の位置や長さが適切な日時に対応します（開始～終了の時間帯を示す棒として描画されます）。なお、一般的に\*\*rangeBarチャートで時間軸を扱う場合は棒を水平（水平方向）\*\*に描画することが多いため、`plotOptions.bar.horizontal: true` を指定してx軸に時間（datetime）、y軸にカテゴリが来るようにするとタイムライン表示がしやすくなります。

## 2. 通常のバーチャート（棒グラフ）との違い

rangeBarチャートは通常のバー（柱状）チャートと**データ構造**や**用途**が異なります。以下に主な違いをまとめます：

| **項目**        | **rangeBarチャート**                                                                             | **通常のバーチャート**                                                                  |
| ------------- | -------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------ |
| **データ形式**     | `x`: カテゴリ名（ラベル）、`y`: **\[開始値, 終了値]** の配列。各データ点が区間を表す。                                        | `x`: カテゴリ名（ラベル）、`y`: **単一の数値**。各データ点が単一の値（棒の大きさ）を表す。                           |
| **チャートタイプ指定** | `chart.type: 'rangeBar'`（ApexCharts固有のタイプ）                                                   | `chart.type: 'bar'`（一般的な棒グラフタイプ）。                                              |
| **棒（バー）の描画**  | 棒は指定した**開始値から終了値まで**の区間として描かれる。基準線は特になく、データごとに開始位置が異なりうる（例えば数値軸上の65～96の区間など）。                | 棒は通常**基準線（既定では0）から目的の値まで**描かれる。すべての棒が共通の基準（ゼロなど）から伸びる長さで比較される。                 |
| **見た目の特徴**    | 区間を表現するため、**棒が浮いて表示される場合**もある（下端が0とは限らない）。時間軸で使う場合は**水平棒**としてタイムライン状に表示することが多い。              | **一般的に棒グラフは垂直方向**に表示（カテゴリが横軸、値が縦軸）だが、オプションで水平にもできる。棒同士は基準線からの長さで比較され、区間の概念はない。 |
| **主な用途**      | **期間や時間範囲の可視化**。タスクの開始・終了時刻の表示、イベントの継続時間のタイムライン表示など（ガントチャート風の用途）。値の増減や範囲を示す「ダンベルチャート」にも応用可能。 | **カテゴリごとの数値比較**。売上や数量など各カテゴリの値を比較する一般的な棒グラフとして使用。値の大小・ランキングを示すのに適する。           |

**データ指定の例：** 通常のバーチャートでは各データ点に単一の数値を指定します。例えば:

```js
// 通常の棒グラフのデータ例
series: [{
  data: [
    { x: 'Category A', y: 10 },
    { x: 'Category B', y: 18 },
    { x: 'Category C', y: 13 }
  ]
}]
```



一方、rangeBarチャートでは各データ点に開始と終了の2つの値を持たせます:

```js
// rangeBarチャートのデータ例
series: [{
  data: [
    { x: 'Category A', y: [10, 20] },   // 10から20の範囲
    { x: 'Category B', y: [18, 30] },   // 18から30の範囲
    { x: 'Category C', y: [13, 25] }    // 13から25の範囲
  ]
}]
```

このように、rangeBarでは\*\*`y`に配列\*\*を渡し二点間の区間を示す点が本質的な違いです。見た目にも、rangeBarの棒は値の区間を表すため途中から始まる棒になります（例えばCategory Aの棒は10の位置から20の位置までの区間をハイライト）。対して通常バーではすべて棒がゼロから伸びるため、棒の開始位置は統一されています。

また、rangeBarでは**同じカテゴリ内で複数の棒が存在**しうる点も特徴的です。通常の棒グラフでは一カテゴリに対し各シリーズ1本の棒ですが、rangeBarの場合例えば一つのカテゴリ（ラベル）について複数の開始～終了区間のデータを与えることで、**同じカテゴリーに複数のバー**を描画することが可能です（後述のタイムライン用途で活用）。この挙動については次のセクションで詳述します。

## 3. センサーの周期的表示用途におけるユースケース

rangeBarチャートは、センサーのON/OFFやアクティブ期間を時系列に可視化する用途に非常に適しています。ここでは「センサーの周期的な状態表示」を念頭に、rangeBarチャートの活用方法とデータ構造上のポイントを解説します。

### センサーのON/OFF時間・アクティブ期間の可視化

センサーが**いつ作動（ON）し、いつ停止（OFF）したか**を示すには、rangeBarチャートが有効です。各センサーの「ONになった時刻」と「OFFになった時刻」をそれぞれ開始・終了値としてデータに持たせることで、時間軸上にセンサーの稼働期間をバーで表示できます。これにより、例えば「一日のうちどの時間帯にセンサーがアクティブだったか」や「どのくらいの連続時間ONの状態が続いたか」といった情報が一目で分かるようになります。棒の長さが作動時間の長さを表し、棒と棒の間の空白が停止期間を表すため、**センサーの動作パターン**や不規則な点を視覚的に捉えやすくなります。

具体的には、センサーごとに**ONになった時刻を開始、OFFになった時刻を終了**とするデータ点を作ります。センサーが一日に何度もON/OFFを繰り返す場合は、その都度の開始・終了ペアを複数用意します。例えばセンサーAが「10:00～10:30」と「14:00～15:00」にONだったなら、センサーAに対して2つのデータ区間 (`y: [開始, 終了]`) を持たせます。こうしたデータをrangeBarチャートに渡すと、同じセンサーAの行に2本の棒が描画され、朝と午後のON期間がそれぞれ可視化されます。

### センサー別・日付別のタイムライン表示（ガントチャート風）

複数のセンサーの稼働状況を**センサー別かつ日付別**に一覧できるようなタイムラインを構築することも可能です。基本的な考え方は、**縦軸（カテゴリ軸）にセンサーの種類（名前）、横軸（時間軸）に日時**をとったレンジバー形式のチャートを作ることです。

例えば下図はApexChartsのタイムライン（rangeBar）チャートの一例で、縦軸にタスク（カテゴリ）が並び、横軸が日付となっています。各バーはタスクの開始日～終了日を示しており、BobとJoeの2系列で色分けされています。このように**カテゴリごとに横方向のバーで期間を表現**できるため、センサーのON/OFFタイムラインも同様の構造で描画できます。

センサーのタイムラインでは、縦方向に**センサーごとの行**を設け、各行にそのセンサーがアクティブだった時間帯のバーを配置します。横軸は日時（例えば時刻や日付）で、チャート全体のxaxisを `'datetime'` 型にします。データの指定方法としてはいくつかアプローチがありますが、代表的な方法は以下のとおりです：

* **単一シリーズでカテゴリを分ける方法:**
  すべてのセンサーのデータを1つのseriesオブジェクトにまとめ、各データ点の`x`にセンサー名、`y`にそのセンサーのON～OFF時刻の配列を入れる方法です。例えば:

  ```js
  series: [{
    data: [
      { x: 'センサーA', y: [ <ON開始1>, <OFF終了1> ] },
      { x: 'センサーA', y: [ <ON開始2>, <OFF終了2> ] },
      { x: 'センサーB', y: [ <ON開始1>, <OFF終了1> ] },
      // ... センサーごとに複数の区間データ
    ]
  }]
  ```

  こうすると、ApexChartsは`x`が同じカテゴリ（例: "センサーA"）のデータを**同じ行にグループ化**して描画します。複数のセンサーがあればカテゴリが複数になります。なお、同じシリーズ内で`x`（カテゴリ）が同一のデータ点が複数存在する場合、デフォルトではそれらの棒が縦方向にずれて重ならないよう表示されることがあります。そのため**plotOptions.bar.rangeBarGroupRows**オプションを利用して、同じカテゴリのデータは一つの行にまとめて描画する設定にすると良いでしょう（後述）。

* **センサーごとにシリーズを分ける方法:**
  別の方法として、センサーごとに別々のseriesエントリを用意し、それぞれのシリーズ内でデータ点の`x`に日付（あるいは任意の共通ラベル）を入れる方法もあります。ただしこの場合、各シリーズの`x`値（カテゴリ名）が一致しないと縦軸で揃わないため、通常は**series名とは別にカテゴリとしてセンサー名を統一**する必要があります。実装上は少々複雑になるため、シンプルには前者の単一シリーズにまとめる方法が扱いやすいでしょう。複数シリーズを使う利点は系列ごとに色を変えられる点ですが、ApexChartsではseries単位でなくともデータ点ごとに色指定が可能なため（例えば各センサーに固有の色を設定）、単一シリーズでも色分けは可能です。

**カテゴリ行のグループ化設定:**
複数のデータ区間を同一カテゴリ（センサー）で表示する際は、先述の`rangeBarGroupRows`オプションを有効にすることで**同じカテゴリ名のバーを一つの行にまとめて表示**できます。これを使用しない場合、同じカテゴリ名でも系列が異なると棒が縦に積み重なって表示されたり、カテゴリが重複して複数行に分かれる場合があります。例えばApexChartsの設定では:

```js
chart: { type: 'rangeBar' },
plotOptions: {
  bar: {
    horizontal: true,
    rangeBarGroupRows: true  // 同じカテゴリのバーをグループ化
  }
},
xaxis: { type: 'datetime' },
series: [ ... 上記データ ... ]
```

とすることで、"センサーA"というカテゴリ名を持つデータは全て\*\*「センサーA」の行にまとまって描画\*\*されます。同一の時間帯に重複する区間が無い限り、棒同士が重なって見づらくなることもありません（仮に重複した場合は`rangeBarOverlap`オプションをtrueにすると棒を重ねて表示できますが、センサーのON/OFFでは通常同時に二重ONは起こらない想定です)。

このタイムライン構造により、**センサー別・日付別の状態**が一目でわかるグラフが実現します。例えば「センサーAは月曜の午前中ずっとON、センサーBは断続的にON/OFFを繰り返している」といった状況を、センサーA・Bそれぞれの行に描かれたバーの位置と長さから読み取ることができます。

### データが周期的な場合の構造と注意点

センサーのデータが**一定の周期で繰り返す**場合（例えば毎正時にONになる、毎日決まった時間帯に動作する、あるいは週ごとに同じパターンを繰り返す等）、rangeBarチャートで表示する際にいくつか考慮すべきポイントがあります。

* **全ての発生区間をデータとして列挙する:**
  rangeBarチャート自体に「繰り返しパターン」を自動認識する機能はありません。したがって、センサーが毎時間ONになる場合でも、**各時間帯のON区間をそれぞれ個別のデータ点として用意**する必要があります。例えば1時間ごとに5分間ONになるセンサーなら、24時間で24個のON区間データを準備します。データが増えますが、それぞれの棒が時間軸上に並ぶことで**周期的なパルス状のパターン**が視覚化されます。ApexChartsは大量のデータポイントも描画できますが、数が非常に多い場合はパフォーマンスや表示の密集度に注意しましょう。

* **時間軸の表示フォーマット:**
  周期的なデータを見やすくするため、x軸のラベルやグリッドを適切に設定します。例えば「毎正時ON」であればx軸に1時間刻みの目盛を表示すると理解しやすくなります。ApexChartsでは`xaxis.labels.formatter`や`xaxis.labels.datetimeFormatter`で日時表示のフォーマットを調整できます。日をまたぐ場合は日付と時刻の併用表示、時間単位なら時:分だけの表示にするなど、**周期に合った粒度で軸ラベルを設定**してください。適切なフォーマット設定により、繰り返しパターンの開始時刻がそろっているかなどが直感的にわかるようになります。

* **日や週の境界を明確にする:**
  データが日ごと・週ごとに繰り返す場合、グラフ上で**日付の境界を視覚的に区切る**ことが有用です。これは必須ではありませんが、例えば1週間分のセンサー稼働パターンを表示する場合、日付の変わり目（深夜0時）にグリッド線や背景の色分けを入れると各日が区別しやすくなります。ApexChartsではカスタムのx軸目盛や縦方向の長いアノテーション（`xaxis.annotations`）を用いて特定日時にラインを引くことも可能です。週単位の繰り返しなら週の境界で区切るなど、見る人が**周期の単位**を把握できる工夫をします。

* **データの順序とソート:**
  時系列のデータは**開始時刻順にソート**しておくとよいでしょう。基本的にseries.data内の順序で描画されますが、仮に順不同でもx軸がdatetime型なら適切にプロットされます。ただ、データを見直す際には昇順に並んでいたほうが管理しやすく、不要な重複や抜け漏れも発見しやすくなります。特に周期データでは「毎日同じ時刻にON」がずれていないか確認する意味でも順序立てて記述するのがおすすめです。

* **ツールチップと凡例の活用:**
  繰り返しパターンでは細かな棒が多数表示されるため、マウスオーバー時の**ツールチップ**情報も重要です。各棒にセンサー名や正確な開始・終了時刻が表示されるよう、ツールチップのフォーマットを整えておくと良いでしょう。また、凡例についてはセンサーが多い場合にフィルタリング（クリックで系列の表示/非表示切り替え）に活用できます。rangeBarではシリーズをセンサー別に分けていれば凡例で個別にON/OFFできますし、単一シリーズの場合でも独自に用意した凡例的なUIでフィルタリングすることも考えられます。

### Vue.jsやVuetifyと組み合わせた実装上のポイント

フロントエンドでVue.jsを使っている場合でも、ApexChartsのrangeBarチャートは容易に組み込むことができます。公式のVueラッパーライブラリである**vue-apexcharts**コンポーネントを利用すると、Vuetifyのレイアウト内にチャートを差し込むことも簡単です。例えばVuetifyのカード内にセンサータイムラインチャートを配置する場合、次のようなコード構成が考えられます：

```vue
<template>
  <v-card>
    <apexchart type="rangeBar"
               height="350"
               :options="chartOptions"
               :series="chartSeries" />
  </v-card>
</template>

<script>
import VueApexCharts from 'vue-apexcharts'
export default {
  components: { ApexChart: VueApexCharts },
  data() {
    return {
      chartOptions: {
        chart: { type: 'rangeBar' },
        plotOptions: {
          bar: { horizontal: true, rangeBarGroupRows: true }
        },
        xaxis: {
          type: 'datetime',
          // datetimeフォーマット例（Vuetify利用でmomentやdayjsも可）
          labels: {
            format: 'HH:mm'  // 時:分 だけ表示する例
          }
        },
        tooltip: {
          x: { format: 'yyyy/MM/dd HH:mm' }  // ツールチップで日時表示形式指定
        },
        legend: { show: true }
      },
      chartSeries: [
        {
          name: 'センサーA',
          data: [
            // センサーAのON/OFF区間データ（開始・終了は日時のタイムスタンプ）
            { x: 'センサーA', y: [1625097600000, 1625101200000] }, // 例: 7/1 00:00〜01:00
            { x: 'センサーA', y: [1625130800000, 1625134400000] }  // 例: 7/1 10:00〜11:00
          ]
        },
        {
          name: 'センサーB',
          data: [
            // センサーBのON/OFF区間データ
            { x: 'センサーB', y: [1625104800000, 1625108400000] }, // 例: 7/1 01:00〜02:00
            // ... （以下省略）
          ]
        }
      ]
    }
  }
}
</script>
```

上記の例では**Vuetify**の`v-card`内に`<apexchart>`コンポーネントを配置し、`chartOptions`と`chartSeries`のデータバインディングでrangeBarチャートを描画しています。`plotOptions.bar.horizontal: true` および `rangeBarGroupRows: true` を指定しているため、同じ`x`ラベル（センサー名）を持つデータは同一行にまとまり、センサーAとBそれぞれ1行ずつにタイムラインが描かれます。`xaxis.type: 'datetime'`により横軸は日時スケールとなり、上ではラベルを時刻のみ表示するようフォーマットしています（必要に応じて日付も含められます）。また、ツールチップや凡例のオプションも設定しており、細かな日時の確認や系列の切り替えが可能です。

Vue.jsデータバインディングのおかげで、例えばセンサーのON/OFFデータが更新された場合でも`chartSeries`を再代入すればチャートに反映できますし、Vuetifyのテーマと組み合わせてカードやレイアウトのスタイル統一も容易です。**まとめると、ApexChartsのrangeBarチャートはVue/Vuetify環境でも柔軟に利用でき、センサーの周期的なON/OFFタイムラインを分かりやすく構築できる**と言えます。各センサーの状態を時系列で俯瞰できるこの可視化は、システムの監視やIoTダッシュボードなどで大いに役立つでしょう。

**参考文献・情報源:** ApexCharts公式ドキュメント【1】【7】および関連デモ【26】を参照して、rangeBarチャートのデータ形式やオプション設定を確認しました。また、Stack Overflowの議論【13】も参考に日時ラベルのフォーマット方法を補足しています。以上の知見を踏まえ、rangeBarチャートの基本構造とセンサー周期データへの応用について詳述しました。


承知しました。ApexCharts の rangeBar チャートにおける「2. データ形式の理解」「3. チャートオプションの構成」「4. スタイルと視覚表現」「5. インタラクション制御」について、センサーの周期的表示ユースケースを踏まえて深掘り調査を行います。調査結果はわかりやすく項目ごとに整理してお届けしますので、しばらくお待ちください。


# ApexCharts における rangeBar チャート解説

## 1. データ形式の理解

### x 値と y 値（開始・終了値）の構造

ApexCharts の rangeBar チャートでは、データポイントを **「カテゴリ (x)」** と **「値の範囲 (y)」** の組にして提供します。具体的には、各データは `{ x: ..., y: [開始値, 終了値] }` というオブジェクト形式です。たとえば:

```js
series: [{
  data: [
    { x: 'TEAM A', y: [65, 96] },
    { x: 'TEAM B', y: [55, 78] },
    { x: 'TEAM C', y: [95, 186] }
  ]
}]
```

上記のように記述すると、`TEAM A`～`C` の各カテゴリについて開始値と終了値のバー（区間）が描画されます。

### 日付データ形式の扱い

rangeBar は時系列のタイムライン表示にも適しており、**日付や時刻を扱う場合**は値をタイムスタンプ（ミリ秒）やパース可能な日付文字列で指定できます。特に **x 軸を時系列 (datetime)** にする場合、各データポイントの `y` に開始・終了の Unixタイムスタンプ（ミリ秒）を指定するのが一般的です。例えば:

```js
series: [{
  data: [
    { x: 'Sensor1', y: [1625097600000, 1625101200000] }, 
    { x: 'Sensor2', y: [1625097600000, 1625104800000] }
  ]
}]
```

上記では、`x` にカテゴリー名 (`Sensor1` など) を付けつつ、`y` に Unix時間の開始・終了を指定しています。この場合、x軸を後述する `'datetime'` 型に設定すると、開始～終了の時間帯がタイムラインとして描画されます。
なお、タイムスタンプの代わりに **ISO8601形式の日付文字列**（例: `"2021-07-01T00:00:00Z"`）や **JavaScriptのDateオブジェクト** を指定することも可能です。ApexCharts は内部でそれらを `Date.parse()` によって解釈し、タイムスタンプに変換してプロットします。重要なのは、文字列で日付を指定する場合は JavaScript の `Date.parse()` で `true` を返すフォーマット（標準的なISO8601など）である必要がある点です。

### x軸タイプ（`datetime` / `category` / `numeric`）の違い

ApexChartsのx軸（`xaxis`）は、データ内容に応じて3種類の型を取ります:

* **`category`（カテゴリ軸）**: 文字列ラベルなどの**離散的なカテゴリ**をx軸にとる場合。例えば上記のように `'TEAM A'` や `'Sensor1'` といったラベルを `x` に指定した場合、自動的にx軸タイプは `category` になります（明示的に `xaxis.type: 'category'` を指定することもできます）。カテゴリ軸ではデータ順にラベルが配置され、等間隔で表示されます。カテゴリ配列を `xaxis.categories` で与える方法もあります。

* **`datetime`（日時軸）**: 時間的な連続量を軸にとる場合。`xaxis.type: 'datetime'` を指定すると、x軸の値は\*\*時刻（タイムスタンプや日時文字列）\*\*として扱われ、時間スケールに沿ってプロットされます。**データポイントの `x` または `y` に与えた日時**をもとに自動で軸ラベルも生成・フォーマットされます（詳細は後述のx軸設定参照）。`datetime` 軸では、軸の範囲やラベル間隔はデータの最小値・最大値に応じて自動調整され、`tickAmount`（目盛り数）の指定は無視されます。

* **`numeric`（数値軸）**: 連続する数値を軸にとる場合。散布図などカテゴリーでない数値系列に使われます。`xaxis.type: 'numeric'` の場合、`x` 値は数値として解釈され、プロット上もその大小関係に応じて配置されます。`tickAmount` に `'dataPoints'` を指定すると、データポイント数に応じて目盛り数を調整する機能などもあります。rangeBar で `numeric` 軸を使うケースは稀ですが、例えば数値の範囲（開始～終了）を示す **「浮動棒グラフ (Floating Bar)」** 的な用途では `numeric` 軸+rangeBarで実現できます。

**カテゴリ軸と日時軸の挙動の違い**: カテゴリ軸ではデータ数に応じてラベルがそのまま配置されますが、日時軸では時系列に沿った目盛りが自動生成されます。このため日時軸では、データ間隔が不均一でも時間の経過に比例した間隔でバーが配置され、軸ラベルも年/月/日など粒度に応じて自動フォーマットされます。一方、カテゴリ軸ではデータの間隔は等間隔扱いであり、軸ラベルは与えられたカテゴリ名そのものが表示されます。さらに**ズームやパン**といった機能は、日時軸・数値軸では利用可能ですが、従来カテゴリ軸ではサポートされていません（v3.15.0以降、一部改善あり）。タイムライン表示を行う場合は通常 `datetime` 軸を用いると良いでしょう。

## 2. チャートオプションの構成

rangeBar チャートを利用する際に指定・調整すべき主なオプションについて説明します。

### `chart.type: 'rangeBar'` の指定

まず **チャートタイプ**として `'rangeBar'` を指定する必要があります。これはオプションオブジェクト内で `chart: { type: 'rangeBar' }` と設定します。他の chart.type（`bar` や `line` 等）では単一値系列として扱われるため、開始・終了の**範囲をプロットする場合は必ず `'rangeBar'` を指定**してください。

### `plotOptions.bar` における主な設定

`plotOptions.bar` では棒グラフ（バー）全般の描画オプションを調整できます。rangeBar特有の重要な設定を以下に挙げます。

* **`horizontal` (水平方向表示)**: デフォルトでは rangeBar は **縦方向の棒（カラム）** として描画されます。`horizontal: true` を指定すると、これを**横向きのバー**（水平バー）に切り替え可能です。例えば、時系列のタイムラインを描画したい場合は `horizontal: true` にして、時間をx軸、カテゴリ（例えばセンサー名など）をy軸に並べる形にします。一般に *「縦型の範囲カラムチャート」* と *「横型のタイムラインチャート」* を切り替えるスイッチと考えて良いでしょう。

* **`barHeight` (バーの太さ)**: 水平バー表示時（`horizontal: true`時）に、バーの太さ（高さ）をパーセンテージ指定できます。`barHeight: '50%'` のように指定すると、プロットエリアの各カテゴリ行の高さに対しバーが50%の太さで描画されます。値が小さいと細い線状になり、大きくするとバー同士が重なるほど太くなります。デフォルトでは `undefined`（自動調整）ですが、複数のシリーズをグループ表示する際や美的調整の際に指定します。

* **`rangeBarOverlap` (バーのオーバーラップ描画)**: **複数シリーズのrangeBar**を重ねて表示する場合に、バー同士を重ねて描画するかどうかを制御します。`rangeBarOverlap: true` を指定すると、同じカテゴリ・同じ系列のバーが**重なって表示**されます。逆に `false`（デフォルト）では、重なる区間があるデータはスタック（積み重ね）ではなく別の列に分離される挙動になります（rangeBarでは通常各シリーズは別行に描画されるため、overlapを有効化しない限り重ならない）。例えば、同じカテゴリ内で時間帯が重複するイベント区間を持つ場合に、オーバーラップ表示させたいなら true に設定します。※単一シリーズ内の重複については自動で調整されます。

* **`rangeBarGroupRows` (行のグループ化)**: こちらも複数シリーズのrangeBarで有効な設定です。`rangeBarGroupRows: true` を指定すると、**異なるシリーズ間でカテゴリ（x値）が同じもの**を一つの行にまとめて表示します。例えば、シリーズAとシリーズBの両方に「Sensor1」というxカテゴリがあれば、本来2行に別れるところを1行に纏め、その中に2本のバーを描画します。この機能は「マルチシリーズのタイムラインで、系列が違っても対象（カテゴリ）が同じなら同じ列にタイムラインを集約したい」場合に有用です（**重複のない独立した区間同士であること**が前提）。`rangeBarGroupRows` は `horizontal: true`（横向き）時に意味を持つ設定で、縦向きカラムには影響しません。

* **その他のオプション**: `plotOptions.bar` には他にもバーの **`borderRadius`（角の丸み）**や、rangeBar固有の **`isDumbbell`（ダンベルチャート表示）** などがあります。`isDumbbell: true` を指定すると、各バーの両端に丸いマーカーが付き、区間の両端点を強調できます（`dumbbellColors` でその色指定も可能）。また `distributed` を `true` にすると各データポイントに対して個別の色を割り当てる（後述）挙動になります。こうした追加設定は必要に応じて検討してください。

### `xaxis` の設定（型・目盛り・範囲・フォーマットなど）

x軸（横軸）の設定は、rangeBarチャートの見た目と挙動に大きな影響を与えます。主なポイントを整理します。

* **`type`**: 前述の通り、`'category'`・`'datetime'`・`'numeric'` を指定可能です。一般に**カテゴリー表示**なら `'category'`、**時系列タイムライン**なら `'datetime'` を選択します。`datetime` 型にすると軸ラベルは自動で日付フォーマットされ、デフォルトではデータ範囲に応じて年→月→日→時間のように粒度が切り替わります（例えば5年以上離れていれば年のみ表示など）。

* **`labels.format`**: x軸ラベルの書式を固定したい場合に使います。例えば `xaxis: { type: 'datetime', labels: { format: 'dd/MM' } }` のように書くと、常に「日/月」の形式で日付ラベルが表示されます。デフォルトでは自動フォーマットに任せますが、用途に応じて `"yyyy-MM-dd HH:mm"` のような書式指定子で整形可能です（使用できる書式指定子は多数あります）。

* **`labels.formatter`**: ラベル表示を完全にカスタムしたい場合は関数を指定します。例えば「timestampを受け取って任意の処理をし、その結果文字列を返す」ことが可能です。`formatter: function(value, timestamp, opts) { ... }` の形式で、日時軸の場合は第2引数に生の timestamp（ミリ秒）が渡されます。この関数内で独自に `new Date(timestamp)` したり、`opts.dateFormatter` を利用して高度なフォーマットを行えます。なお、このformatterを指定すると上記の`format`設定は無視されます。

* **`tickAmount`**: x軸上の**目盛り間隔数**を指定します。例えば `tickAmount: 10` とすれば目盛りラベルを10等分程度表示します。ただし **日時軸には効きません**（日時軸は自動計算）。数値軸では `'dataPoints'` を指定してデータ件数に応じた目盛り表示も可能です。カテゴリ軸ではデータ数がそのまま目盛り数になりますが、例えば多すぎる場合に一部ラベルを間引きたいときは、この値ではなくCSSでラベルを隠すなど別の方法が必要になります。

* **`min` / `max`**: x軸の表示範囲を明示的に指定できます。日時軸・数値軸では特に有用で、例えば `xaxis: { min: 1609459200000, max: 1609545600000 }` のようにミリ秒で指定すると、グラフをその範囲内にズーム固定できます。範囲外のデータは\*\*クリッピング（切り落とし）\*\*され表示されません。rangeBarのタイムラインで「特定期間のみ表示したい」「過去～未来の固定ウィンドウを表示したい」といった場合に使用します。

* **`tooltip` (xaxis.tooltip)**: x軸上部に表示される**クロスヘアのガイド用ツールチップ**の設定です。`xaxis: { tooltip: { enabled: true } }` とすると、グラフホバー時にx軸上に現在の値を示す小さな吹き出しが表示されます（デフォルト有効）。さらに `xaxis.tooltip.formatter` を指定すれば、その吹き出しに表示するテキストをカスタマイズ可能です。もっとも、一般的には次項で述べる `tooltip` オプションでホバー時の情報を制御することが多いため、`xaxis.tooltip` はシンプルにオン/オフ程度でよいでしょう。

### `dataLabels` および `tooltip` の基本設定と関連性

**データラベル (dataLabels)** は各データポイント上に直接表示される値のラベル、**ツールチップ (tooltip)** はホバー時に表示される情報ボックスです。両者は同じデータ系列から情報を取りますが、表示タイミングと目的が異なります。

* **dataLabels**: `dataLabels: { enabled: true }` で有効化すると、各バー区間に値ラベルが描画されます。通常の棒グラフでは単一の値が表示されますが、rangeBarの場合はデフォルトでは何が表示されるか注意が必要です。基本的には **終了値（上限値）** が表示される実装になっています（開始値ではなく）。例えば区間\[20, 27]であれば「27」とラベル表示されます。**区間そのものを表示したい場合**や、独自の文字列（例：「ON」「OFF」など）を表示したい場合は、`dataLabels.formatter` 関数を用いてカスタマイズします。`formatter: function(val, opts) { ... }` では `val` に表示しようとしている値（rangeBarではデフォルト終端値）が入り、`opts` オブジェクトから詳細情報を取得できます。例えば `opts.w.config.series[opts.seriesIndex].data[opts.dataPointIndex]` には元データオブジェクトが格納されているため、そこから `y` の開始・終了値の両方を取得して `${start}〜${end}` のような文字列を組み立てて返すことができます。以下は区間を「開始〜終了」の形式でデータラベル表示する例です。

```js
dataLabels: {
  enabled: true,
  formatter: function(val, { seriesIndex, dataPointIndex, w }) {
    const d = w.config.series[seriesIndex].data[dataPointIndex];
    const [start, end] = d.y;
    return `${start}〜${end}`; // 開始値〜終了値という形式で表示
  }
}
```

上記のように `w`（ワイドオブジェクト）の中から元データにアクセスすることで柔軟な表示が可能です。なお、dataLabelsは多用しすぎるとグラフ上が数字だらけになり視認性が下がるため、必要な場合のみ有効化すると良いでしょう（toolitpで代替できる情報は必ずしも常時表示する必要はありません）。

* **tooltip**: ツールチップは `tooltip: { enabled: true }` で有効（デフォルト有効）になり、ユーザが棒にマウスオーバーした際に詳細情報を表示します。rangeBarの場合、デフォルトのツールチップには**シリーズ名**（`series[i].name`）、**カテゴリ名**（`x`の値）、そして**範囲の開始値と終了値**が含まれます。例えばシリーズ名が「Sensor状態」、xが「Sensor1」、yが`[10, 20]`なら、「Sensor状態 – Sensor1: 10 \~ 20」のような表記になります。この表示内容もカスタマイズ可能で、`tooltip.x` および `tooltip.y` オプションを使用します。例えば日時軸の場合にxの日時フォーマットを指定するには `tooltip: { x: { format: "yyyy-MM-dd HH:mm" } }` のように書けます。あるいは `tooltip.x.formatter` に関数を渡して、独自のフォーマット処理を施すことも可能です。同様にy値側も `tooltip.y.formatter` でフォーマットできます。formatter関数では先ほどのdataLabels同様に引数で `seriesIndex` や `dataPointIndex`、さらには全データを含む `w` オブジェクトが使えるため、例えばツールチップ内で「〇〇〜〇〇 (合計△△)」のように開始・終了・差分をまとめて表示するといった高度なこともできます。

ツールチップとデータラベルは用途に応じて使い分けます。**常に表示しておきたい重要な数値はデータラベル**にし、**詳細な補足情報や複数項目の一覧はツールチップ**に任せると良いでしょう。なお、データラベルをオフにしてもツールチップには影響ありません。また逆にデータラベルをオンにしている場合でも、ツールチップにはシリーズ名など追加情報が表示されるため両方併用するケースもあります。ユーザビリティに応じて調整してください。

## 3. スタイルと視覚表現

rangeBar チャートの見た目を調整するための主なポイントを解説します。

### 色の指定（シリーズ単位・データポイント単位の設定）

ApexChartsでは**シリーズごと**あるいは**データポイントごと**に色を設定することができます。デフォルトでは用意されたカラーパレットに従い系列ごとに異なる色が割り当てられますが、必要に応じて以下のようにカスタマイズします。

* **シリーズ単位の色指定**: オプションのルートに `colors: ['#FF4560', '#008FFB', ...]` のような配列を設定すると、系列順にその配列の色が適用されます（ここでの系列順とは `series` 配列内のインデックス順）。例えば2系列あれば、`colors: ['#00E396', '#0090FF']` とすることで1系列目の全バーが緑、2系列目が青で描画されます。また各シリーズオブジェクト自体に `color` プロパティを指定しても同様の効果があります（React/Vueラッパーではprops経由で指定可能）。

* **データポイント単位の色指定**: 一つの系列内で個々のバーごとに色を変えたい場合、データ配列中のオブジェクトに直接 `fillColor` プロパティを指定します。例えば:

  ```js
  series: [{
    data: [
      { x: 'Phase 1', y: [30, 40], fillColor: '#775DD0' },
      { x: 'Phase 2', y: [40, 80], fillColor: '#00E396' },
      { x: 'Phase 3', y: [80, 90], fillColor: '#00E396' },
      { x: 'Phase 4', y: [90, 120], fillColor: '#775DD0' }
    ]
  }]
  ```

  上記のように設定すると、`Phase 1`と`Phase 4`のバーは紫色、それ以外は緑色といった**点ごとの色分け**が可能です。 これは特定条件で色分けしたい場合（例えばON区間は緑、OFF区間は赤など）に有用です。なお、`plotOptions.bar.distributed: true` を設定すると**自動的に各データポイントに異なる色**が割り当てられます（この場合、`colors` 配列の色が順番にデータに適用されます）。ただし distributed モードは単一シリーズ内の棒グラフ全般に適用される挙動であり、rangeBarでも機能しますが任意の色制御をしたい場合は上記のように `fillColor` を明示する方法が確実です。

* **枠線やマーカーの色**: rangeBarでは通常棒の塗りつぶし色のみ指定しますが、`stroke` オプションで**枠線色**や太さも指定できます。デフォルトでは枠線は透明(0px)なので見えませんが、例えば「開始値＝終了値で長さ0のバーを可視化したい」場合などは `stroke: { width: 1, colors: ['#000'] }` のようにすると、長さ0でも細い線が描かれるようになります。また `isDumbbell: true` にしている場合は両端の丸いマーカー色を `dumbbellColors` で指定できます。

### `fill`・`gradient` オプションの使い方

`fill` オプションでは、バーの塗りつぶしスタイルを細かく制御できます。単純な色指定以外に、**グラデーション**や**パターン**、**画像**による塗りつぶしも可能です。

* **単色塗りつぶし (solid)**: これはデフォルトの塗りつぶしタイプで、特に指定しなくても `colors` で与えた色やデフォルトパレット色で塗られます。明示的に指定する場合は `fill: { type: 'solid', colors: ['#FF4560', ...] }` のように書きます。`colors` をここで指定すると先述の全体`colors`指定を上書きします（系列ごと、あるいは関数を用いて値に応じた動的色指定も可能）。

* **グラデーション塗りつぶし**: よりリッチな表現をしたい場合、`fill: { type: 'gradient', gradient: { ... } }` を設定します。`gradient`オブジェクト内ではグラデーションの方向（`shade` と `type`）、濃淡の強さ（`shadeIntensity`）、開始色・終了色（`gradientToColors` または `inverseColors` 等）、不透明度（`opacityFrom` / `opacityTo`）などを細かく制御できます。例えば水平バーに左→右のグラデーションを掛けたい場合:

  ```js
  fill: {
    type: 'gradient',
    gradient: {
      shade: 'light',
      type: 'horizontal', // 横方向にグラデーション
      shadeIntensity: 0.5,
      gradientToColors: undefined, // 終了色を自動（colors配列の次の色かinverseColorsによる）
      inverseColors: true,
      opacityFrom: 0.9,
      opacityTo: 0.1,
      stops: [0, 100]
    }
  }
  ```

  上記のようにすると、各バーが左端濃い目・右端透明に近いグラデーションで描画されます（カラーはデフォルト色に基づきます）。`type` は `'horizontal'` の他 `'vertical'` や斜め方向（`diagonal1`/`diagonal2`）も選択可能です。`gradientToColors` に具体的な色配列を指定すると各系列の終了色を自由に決められます。

* **パターン塗りつぶし**: `fill: { type: 'pattern', pattern: { style: '...'} }` を指定するとストライプやドットなどのパターンでバーを塗りつぶせます。パターンは `verticalLines` や `horizontalLines` などいくつかプリセットがあり、カスタムSVGパスで独自パターンを定義することも可能です。例えば背景用途や印刷時の白黒区別用に使えます。

* **画像塗りつぶし**: `fill: { type: 'image', image: { src: ['image.png'] } }` のようにすると、指定した画像でバーをタイル状に塗りつぶします。特殊な用途ですが、バーにテクスチャを入れたい場合などに使えます。

通常の業務データ可視化では単色かグラデーション指定が主でしょう。**グラデーションは微妙な強調**（例えば期間の開始と終了で色味を変えることで変化を示唆する等）に有用です。一方、色分け自体で意味を持たせたい場合（例えばON/OFFで色違い）は**単色を分ける**方が凡例などとも連動し分かりやすいでしょう。

### 棒の高さやグループ化（`barHeight`, `rangeBarGroupRows`, `rangeBarOverlap`）

棒（バー）の表示に関するレイアウト調整です。

* **バーの太さ (`barHeight`)**: 先述しましたが、特に**横向きレンジバー**の場合にバーの太さを `%` で調整できます。例えばタイムラインチャートでカテゴリ（行）間のスペースが大きいと感じたら `barHeight: '80%'` などとするとバーが太くなり隙間が減ります。逆にバー同士を間引いて細く表示したければ `30%` などとします。複数シリーズをグループ表示する場合、それぞれのバーが行内に並ぶため自ずと細く配置されますが、その場合でも `barHeight` は**各シリーズ束全体**の高さ割合として機能します（各バー個別の太さは自動計算）。

* **バーの重なり (`rangeBarOverlap`)**: 複数系列で同じカテゴリ・重複時間帯のバーがある場合に、それらを重ねて表示するか制御します。デフォルトは `false` で、重複があると自動的にスタックしないよう縦方向に並べて表示されます。しかし `rangeBarOverlap: true`を指定すると、**同じ行に重複するバーがオーバーレイ表示**されます。例えば同じ人物のスケジュールバーが二重に重なるなどのケースです。この設定を使う際は、重なったバー同士が区別できるように色や透明度を工夫する必要があります（例えば片方を半透明にする、枠線を付ける等）。逆に、デフォルト動作では**重複があると自動で縦に分かれて描画**されますが、これは一見すると「スタック表示」にも似ています。重ならない場合は1行1バー、重なると2行目が出現、といった挙動になるため、どちらの見せ方が適切かは目的次第です。

* **行のグループ化 (`rangeBarGroupRows`)**: 複数系列で**同じカテゴリ名**を持つデータをまとめる場合に使用します。`true` にすると、系列に関わらず同名xカテゴリは一つの行に統合され、その行内で複数のバーが並びます。例えばシリーズ1が「MachineA: 稼働時間」、シリーズ2が「MachineA: 故障時間」というデータを持っている場合、`rangeBarGroupRows: true` なら MachineA の行が1つだけできてその中に2本のバー（稼働と故障）が描画されます。`false` ならシリーズ別にMachineA行が2つできてしまいます。**重複していない独立した期間**であればグループ化することで見やすくなります（重複する場合は上述のoverlapと組み合わせるか、系列を分けず一つに統合するなど設計を再考する必要があります）。

以上の設定を駆使すると、**縦方向の間隔**や**系列間のレイアウト**を細かく制御できます。例えば「項目ごとに1行にまとめて、その中に複数の期間バーを配置したタイムライン」を作りたい場合、`horizontal: true, rangeBarGroupRows: true` とし、重複が無ければOK、万一重複するなら `rangeBarOverlap: true` も検討、といった形になります。

### ラベルの見た目調整（折り返し、省略、スタイル指定など）

軸ラベルやデータラベルのテキスト表示が長い場合の対策や、スタイル調整についてです。

* **軸ラベルの折り返し/省略**: カテゴリ名が長い場合、デフォルトでは横軸（または縦軸）の領域からはみ出すと自動で `...` に省略されます。これは `xaxis.labels.trim` オプションが既定で有効なためで、複数行表示（折り返し）はデフォルトでは行われません。もし**省略せずに表示させたい**場合は `xaxis.labels.trim: false` と設定します。省略を無効にすると、テキスト全体が表示されますが、長すぎると軸エリアからはみ出す恐れがあるため注意です。残念ながらSVG描画上、テキストの自動折り返しはサポートされていません。ただし、代替策として軸ラベル用の文字列に改行文字（例えば `"Sensor\nName"`）を入れておくと、擬似的に2行に見せることができます。これは実際には1つのテキスト要素で表示されるため見た目上の調整となります。ApexCharts公式でも「カテゴリ文字列を工夫して<br>タグ等を挿入することで複数行表示に見せる方法」が紹介されています。したがって、**長いラベルは適宜短縮した文言を用意する**か、**CSSでフォントサイズを小さくする**（`xaxis.labels.style.fontSize`で変更可）などで対処すると良いでしょう。

* **軸ラベル・データラベルのスタイル**: フォントサイズや色、フォントファミリなどはオプションで指定可能です。`xaxis.labels.style` 内で `colors`, `fontSize`, `fontWeight`, `cssClass` などを設定すれば軸ラベルに反映されます。同様に `yaxis.labels.style`（横軸がカテゴリの場合はこちらがカテゴリラベルとなる）も指定できます。データラベルについても `dataLabels.style` で `fontSize` や `colors` を配列で与え、個別に色分けすることも可能です。例えば `dataLabels.style.colors: ['#000']` とすればラベル文字色を黒に統一します。

* **ラベルと表示領域**: `xaxis.labels.hideOverlapping` を有効にすると、ラベル同士が重なりそうな場合に自動で一部のラベルを非表示にして衝突を避けます。これは主に縦軸（カテゴリ軸で横に長いラベルが縦方向に並ぶとき）で有効ですが、rangeBarのタイムラインではあまり起きないかもしれません。`tooltip`を活用すれば軸ラベルを簡略化しても詳細をホバーで補足できるため、**軸ラベルは短め・省略気味にし、詳細はツールチップやデータラベルで提供**という設計もよく使われます。

* **その他**: 軸タイトル（軸全体の見出し）を付ける場合、`xaxis.title.text`, `yaxis.title.text` に文字列を指定します。yaxis.title は自動で90度回転して表示されますが、オプションで位置調整も可能です。凡例（legend）を使う場合は系列名がそのまま表示されるため、系列名を工夫することで説明的なラベルとして活用できます。Vuetify等と組み合わせる際は、フォントをUIと統一するために `chart.fontFamily` を設定したり、CSSで `.apexcharts-tooltip` クラスや `.apexcharts-xaxis-label` クラスにスタイルを当てることでデザイン統一を図ることもあります。

## 4. インタラクション制御

rangeBar チャートを動的・対話的に扱うためのテクニックを紹介します。ツールチップのカスタマイズやイベントハンドリングによって、ユーザーにとって使いやすいチャートを実現できます。

### ツールチップのカスタマイズ（表示形式・formatter関数の利用）

ツールチップ（ホバー時の情報吹き出し）は前述の通り `tooltip` オプションで制御しますが、特に**日時のフォーマット**や**値の単位**などを揃えるためにカスタマイズすることが多いです。

* **x値（カテゴリ/日時）のフォーマット**: `tooltip.x.format` に日時書式（例：`"yyyy/MM/dd HH:mm"`）を指定すると、その形式でx軸値が表示されます。これは `xaxis.labels.format` と似ていますが、**ツールチップ専用**の設定であり、軸ラベルと異なるフォーマットを表示できます（例えば軸は「月日」のみ、ツールチップでは「年月日 時:分:秒」まで詳細表示など）。さらに細かな制御が必要なら `tooltip.x.formatter` を使い、関数内で`val`（xの値）を受け取って好きな文字列を返します。カテゴリ軸の場合、`val` にはカテゴリ名（文字列）が入ります。日時軸の場合、`val` はデフォルトフォーマット済みの文字列、`opts` 引数経由で生のtimestampも取得できます。公式ドキュメントによると、xaxisのカスタムformatterを指定するとtooltipもそれに準じた表示になるため、必要に応じてtooltip用formatterで上書きする、といった使い分けが推奨されています。

* **y値（範囲）のフォーマット**: rangeBarではy値が配列ですが、tooltip表示時には開始と終了が自動的に`「[開始] - [終了]」`の形式で表示されます。この両者の数値フォーマット（例えば小数点や単位）は、`tooltip.y.formatter` で制御可能です。ただし、tooltip.y.formatter関数の第1引数`value`には**配列ではなく単一の値**が入ってくる点に注意してください（通常は終了値と思われます）。rangeBar特有の事情として、デフォルト実装では開始値と終了値の双方をまとめて1つの文字列にして表示しているため、単純なformatterでは一方の値しか受け取れません。そこで、必要に応じて `tooltip.custom` という完全カスタム描画用の関数を使用できます。`tooltip.custom`を使うと、ツールチップのHTMLを自前で構築でき、`seriesIndex`・`dataPointIndex`ごとに自由な情報を表示できます。例えば以下のようにして開始・終了を個別に取得して表示することが可能です:

  ```js
  tooltip: {
    custom: function({ series, seriesIndex, dataPointIndex, w }) {
      const d = w.config.series[seriesIndex].data[dataPointIndex];
      const [start, end] = d.y;
      return (
        '<div class="arrow_box">' +
        `<span>${d.x}: ${start}〜${end} (${series[seriesIndex][dataPointIndex]}秒)</span>` +
        '</div>'
      );
    }
  }
  ```

  上記は一例ですが、`w`オブジェクトから元データや計算値を取り出し、HTML文字列を返しています。`series[seriesIndex][dataPointIndex]`にはおそらく終了値が格納されていますが、必要なら開始値との差を計算して「期間（秒）」を表示するといったことも可能です。customツールチップを使うと完全にレイアウトも自由になりますが、スタイルの適用にはCSSで `.arrow_box` などクラス指定する必要があります。まずはシンプルに `tooltip.x.format` や `tooltip.y.formatter` で事足りるケースが多いので、それでも表現できない場合に custom の実装を検討しましょう。

* **シリーズ名や追加情報**: `tooltip.y.title.formatter` を指定すると、デフォルトではシリーズ名が表示される箇所も任意の文字列に変えられます。例えばシリーズ名「温度」を「温度(℃)」としたり、あるいはシリーズ名とは関係ない固定文言を付けるといった使い方ができます。ただしrangeBarでは系列名よりも各バーのカテゴリ名の方が重要度が高いことも多いため、ツールチップにシリーズ名を出さずカテゴリや期間中心にしたい場合は、単にシリーズ名を空文字にするか、あるいはtooltip.custom内で構築する方法が考えられます。

### `dataLabels.formatter` による区間情報の表示調整

データラベルについては既にフォーマッタの例を示しましたが、rangeBar特有の工夫点を補足します。

* **区間長や状態の表示**: データラベルformatter内では `val` と各種インデックス情報が得られるので、**区間の長さ（終了-開始）**を計算して表示したり、あるいは**状態名**を表示することも可能です。例えばセンサーのON/OFF状態を表すチャートの場合、`y`値として数値の代わりにONを1、OFFを0などとして区間データを作るよりも、単に時間帯だけをバーで表し、ラベルに「ON期間」「OFF期間」と文字で表示する方がわかりやすいでしょう。その場合、データオブジェクトに例えば `{ x: "Sensor1", y: [startTime, endTime], state: "ON" }` のように独自フィールド `state` を加えておき、formatterで `w.config.series[seriesIndex].data[dataPointIndex].state` を参照して返す方法があります。ApexChartsは与えたオブジェクト内の知らないフィールドは無視しますが`w.config`経由では参照できるので、このようにカスタムデータを埋め込んで表示に活用できます。

* **条件によるスタイル変更**: formatter内では単に文字列を返すだけですが、`dataLabels.style.colors` を関数配列で指定しておくことで値に応じた色変更も可能です。例えば `dataLabels.style.colors: [ function({ value, seriesIndex, dataPointIndex, w }) { return value > 100 ? "#FF0000" : "#000000"; } ]` のようにすると、値が100を超えるラベルは赤、それ以外は黒、といった色分けができます（rangeBarではvalueは終了値になりますので注意）。しかし区間全体に対する条件分岐はやや難しいため、単色でよければ上記の独自フィールド（例えば state を "ON"/"OFF" として、それによって色分けする等）を活用する方法も考えられます。

* **表示非表示の切替**: `dataLabels.enabledOnSeries` オプションを使うと、複数系列のうち特定の系列にのみラベルを表示できます。例えば2系列ある内の1系列目だけラベル表示したい場合、`enabledOnSeries: [0]` と指定します（0始まりのインデックス）。これにより不要なラベルを減らしつつ必要な情報だけ表示できます。rangeBarのタイムラインでは通常1系列に全データを入れることが多いですが、もし複数系列（例えば複数のセンサー種別など）を重ねている場合に活用できます。

### クリックイベントでのデータ取得と動作追加 (`plotOptions.bar.events.click` など)

レンジバーをクリックした際に何らかのアクションを起こしたい場合、ApexChartsのイベント機能を利用できます。特にVue.jsで構築している場合、クリックで詳細ダイアログを出す・別コンポーネントに反映させる等のニーズが考えられます。

* **データポイント選択イベント**: 最も直接的なのは `chart.events.dataPointSelection` です。これはユーザーがバー（データポイント）をクリックしたときに呼び出されるイベントで、イベントハンドラに `(event, chartContext, config)` が渡されます。`config.seriesIndex` や `config.dataPointIndex` からクリックされた系列とデータのインデックスが取得できます。また、`chartContext.w.globals` 内にカテゴリラベルの配列や各種データが格納されているため、それを用いて「どのバーがクリックされたか」を特定できます。例えば:

  ```js
  chart: {
    events: {
      dataPointSelection: function(event, chartContext, config) {
        const seriesIndex = config.seriesIndex;
        const dataIndex = config.dataPointIndex;
        const category = chartContext.w.globals.labels[dataIndex];
        alert(`"${category}"のバー（シリーズ${seriesIndex}）がクリックされました`);
      }
    }
  }
  ```

  上記のようにすると、クリック時にそのバーのカテゴリ名をアラート表示します。実際にはalertではなく、Vueなら `$emit` やVuexのmutationを呼ぶ、あるいは予め渡しておいたコールバックを呼ぶなどして他の処理につなげます。

* **プロットオプション経由のイベント**: ApexChartsでは `plotOptions.bar.events.click` という設定も存在し、これを使ってもバークリックを検知できます。書き方は上記とほぼ同様で、例えば:

  ```js
  plotOptions: {
    bar: {
      events: {
        click: function(event, chartContext, config) {
          console.log("clicked series:", config.seriesIndex, "data:", config.dataPointIndex);
        }
      }
    }
  }
  ```

  といった具合です。`config` オブジェクトの中身は `dataPointSelection` のときと似ています（seriesIndexやdataPointIndex等が含まれる）。どちらかといえば `chart.events.dataPointSelection` の方が公式に推奨されているイベントですが、`plotOptions.bar.events.click` は**バー/カラム系チャート限定**で軽量に定義できるため、rangeBarでも機能します。内部的な違いはあまり気にせず、都合の良い方を使って構いません。Vueのラッパー（vue-apexcharts）でもこれらイベントはoptions経由で渡せます。

* **取得できる情報と活用**: `config` から取得できるインデックスを使って、元のデータを参照したり任意の処理に結びつけたりします。例えば先ほどデータオブジェクトに独自フィールド `state` を入れていた場合、`chartContext.w.config.series[seriesIndex].data[dataPointIndex].state` でその値を得られます。これを使って「クリックされたバーの状態がOFFなら詳細フォームを開く」といった条件分岐も可能です。また、単にconsole.logで `chartContext` や `config` を出力してみると中身を確認できますので、開発時には一度試してみることをお勧めします。

* **他のイベント**: この他にも `dataPointMouseEnter`（ホバーしたとき）や `legendClick`（凡例クリック時）、`zoomed`（ズーム操作完了時）など様々なイベントが用意されています。rangeBar特有のイベントはありませんが、一般的な棒グラフと同様に利用できます。例えば **長押しやドラッグで区間を選択**するといった機能は標準ではありませんが、クリックイベントで開始・終了を取得し、別途実装することも考えられます。

最後に、**Vue.jsやVuetifyとの連携**について触れておきます。Vue環境では公式の `vue-apexcharts` コンポーネントを用いてチャートを描画できます。この場合、本稿で述べた `options` オブジェクトと `series` 配列をそれぞれコンポーネントのプロパティにバインドし、Vueのデータや算出プロパティからそれらを生成・管理します。rangeBarチャートのオプションも同様に設定可能です。Vuetifyとは直接関係ありませんが、例えばVuetifyのカード内にチャートを入れたり、テーマカラーをApexChartsの色に適用したりといった統合が考えられます。クリックイベントでVuetifyのダイアログ（モーダル）を開くなども、上記イベントハンドラ内でVueのメソッドを呼べば実現できます。**重要なのは**、ApexChartsのオプションを適切に設定することで、センサーのON/OFFタイムラインのようなユースケースでもスムーズに動作するチャートが作れるという点です。本記事のベストプラクティスを踏まえ、視認性が高くインタラクティブなrangeBarチャートを是非活用してみてください。

### 参考文献・情報源

* ApexCharts 公式ドキュメント（Range Bar Chart ガイド）
* ApexCharts 公式オプションリファレンス（plotOptions.bar 等）
* ApexCharts 公式ドキュメント（Datetime軸の扱い）
* 開発者ブログ記事: ApexChartsのRangeBarで同じ値の区間を表示する方法（rangeBarで幅0のバーを見せるテクニック）
* GitHub Issues / StackOverflow: ApexChartsのデータポイントごとの色指定例、クリックイベントの活用例 など.
