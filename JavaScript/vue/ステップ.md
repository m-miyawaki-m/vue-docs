了解です。JavaScript + jQuery の経験者が業務開発を見据えて Vue を学ぶために、ステップ1（Vueの基礎を理解する）に関する各項目を丁寧に解説し、具体例を交えたレポート形式で深掘りしていきます。

調査が完了したら、実務目線で理解しやすいように構造化されたレポートをお届けします。少々お待ちください。

# jQuery開発者のためのVue.js基礎ガイド（学習ロードマップ Step 1）

## 1. Vueとは何か？ReactやAngularとの比較

**Vue.jsの概要:** Vue.jsは、Evan You氏によって開発された**プログレッシブなJavaScriptフレームワーク**です。プログレッシブとは「徐々に導入できる」という意味で、必要に応じて段階的に適用できる柔軟さを持ちます。実際、Vueは既存のアプリに組み込んで段階的に機能拡張することも、一からシングルページアプリケーション(SPA)全体を構築することも可能です ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=Vue%20is%20a%20modern%20JavaScript,for%20a%20library%20like%20jQuery))。jQueryのように既存のHTMLに対して動的な機能を付加する用途でも利用でき、「徐々に導入できるフレームワーク」という特性から**jQueryの代替**として既存プロジェクトにドロップインして使うこともできます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=Vue%20is%20a%20modern%20JavaScript,for%20a%20library%20like%20jQuery))。一方で、必要に応じて公式のルーティングや状態管理ライブラリ（Vue RouterやPiniaなど）を追加し、本格的なSPA開発へ移行することもできます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=That%20being%20said%2C%20you%20can,they%20better%20fit%20your%20application))。Vueはテンプレートベースの宣言的な構文と、コンポーネント指向のアーキテクチャ、そして**リアクティブシステム**（後述）によるデータとUIの自動同期を特徴としています。これにより、開発者はデータの変更に専念すれば、VueがDOM更新を最小限の差分で自動的に行ってくれます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=Vue%20uses%20an%20HTML,compliant%20browsers%20and%20HTML%20parsers))。

**他フレームワークとの比較:** フロントエンドの主要な選択肢としてはReactやAngularもよく比較に挙がります。それぞれ性質が異なるため、Vueとの違いを押さえておきましょう ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。

- **React:** Facebook社（現在のMeta社）によって開発されたUIライブラリです。Reactはビューの構築に特化した**ライブラリ**であり、コンポーネントをJSX（JavaScript内にXMLライクな構文を書く手法）で記述します ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。状態管理やルーティングはReact本体に含まれないため、必要に応じReduxやReact Routerなど外部ライブラリと組み合わせてSPAを構築します。学習コストは中程度で、JavaScriptと若干の独自記法（JSXやフックAPIなど）に慣れる必要があります ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。Reactは**仮想DOM（Virtual DOM）**によって効率的に差分レンダリングを行うのが特徴で、状態変化時にUIを再描画する際、実DOMに直接触れず仮想DOM上で差分計算して必要最小限の更新をします。これはVueも同様で、VueもReact同様にVirtual DOMを用いた高速なレンダリングを実現しています ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=))。

- **Angular:** Google社によって開発・保守されている**フルスタックなフレームワーク**です。Angular（特にAngular 2以降、いわゆるAngularと呼ばれるもの）はTypeScriptを標準採用しており、大規模アプリケーション向けに設計されています ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。テンプレート構文や双方向データバインディングの概念はVueにも通じるものがありますが、依存性注入（DI）やフォームバリデーション、HTTPクライアントモジュールなど**多くの機能が内蔵**されているのが特徴です。そのぶん学習難易度は高め（Steep）で、プロジェクトに導入する際の初期設定や作業も大きくなりがちです ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。AngularはAngularJS（初期のバージョン1系）とは別物のモダンフレームワークとなっており、現在ではコンポーネント指向とリアクティブプログラミング（最近のバージョンではSignalsというリアクティブ機構も導入）を備えています。しかしVueやReactと比べると柔軟性より**規約重視**で、「やり方が決まっている」フレームワークと言えます。例えばVueやReactが必要なライブラリを選んで組み合わせるのに対し、Angularは最初から多機能で包括的です。そのため、小〜中規模のアプリにはやや重厚すぎる場合がありますが、大規模開発では統一されたアプローチで開発を進められる利点があります ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=))。

- **Vue:** Vueは上述の通り**フレームワークとライブラリの中間**のような位置付けです ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。公式には「The Progressive JavaScript Framework（漸進的なフレームワーク）」と謳われており、必要最小限のコア機能（リアクティブな状態管理、テンプレートによるUI構築、コンポーネント）に集中しつつ、ルータや状態管理(Vuexの後継であるPinia)などは必要に応じて採用できます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=That%20being%20said%2C%20you%20can,they%20better%20fit%20your%20application))。学習コストは比較的低く、「習得しやすい (Easy)」と評価されることが多いです ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy))。これはVueがHTMLベースのテンプレート記法を採用しており、従来のHTML/CSS/JSの延長で直感的に理解できる部分が大きいためです。実際、jQueryで頻出する「DOM操作をして要素を表示/非表示にする」「イベントを検知して処理を行う」といった作業が、Vueではテンプレート上のディレクティブやバインディングによって宣言的に記述でき、DOM操作の細部を意識せずに実現できます。また、ReactのVirtual DOMやAngularの双方向バインディングの長所を取り入れており、**シンプルさと性能を両立**したデザインになっています。Vueは特定企業のプロダクトではなく、コミュニティ主導でメンテナンスされているオープンソースプロジェクトですが、非常に情熱的なコミュニティに支えられており、公式フォーラムやDiscord、多数のプラグインエコシステムも充実しています ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=))。

**jQueryとの違い:** 質問の対象読者はjQuery経験者とのことなので、jQueryとの比較にも触れておきます。jQueryはDOM要素の操作を簡便にする**ユーティリティライブラリ**であり、開発者が明示的に`$("#elem").text("new")`のようなコードを書いてDOMを書き換える「命令的（インペラティブ）な」アプローチです。Vueでは、開発者はDOM要素に対し直接操作を行わず、**データの状態を宣言的に記述**します。例えば、画面に表示するテキストを更新する場合、jQueryでは該当要素を選択してテキストを更新しますが、Vueではそのテキストに対応するデータプロパティを変更するだけです ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=When%20dealing%20with%20forms%20on,bindings%20and%20change%20event%20listeners)) ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=The%20%60v,simplify%20the%20above%20to))。変更後のDOM更新はVueのリアクティブシステムにより自動で行われます。この違いにより、jQueryよりも**状態遷移が追いやすく保守しやすい**コード構造になります。特に複雑なUIや複数要素にまたがる状態管理では、jQueryだとDOMの変更箇所をすべて把握・記述する必要がありますが、VueではデータとUIの同期がフレームワークによって保証されるため、ロジックに集中できる利点があります。

## 2. Vue 3の新機能とVue 2との違い

Vueは2020年にリリースされたバージョン3系(Vue 3)によって、パフォーマンスの向上や開発体験の改善が図られました。Vue 2からVue 3への主な変更点と新機能を押さえておきましょう。

- **Composition APIの導入:** Vue 3で最も注目された新機能が**Composition API**です。Vue 2まではオプションAPI（`data`, `methods`, `computed`, `mounted`などオプションオブジェクトに各種プロパティを定義するスタイル）でコンポーネントを記述するのが基本でした。小規模なコンポーネントではオプションAPIでも十分でしたが、コンポーネントが大きくなるにつれ関連するロジックがオプションごとに分散し、可読性が下がる課題がありました。Composition APIでは、`setup()`関数内で状態やメソッドをまとめて定義でき、機能ごとにコードをグルーピングしやすくなります (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,maintainability%20and%20reusability%20of%20code))。たとえば、ある機能に関連するデータ・メソッド・副作用処理を一箇所にまとめて記述できるため、コンポーネントの可読性と再利用性が向上します (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,maintainability%20and%20reusability%20of%20code))。特に大規模アプリケーションではComposition APIによってコードの構造化がしやすくなり、mixinsに頼らずロジックの共有が可能になりました。Vue 3では従来のオプションAPIも引き続きサポートされていますが、公式ガイドではComposition APIが**ベストプラクティス**として推奨されています ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=%2A%20React%20,from%20the%20old%20Options%20API))。また、`<script setup>`記法（SFC内でより簡潔にComposition APIを扱う構文）も導入され、ボイラープレートを削減しています。

- **新しいリアクティブシステム:** Vue 3ではリアクティブシステムの実装が刷新されました。Vue 2では`Object.defineProperty`を用いてデータオブジェクトのプロパティにgetter/setterを仕込み、変更検知を行っていましたが、この方法ではオブジェクトに新しいプロパティが追加された場合にリアクティブに検知できない（`Vue.set`で追加する必要がある）などの制限がありました。Vue 3ではよりモダンな**Proxyオブジェクト**を利用することで、オブジェクト全体をラップしプロパティの追加・削除も含めて変更を捕捉できます (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,has))。Proxyベースの実装により、深いネストのオブジェクトでも変更検知性能が向上し、大規模データの扱いでもより効率的になっています (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,has))。この変更に伴い、Vue 2で必要だった`Vue.set`や`Vue.delete`といったAPIは不要になり、JavaScriptの通常のオブジェクト操作でリアクティブデータを扱えるようになりました。

- **パフォーマンスとバンドルサイズの改善:** Vue 3は内部実装の最適化により、レンダリング性能が向上しフレームワーク自体のサイズも削減されています (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,optimizations%20that%20significantly%20boost%20performance))。仮想DOMのレンダリングアルゴリズムが改善され、特に大規模コンポーネントや大量のDOM要素を扱う場合にVue 2より高速になっています (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,bundle%20by%20removing%20unused%20code))。また、Vue 3はモジュールバンドラによる**ツリーシェイキング**に対応し、未使用の機能をビルドから自動的に除外できる設計になっています (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,bundle%20by%20removing%20unused%20code))。その結果、必要な機能だけを含んだ最適なバンドルサイズを実現できます。

- **TypeScriptサポートの強化:** Vue 3は開発段階からTypeScriptで書かれており、TypeScriptのサポートが格段に向上しました (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,seamless%20and%20requires%20additional%20configuration))。Vue 2でもTS利用は可能でしたが型定義ファイルの用意や手作業の設定が必要でした。Vue 3では公式が型定義を完備しており、コンポーネントやComposition APIの各種関数（`ref`, `reactive`等）に対して型推論が効くため、エディタ支援やバグ検出が改善しています (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,seamless%20and%20requires%20additional%20configuration))。そのため、**大型プロジェクトでの開発体験向上**や堅牢性の強化に寄与しています。

- **複数ルート要素・Teleport・Suspense:** Vue 2では制約として「コンポーネントのテンプレートは単一のルート要素しか持てない」というものがありました。Vue 3では**Fragment**機能により、テンプレート直下に複数の要素を並べることが可能になりました (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,Fragment%2C%20Teleport%2C%20and%20Suspense))。これにより不要なラッパー要素を作らずに済み、柔軟なマークアップができます。同時に、モーダルダイアログなど特定のDOMツリー外にコンテンツを描画したい場合のために**Teleport**が導入され、例えばコンポーネントの内容を`<body>`直下など別の場所に描画できます (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,loaded%20components)) (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=))。さらに、非同期コンポーネントの読み込み中にフォールバックUIを表示するための**Suspense**コンポーネントも追加され、ユーザー体験を損なわずに遅延ロードを扱えるようになりました (["Vue 2 vs Vue 3: A Comprehensive Analysis of Key Differences, Improvements, and Performance Optimizations" - DEV Community](https://dev.to/xm__/vue-2-vs-vue-3-a-comprehensive-analysis-of-key-differences-improvements-and-performance-43ep#:~:text=,Fragment%2C%20Teleport%2C%20and%20Suspense))。

- **その他の改善:** このほか、Vue 3ではカスタムディレクティブやグローバルAPIの整理（Vue 2での`Vue.mixin`などは必要時にインポートして使う形式へ変更）、Composition APIと相性の良い新しいライフサイクルフック（`onMounted`等のフック関数）追加、`v-model`ディレクティブの拡張（カスタムコンポーネントでのv-model使用方法の変更）など多くの改良があります。全体としてVue 3はVue 2との**後方互換性に配慮しつつも進化**を遂げており、Vue 2から段階的に移行できるよう公式の移行ガイドや互換ビルドも用意されました。

Vue 3系が現在主流となっており、新規プロジェクトでは基本的にVue 3を用いるのが推奨されています。Vue 2で書かれた既存プロジェクトに携わる際も、上記のような新機能・変更点を理解しておくと良いでしょう。

## 3. 開発環境の構築

Vue.jsを使った開発を始めるには、まずローカルの開発環境を準備する必要があります。特に**Node.jsとnpm**（Nodeに付属するパッケージマネージャ）は必須です。Node.jsはサーバサイドJavaScript実行環境ですが、フロントエンド開発においてはビルドツールやローカルサーバを実行するために利用します。Vueの公式CLIやビルドツールもNode上で動くため、まずはNode.jsをインストールしましょう。一般的には推奨版(LTS版)のNode.jsを導入し、npm（または同等のyarnなど）でプロジェクトのセットアップを行います。**Vue CLI**や**Vite**といったツールを使う際にも、これらはNode上でコマンドとして動作します。例えばVue公式ガイドでも「高度な機能を使うにはNode.jsとnpmをインストールする必要がある」とされています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=However%2C%20this%20approach%20has%20some,vue%60%20you%20will%20need))。

### Node.jsとnpmのインストール

1. **Node.jsのインストール:** Node.js公式サイトからインストーラをダウンロードしてインストールするか、`nvm`（Node Version Manager）等を使ってセットアップします。インストール後、ターミナル/コマンドプロンプトで`node -v`および`npm -v`を実行し、バージョンが表示されれば成功です。2024年時点ではNode.js 18系や20系のLTS版が安定版として利用できます。

2. **プロジェクト用ディレクトリの作成:** 任意の作業フォルダ上でVueプロジェクト用のディレクトリを作成します（例: `vue-app`）。

3. **npmでVueプロジェクトを初期化:** Vue 3では公式に`create-vue`というプロジェクト作成ツールが提供されています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=However%2C%20this%20approach%20has%20some,vue%60%20you%20will%20need))。これはVue CLI 3.x系に代わるもので、内部的に高速ビルドツールのViteを使用しています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=app,if%20you%20prefer%20Yarn))。使い方はターミナルでディレクトリを移動した上で以下のコマンドを実行します。

   ```bash
   npm create vue@latest
   ```

   もしくはyarn利用者であれば `yarn create vue@latest` と実行します ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=app,if%20you%20prefer%20Yarn))。実行すると、プロジェクト名や各種オプション（TypeScriptを使うか、Vue Routerを含めるか、Piniaを含めるか、テストセットアップを含めるか等）の質問が対話形式で表示されます。ガイドに沿って必要なオプションを選択すると、テンプレートプロジェクトの雛形が生成されます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=After%20choosing%20these%20options%2C%20your,you%20need%20to%20do%20this))。

4. **依存関係のインストールと開発サーバ起動:** プロジェクトが作成されたら、そのディレクトリに移動し`npm install`で依存パッケージをインストールします。その後、`npm run dev` を実行するとローカル開発サーバが起動し、ブラウザでアプリを表示できます。デフォルトでは http://localhost:5173 などに立ち上がるはずです（ポート番号は環境により異なる場合あり）。これでVueの開発環境が整いました。

### Vue CLI vs Vite の選択と理由

Vue 3登場以前から存在する公式ツールに**Vue CLI**があります。Vue CLIはグローバルnpmパッケージ（`@vue/cli`）としてインストールして使用するプロジェクト作成コマンドで、内部ではWebpackを用いてプロジェクトのひな型を生成してくれます。しかし2020年以降、より高速でシンプルなビルドツールである**Vite**が台頭し、現在ではVue公式も新規プロジェクトにはViteを使うことを推奨しています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=app,if%20you%20prefer%20Yarn)) ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=The%20%60create,you%20can%20easily%20run%20them))。Vue CLIとViteの違い、およびViteが選好される理由を整理しましょう。

- **Vue CLI（＋Webpack）:** Vue CLIはテンプレートプロジェクトを生成し、開発用にWebpackの設定一式を含んだプロジェクトを作成します。コマンド一発で基本構成が出来上がり便利ですが、Webpackベースのため**開発サーバの起動やホットリロード（HMR）の速度が遅め**という欠点がありました。プロジェクトが大規模になると、起動に数秒〜十数秒かかることもあります。また、追加のローダー設定（例えばSassを使うなら`sass-loader`のインストールと設定）など**環境構築に手間**がかかる場面もあります ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=1.%20%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89%E3%81%8C%E6%89%8B%E8%BB%BD%20Vue%20CLI%E3%81%AF%E3%81%82%E3%81%8F%E3%81%BE%E3%81%A7%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E4%BD%9C%E6%88%90%E3%83%84%E3%83%BC%E3%83%AB%E3%81%A7%E3%81%82%E3%82%8A%E3%80%81%E3%83%93%E3%83%AB%E3%83%89%E3%83%84%E3%83%BC%E3%83%AB%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E3%81%9F%E3%82%81%E3%80%81%E3%83%93%E3%83%AB%E3%83%89%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%ABwebpack%E3%81%A8Vue,loader%E3%81%AA%E3%81%A9%E9%96%8B%E7%99%BA%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%83%84%E3%83%BC%E3%83%AB%E3%82%92%E5%88%A5%E9%80%94%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%81%97%E3%81%A6%E3%81%84%E3%81%8F%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8B%E3%81%9F%E3%82%81%E3%80%81%E7%92%B0%E5%A2%83%E6%A7%8B%E7%AF%89%E3%82%92%E3%82%88%E3%82%8A%E6%89%8B%E8%BB%BD%E3%81%AB%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%A8%E3%81%84%E3%81%86%E7%82%B9%E3%80%82))。一方でWebpackは成熟したエコシステムを持ち、細かなカスタマイズが可能なため、既にWebpackに習熟している場合や特殊な設定が必要なケースでは引き続きVue CLI（Webpack）を選ぶ余地もあります。

- **Vite:** ViteはVueの作者であるEvan You氏が開発した次世代のフロントエンドビルドツールで、フランス語で「速い」という意味の名の通り**圧倒的な開発速度**を誇ります ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=%E3%80%8CVite%E3%80%8D%E3%81%A8%E3%81%AF))。Viteは開発時にはESモジュールを活用し、必要なモジュールだけを動的にロードする仕組みを持っているため、**開発サーバの起動が非常に速く（ほぼ瞬時）**、ファイル変更時のHMRもきわめて高速です ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=2)) ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=Vite%E3%81%AF%E3%83%95%E3%83%A9%E3%83%B3%E3%82%B9%E8%AA%9E%E3%81%A7,Replacement%E3%81%AE%E7%95%A5%E3%80%82%E7%94%BB%E9%9D%A2%E3%81%AE%E5%86%8D%E6%8F%8F%E7%94%BB%E7%84%A1%E3%81%97%E3%81%AB%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E6%9B%B4%E6%96%B0%E3%82%92%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%AB%E9%81%A9%E7%94%A8%E3%81%97%E3%81%A6%E3%81%8F%E3%82%8C%E3%82%8B%E6%A9%9F%E8%83%BD%E3%80%82%E3%83%9B%E3%83%83%E3%83%88%E3%83%AA%E3%83%AD%E3%83%BC%E3%83%89%E3%80%82%EF%BC%89%E3%82%92%E5%82%99%E3%81%88%E3%81%A6%E3%81%84%E3%82%8B%E3%80%82))。具体的な比較では、従来Vue CLI + Webpackで数秒かかっていた再ビルドが、Viteでは1秒未満で完了するといったレポートもあります ([「Vueが2021年時点で最も優れたフレームワークだと感じる理由を ...](https://www.ragate.co.jp/blog/articles/9086#:~:text=%E3%80%8CVue%E3%81%8C2021%E5%B9%B4%E6%99%82%E7%82%B9%E3%81%A7%E6%9C%80%E3%82%82%E5%84%AA%E3%82%8C%E3%81%9F%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%A0%E3%81%A8%E6%84%9F%E3%81%98%E3%82%8B%E7%90%86%E7%94%B1%E3%82%92%20,5%E7%A7%92%E3%81%A8%E3%81%8B%E3%81%AA%E3%82%8A%E6%97%A9%E3%81%8F%E3%81%AA%E3%81%A3%E3%81%9F%E3%81%A8%E3%81%82%E3%82%8A%E9%96%8B%E7%99%BA%E5%8A%B9%E7%8E%87%E3%81%8C%E6%A0%BC%E6%AE%B5%E3%81%AB%E4%B8%8A%E3%81%8C%E3%82%8B%E3%81%A8%E8%A8%80%E3%81%88%E3%81%BE%E3%81%99%E3%80%82%20VueJS))。また、Viteは設定ファイル（vite.config.js）がシンプルで、デフォルトでVueやReactのプロジェクトテンプレートやTypeScript/JSXサポートが組み込まれているため、追加の設定なしにモダンな開発環境を利用できます ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=%E3%80%8CVite%E3%80%8D%E3%81%A8%E3%81%AF))。必要に応じプラグイン拡張も可能ですが、Webpackに比べて概念的に理解しやすい作りになっています。

以上の点から、**新規にVue 3でプロジェクトを始めるならViteを選ぶのがベター**です ([プロジェクト作成ツール「Vue CLI」と「Vite」 #Vue.js - Qiita](https://qiita.com/Maro1027/items/a7abb77240b953342d19#:~:text=%E7%B5%90%E8%AB%96))。実際、先述の`npm create vue@latest`（create-vue）は内部でViteを利用してプロジェクトを構成しており、公式もViteベースへの移行を進めています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=The%20%60create,you%20can%20easily%20run%20them))。Vue CLIは既存のVue 2系プロジェクトやWebpackエcosystem特有のプラグインを活用している場合に限って検討し、新規開発ではその簡便さ・速度からViteを使うことをおすすめします。

*補足:* 既存のVue CLI（Webpack）プロジェクトをViteに移行する手順もコミュニティから提供されています ([Vue-cli から Vite へ移行ガイド｜そんちゃー君 - note](https://note.com/mz700/n/nf9060516fef3#:~:text=Vue,cli%20%E7%B8%9B%E3%82%8A%E3%81%AA%E3%83%A2%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AB%E3%81%8C%E9%9D%9E%E5%AF%BE%E5%BF%9C))。将来的にVue CLIの公式サポートが段階的に縮小されていく可能性もありますので、長期的にはViteへの切り替えを見据えておくと良いでしょう。

## 4. Vueプロジェクトの基本構成

プロジェクトを作成したら、典型的なVueプロジェクトのディレクトリ構成と主要ファイルの役割を理解しましょう。Vue CLIやViteで生成されるプロジェクトには共通して`src`フォルダがあり、その中にアプリケーションのソースコードがまとまっています ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,core%20of%20your%20Vue%20app))。ここでは特に重要な`main.js`、`App.vue`、`components/`ディレクトリについて解説します（他にも`index.html`や`package.json`、設定ファイルなどがありますが、要点に絞ります）。

- **`main.js`: エントリポイント**  
  アプリケーションのエントリポイントとなるファイルです。Vueインスタンス（Vue 2の場合）やアプリ（Vue 3の場合）を作成し、どのHTML要素にマウント（紐付け）するかを指定します ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,just%20has%20one%20example%20component))。例えばVue 3 + Viteのプロジェクトでは、`src/main.js`に以下のようなコードが入っています。

  ```javascript
  import { createApp } from 'vue';
  import App from './App.vue';

  createApp(App).mount('#app');
  ```

  このコードは、Vueアプリケーションを生成し、ルートコンポーネントとして`App.vue`を指定して、`#app`というidを持つ要素（通常は`public/index.html`内の`<div id="app">`）にマウントしています。これにより、以降は`#app`内部のDOMはすべてVueによって管理されるようになります。**main.jsはグローバルな設定やプラグインの登録**なども行う場所です。例えば、Vue Routerを使う場合はここで`createApp(App).use(router).mount('#app')`とすることでルータを全体に適用しますし、他にも状態管理(Pinia)やUIフレームワーク（Vuetify等）のプラグイン初期化もmain.jsで行います。

- **`App.vue`: ルートコンポーネント**  
  アプリケーション全体のルートとなるコンポーネントです。単一ファイルコンポーネント(SFC)形式で記述され、`<template>`, `<script>`, `<style>`の三つのセクションから構成されます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=Open%20your%20,share%20this%20same%20basic%20structure)) ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=%60,function))。`App.vue`はアプリの骨組みに相当し、通常全てのページ/コンポーネントは最終的にApp.vueに内包される形で表示されます。例えば、デフォルトで生成される`App.vue`にはロゴ画像やサンプルコンポーネント`HelloWorld.vue`の使用例が含まれています。擬似コードですが下記のような構造です。

  ```html
  <!-- App.vue -->
  <template>
    <div id="app">
      <img alt="Vue logo" src="./assets/logo.png" />
      <HelloWorld msg="Welcome to Your Vue.js App"/>
    </div>
  </template>

  <script>
  import HelloWorld from '@/components/HelloWorld.vue';
  export default {
    name: 'App',
    components: {
      HelloWorld
    }
  }
  </script>

  <style>
  /* アプリ全体のスタイル（必要に応じてグローバルに適用） */
  body { margin: 0; font-family: -apple-system, ...; }
  #app { text-align: center; }
  </style>
  ```

  上記の例では、テンプレートに画像と子コンポーネント`HelloWorld`を配置し、スクリプトでその子コンポーネントをインポート＆登録しています。App.vueは**アプリの土台**となる部分なので、ナビゲーションバーやフッターなど全ページ共通のレイアウトをここに含めたり、またルーティングを使う場合は`<router-view>`（表示すべきページコンポーネントが切り替わるアウトレット）を配置するなどして使います。基本的にはApp.vue自体が大きなロジックを持つことは少なく、子コンポーネントを組み合わせて画面を構成するコンテナ的な役割となります ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,just%20has%20one%20example%20component))。

- **`components/` ディレクトリ: コンポーネント群**  
  アプリ内で利用される各種再利用可能なコンポーネントを配置するフォルダです ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,just%20has%20one%20example%20component))。プロジェクト作成直後は例として`HelloWorld.vue`が置かれている程度ですが、開発が進むにつれUI部品やページ毎のコンポーネントなどファイルが増えていきます。コンポーネントはSFC形式（`.vue`拡張子）で作成し、`<template><script><style>`で構成されます。ファイル名は慣習としてパスカルケース（例: `UserCard.vue`, `LoginForm.vue`）で命名します。componentsディレクトリ直下には汎用的な小コンポーネント（ボタンやヘッダー等）を置き、ページ固有のコンポーネントはさらに`components/pages`や`views`ディレクトリを分けて管理することもあります。コンポーネント同士は**インポートと登録**によって親子関係を構築します。例えば上記App.vueで`HelloWorld`をインポートしたように、あるコンポーネントから別のコンポーネントを使いたい場合は`import 子 from '...'; components:{ 子 }`という形で登録し、テンプレート中で`<子 />`とタグを書くことで表示できます。

- **その他のファイル/ディレクトリ:**  
  上記以外にもプロジェクトには様々なファイルがあります。`public/index.html`はアプリの土台となるHTMLファイルで、Vueアプリはこの中の`<div id="app">`に差し込まれます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,run%20from%20this%20HTML%20page))。`package.json`はプロジェクトの依存関係やスクリプトを定義するファイルです。また`vite.config.js`（または`vue.config.js`(Vue CLI使用時)）はビルドツールの設定ファイル、`.eslintrc.js`はリント設定、`babel.config.js`はBabelの設定ファイル等が含まれます ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,project%20while%20you%20make%20changes))。`assets`ディレクトリは画像やフォント、グローバルCSSなどを置く場所で、VueコンポーネントからインポートすることでWebpackやViteがビルド時に取り込み管理します ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=,processors%20like%20Sass%2FSCSS%20or%20Stylus))。

プロジェクトの基本構成は以上のようになっており、シンプルな構成ですが、小さいコンポーネントに分割して開発を進めることで大規模なアプリケーションも整理して実装できます。ベストプラクティスとして、**1コンポーネント＝1ファイル**を心がけ、コンポーネントが肥大化しそうな場合はさらに子コンポーネントに分割する、ディレクトリも用途ごとに整理する（views、store、composables等）などの工夫でプロジェクトを構造化すると良いでしょう。

## 5. テンプレート構文の基礎

Vueの強力な特徴の一つに、直感的に使える**テンプレート構文**があります。テンプレート構文とは、HTMLライクな記法の中に特殊なマスタッシュ記法（二重中括弧）やディレクティブ（v-から始まる属性）を埋め込むことで、DOMとデータをバインドする仕組みです ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=Vue%20uses%20an%20HTML,compliant%20browsers%20and%20HTML%20parsers))。Vueのテンプレートはすべて有効なHTMLとしてパース可能でありつつ、内部的には仮想DOM操作にコンパイルされるため、高速に動作します ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=Under%20the%20hood%2C%20Vue%20compiles,when%20the%20app%20state%20changes))。ここでは基本的なテンプレート構文の要素である**データの差し込み**と**ディレクティブ（v-bind, v-model, v-if, v-forなど）**、そして**イベントハンドリング（@click, @submitなど）**について、jQueryでの実現方法とも対比しながら説明します。

### データの差し込み（Interpolations）

テンプレート中で最も基本となるのが、データを表示するための差し込み構文です。ダブル中括弧`{{ }}`を用いた**Mustache記法**で、JavaScriptの式を評価しテキストとして表示します ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=Text%20Interpolation))。例えば、コンポーネントのデータ`message: 'Hello Vue'`を画面に表示するには以下のように書きます。

```html
<p>{{ message }}</p>
```

これだけで、画面には`Hello Vue`と表示されます。`message`の値を変更すると、Vueのリアクティブシステムにより自動的に表示も更新されます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=template))。jQueryの場合、同様のことをするには`$('p').text(message)`のように明示的にDOMを書き換える必要がありましたが、Vueではテンプレートに宣言するだけでよく、**状態と表示の同期**がフレームワークによって管理されます。

差し込みはテキストだけでなく、例えば属性値の中で使いたい場合もあります。しかし通常のHTML属性内では`{{ }}`は使えないため、その場合は次に説明する`v-bind`ディレクティブを使用します。

### v-bind（属性バインディング）

`v-bind`ディレクティブは、HTML要素の属性にデータの値をバインド（結び付け）するための構文です ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=%3Cdiv%20v)) ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=name.%20For%20example%2C%20the%20%60v,reactively%20update%20an%20HTML%20attribute))。書式は`v-bind:属性名="式"`とします。例えば画像の`src`属性にデータプロパティ`imageUrl`の値を設定するには以下のように書きます。

```html
<img v-bind:src="imageUrl" alt="写真">
```

上記は、データにある`imageUrl`（例: `"photo.png"`）の値がimg要素のsrc属性にセットされることを意味します ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=The%20%60v,or))。データ`imageUrl`が更新されれば、表示中の画像も自動で切り替わります。`v-bind`は非常によく使われるため、**縮約記法**としてコロン`:`一文字で表すことができます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=Because%20%60v,has%20a%20dedicated%20shorthand%20syntax))。したがって上記は`<img :src="imageUrl" alt="写真">`とも書けます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=match%20at%20L418%20%3Ca%20v,a))。

`v-bind`は任意の属性に利用可能で、たとえば`:<div :class="{'active': isActive}">`のようにクラスの付け外しをデータに紐付けたり、`<button :disabled="isDisabled">`のように真偽値によって属性の有無を切り替えたりできます。また、特殊な使い方として`v-bind="object"`とオブジェクト自体を渡すことで、そのオブジェクトのプロパティを一括して属性にバインドするといったテクニックもあります ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=You%20can%20bind%20them%20to,bind%60%20without%20an%20argument))。

### v-model（双方向データバインディング）

フォーム入力とデータを連動させるために用意されているのが`v-model`ディレクティブです。`v-model="プロパティ名"`と指定すると、入力要素の値とデータオブジェクト上の対応するプロパティが**双方向にバインド**されます。つまり、データを変えれば入力欄の表示が変わり、ユーザが入力欄に打ち込めばデータも更新されます。

例えば、データに`name: ''`（名前を保持する空文字列）を用意し、入力フォームで名前を入力させたい場合は次のようにします。

```html
<input v-model="name" placeholder="名前を入力">
<p>こんにちは、{{ name }}さん！</p>
```

初期では`name`は空なので挨拶文は「こんにちは、さん！」となっていますが、ユーザーがテキストボックスに「太郎」と入力すると即座に`name`に「太郎」が反映され、段落の表示も「こんにちは、太郎さん！」に更新されます。裏では、`v-model`は入力要素に対して`value`属性へのバインドと`input`イベントの監視を同時に行っており ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=template)) ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=%3Cinput%20v))、テキスト入力では`@input="..."`でデータを更新する処理を書かなくても済むようになっています ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=When%20dealing%20with%20forms%20on,bindings%20and%20change%20event%20listeners))。チェックボックスやラジオボタン、セレクトボックスの場合も、それぞれ`checked`属性や`selected`属性と対応するイベントで動作するよう自動的に振る舞いを変えてくれます ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=In%20addition%2C%20%60v,element%20it%20is%20used%20on))。このように`v-model`を使うことでフォーム入力のボイラープレートを大幅に削減でき、jQueryで行っていたような`$('input').val()`やイベントハンドラ内での値取得・設定処理が不要になります。

`v-model`は主にフォーム要素用ですが、実はカスタムコンポーネントにも適用できます。コンポーネント側で`defineProps`と`defineEmits`（または`props`オプションと`update:`イベント）を適切に扱えば、親コンポーネントからその子コンポーネントに対しても`v-model`で双方向バインドが可能です。これは例えば再利用可能な入力コンポーネント（テキストフィールドやチェックボックスコンポーネント）を作る際に便利です。ただしこの応用は基礎を理解した後で構いません。

### 条件レンダリング（v-if, v-show）

Vueは条件によって要素を出し分けるためのディレクティブを提供しています。その代表が`v-if`と`v-show`です。

- **v-if:** 評価結果が真の場合に要素を描画し、偽の場合はその要素自体をDOMから取り除きます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=,Directives))（描画もしない）。書式は`<タグ v-if="条件式">...</タグ>`もしくは`v-else`や`v-else-if`と組み合わせて使います。例えば、エラーメッセージを表示するかどうかを`hasError`という真偽値で管理する場合、`<p v-if="hasError" class="error">エラーが発生しました</p>`のようにします。`hasError`が`false`の時、この`<p>`要素はDOMに存在しません。

- **v-show:** 挙動は`v-if`に似ていますが、DOM要素自体は常にレンダリングし、条件が偽の場合はCSSの`display: none`スタイルを適用して非表示にする点が異なります。したがって`v-show`は頻繁に表示切替えを行う場合にパフォーマンス上有利（要素の作成破棄を繰り返さない）ですが、初期ロード時にも非表示要素が出力されるため、完全に削除したい場合には不向きです。

通常は必要に応じて`v-if`と`v-else`で条件分岐を実装します。例えば:

```html
<div v-if="user">
  <p>{{ user.name }}さん、ようこそ！</p>
</div>
<div v-else>
  <p>ログインしてください。</p>
</div>
```

上記では`user`オブジェクトが存在する場合は歓迎メッセージを、ない場合はログイン要求メッセージを表示します。`v-else`は直前のv-ifが偽の場合に描画されます。

### リストレンダリング（v-for）

配列やオブジェクトのリストを繰り返し描画するには`v-for`ディレクティブを使います。書式は典型的には`v-for="item in items"`のように書き、さらに**キー`key`属性**を各要素に指定します（`:key="item.id"`など） ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=%3Cform%20%40submit.prevent%3D))。キーはVueが各要素を一意に識別し、リストの差分更新を効率化するために重要です。キーを適切に指定しないと再レンダリング時に意図しない挙動を招くことがあるため、ベストプラクティスとして**v-forの際は常にキーを付与**するようにしましょう。

例として、配列`tasks = [{ id: 1, title: '買い物'}, { id: 2, title: '掃除'}]`をデータとして持ち、それらをリスト表示する場合は以下のように書けます。

```html
<ul>
  <li v-for="task in tasks" :key="task.id">
    {{ task.title }}
  </li>
</ul>
```

上記は`tasks`配列を順に走査し、各要素に対して`<li>`を生成しています。`task`オブジェクトの`title`プロパティが表示され、キーには`task.id`を使用しています。配列に新しいタスクを追加すれば対応する<li>が追加され、削除すれば<li>が消える、といったDOM更新が自動で行われます。jQueryの場合、同様のことを実現するにはループを回して手動でDOM文字列を組み立てたり、差分更新ロジックを自前で書く必要がありましたが、Vueではデータ配列を操作するだけでビューが同期するため格段に楽になります。

### イベントハンドリング（@click, @submit など）

Vueのテンプレートでは、DOMイベント（クリック、サブミット等）に対してメソッドをバインドすることが簡単にできます。`v-on`ディレクティブ、略記の`@`記法を使って記述します ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=We%20can%20use%20the%20%60v,handler))。書式は`v-on:イベント名="メソッド名"`または短縮して`@イベント名="メソッド名"`です。

例えばボタンクリックで`increment`というメソッドを実行したい場合、テンプレートに`<button @click="increment">カウント</button>`と記述します ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=%3Ca%20v))。対応するスクリプト側ではコンポーネント内に`methods: { increment() { ... } }`のようにメソッドを定義しておきます（Composition APIの場合はsetup内で関数を定義しreturnする）。こうすると、ボタンがクリックされたときにincrementメソッドが呼ばれます。実際、Vueではイベントリスナを自分で登録する代わりにこの`@click`のような構文で簡潔に書けるため、jQueryで`$('button').on('click', handler)`としていたのに比べ記述量が減ります。

**イベント修飾子:** Vueではイベントハンドラ内でよく使われる`event.preventDefault()`や`event.stopPropagation()`といった処理を簡潔に書けるよう**修飾子 (modifier)**をサポートしています ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=It%20is%20a%20very%20common,deal%20with%20DOM%20event%20details))。例えばフォームのsubmitイベントでページリロードを防ぎつつ処理を行いたい場合、通常はイベント内で`event.preventDefault()`を呼びますが、Vueでは`@submit.prevent="onSubmit"`と書くことで自動的に`preventDefault()`が実行されます ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=%3Cform%20%40submit.prevent%3D))。同様に`@click.stop`と書けばクリックイベントの伝搬（バブリング）を止めることができます ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=It%20is%20a%20very%20common,deal%20with%20DOM%20event%20details))。複数の修飾子を併用することも可能で、例えば`@click.stop.prevent="handler"`のようにチェインすることで、クリックイベントの伝搬を止めつつ既定動作も無効化する、といった指定も一行で書けます ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=%3Cform%20%40submit.prevent%3D))。修飾子のおかげで、メソッド内のロジックは**ビジネスロジックに専念**でき、イベントオブジェクトの低レベル制御をテンプレート側で肩代わりできるのが利点です ([Event Handling | Vue.js](https://vuejs.org/guide/essentials/event-handling#:~:text=It%20is%20a%20very%20common,deal%20with%20DOM%20event%20details))。

**イベント引数:** イベントハンドラメソッドには暗黙で`$event`オブジェクトが渡されます。必要なら`@keyup="onKey($event)"`のようにメソッドにイベントオブジェクトを渡したり、あるいは更に簡潔に`@submit.prevent="onSubmit($event.target.username)"`のように式を書くこともできます。ただし多くの場合、メソッド内で`$event`を使うより、コンポーネントのデータやrefs経由で必要情報にアクセスする方が望ましいでしょう。

以上、テンプレート構文の基本としてデータ差し込み、主要なディレクティブ、イベントバインディングを紹介しました。テンプレート構文により、**UIとロジックを直感的・宣言的に紐付ける**ことができ、jQuery中心の開発に比べてコードの見通しが良くなることを体感できるはずです。

## 6. データバインディングの仕組み（リアクティブシステム）

Vueの核となる仕組みが**リアクティブシステム（反応性システム）**です。リアクティブシステムとは、一言で言えば「データの変化を検知して自動でUIを更新する仕組み」です ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=Reactivity%20is%20the%20mechanism%20that,understand%20its%20strengths%20and%20limitations))。Vueにおけるデータバインディングは、このリアクティブシステムによって実現されています。ここではその概念と簡単な仕組みを、図解を交えて説明します。

 ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/))  
*図: Vue.jsのリアクティブシステム概念図。データオブジェクトは内部的にgetter/setter（Vue 3ではProxy）でラップされ、コンポーネントのレンダリング時に依存として記録される（データを “収集”）。データが変更されると関連するレンダー関数（ウォッチャ）が通知を受け再レンダリングがトリガーされる ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=Reactivity%20is%20the%20mechanism%20that,understand%20its%20strengths%20and%20limitations))。この仕組みにより、データとUIの自動同期が実現している。*

### リアクティブシステムの概要

Vueのリアクティブシステムは、コンポーネントのデータを監視対象にし、そのデータが変わった際に**どの部分を更新すべきかを自動で判断して実行**します ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=Reactivity%20is%20the%20mechanism%20that,understand%20its%20strengths%20and%20limitations))。開発者は通常、リアクティブシステムの存在を意識せずとも、データを変更するだけで画面が更新される便利さを享受できますが、その裏では以下のような処理が行われています。

1. **データのリアクティブ化:** Vueは`data(){ return { ... } }`で返されたオブジェクトや、Composition APIで`ref()`や`reactive()`によって作られたオブジェクトを**リアクティブオブジェクト**に変換します。Vue 3では先述の通りこの変換にJavaScriptのProxyを使用しており、プロパティへのアクセス（get）や変更（set）をフックしています ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=Vue%20provides%20automatic%20reactivity,a%20JavaScript%20feature%3A%20the%20Proxies)) ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=set%28obj%2C%20key%2C%20value%29%20,))。つまり、データを読み書きするたびに「誰がそのデータを使ったか」「どのデータが変わったか」を追跡できるようになっています ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=set%28obj%2C%20key%2C%20value%29%20,))。

2. **依存関係の収集 (Dependency Tracking):** コンポーネントが初めて描画される際、そのコンポーネントのテンプレートが評価されて仮想DOMが生成されます。このレンダリング過程でリアクティブデータにアクセスすると、Vueは「このコンポーネント（のレンダリング処理）はこのデータに依存している」という記録を内部的に行います。Vue 2の用語ではこの記録役を**ウォッチャ (Watcher)**と呼び、各コンポーネント毎にレンダー用ウォッチャがあって依存データを収集します。Vue 3でも同様の概念で、`effect`や`ReactiveEffect`によって依存関係をトラッキングしています。要するに、「どのデータがどのコンポーネント（あるいは計算プロパティなど）で使われたか」をマッピングして保持している状態です。

3. **変更の検知と通知:** リアクティブデータが変更されると（例えば`this.count++`や`state.value = ...`のように）、Proxy経由でその「書き込み(set)」が捕捉されます。Vueはそのデータを依存としていたウォッチャに対して変更通知を送り、「再レンダリングが必要」とマークします。ここで重要なのは、Vueはすぐさま再描画するのではなく、一旦すべての変更をまとめてから**一括して更新をかける（バッチ処理）**という点です ([Reactivity Fundamentals | Vue.js](https://vuejs.org/guide/essentials/reactivity-fundamentals#:~:text=When%20you%20mutate%20reactive%20state%2C,state%20changes%20you%20have%20made))。これは複数のデータ変更があっても無駄な再描画を複数回行わないための最適化です。具体的には、次の"tick"（ブラウザの描画タイミング）まで変更を蓄積し、まとめて仮想DOMの再計算と差分適用を行います ([Reactivity Fundamentals | Vue.js](https://vuejs.org/guide/essentials/reactivity-fundamentals#:~:text=When%20you%20mutate%20reactive%20state%2C,state%20changes%20you%20have%20made))。そのため、データを立て続けに変更してもパフォーマンスが損なわれず、最終的な結果だけが反映されます。

4. **仮想DOM差分による更新:** 通知を受けたコンポーネントは仮想DOMを再生成し、前回の仮想DOMと比較して変更のあった部分だけを実際のDOMに適用します。例えば`title`データが変わったなら、その`title`を表示しているテキストノードだけが更新され、他の部分は再利用されます ([Template Syntax | Vue.js](https://vuejs.org/guide/essentials/template-syntax#:~:text=parsers))。この差分計算にはVirtual DOMの仕組みが使われ、非常に効率的です。結果として、開発者は**最小限の労力でDOM操作を実現**できます。jQueryであれば「特定の要素を探して書き換える」という命令を逐一書いたでしょうが、Vueではその必要がありません。

まとめると、Vueのリアクティブシステムは**「データ変更の自動検知」**と**「影響範囲の自動特定」**によって、必要最低限のDOM更新を自動化しています。この仕組みのおかげで、我々開発者は`data`に集中して宣言的にUIを構築できるのです ([Reactivity | Introduction to Vue.js](https://worldline.github.io/vuejs-training/reactivity/#:~:text=Vue%20provides%20automatic%20reactivity,a%20JavaScript%20feature%3A%20the%20Proxies))。リアクティブシステムはVueだけでなく他のモダンフレームワーク（Reactのステート＋Virtual DOM、Angularの変更検知など）にも共通する核心部分であり、Vueは特にその実装がシンプルで分かりやすいと言われます。実際、「リアクティブである」という概念を理解すると、以前jQueryで苦労していたDOM操作がいかに自動化・簡略化されるかが実感できるでしょう。

**jQueryとの対比:** jQueryではデータと表示の同期はすべて開発者の責任でした。例えば配列の内容を更新したら対応するリストの<li>要素を自分で組み立て直す必要があり、値を変更したらそれを表示する全ての箇所を選択して書き換えるコードを書く必要がありました。Vueではそうした処理は原則不要です。データの変更を一箇所に書けば（例えば`this.items.push(newItem)`のように配列を操作すれば）、それを使っているテンプレート箇所は自動更新されます。これにより、状態遷移が複雑になってもUI更新漏れや不整合が起きにくく、バグを減らせます。また、リアクティブシステムが効率的に動作するようVueは内部的に様々な最適化を行っています。例えばコンポーネントが関係しないデータ変更ではそのコンポーネントは再描画されないなど、**細粒度な更新制御**がなされています ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=,rendering%20efficiency%20in%20larger%20applications))。

以上がVueのデータバインディングを支えるリアクティブシステムの概要です。図解したフローをまとめると、**データを変更する -> 変更が自動検知され依存するコンポーネントが特定される -> 差分レンダリングでUIが更新される**、という一連の流れになります。この仕組みを理解しておくと、Vueで開発する際に「なぜ自動で画面が変わるのか」「どの程度の処理が裏で走っているのか」がイメージでき、より適切なコード設計やパフォーマンス考慮ができるようになるでしょう。

---

以上、6つの項目に沿ってVue.jsの基礎を解説しました。jQueryの経験を持つエンジニアの方にとって、Vueのアプローチは最初少し異なる考え方に感じるかもしれません。しかし、本稿で述べた**宣言的なテンプレート**や**リアクティブなデータバインディング**に慣れれば、DOM操作中心の開発よりも直感的で生産的に感じられるはずです。まずは小さなVueコンポーネントを作り、jQueryで行っていた処理を置き換えてみるところから始めてみましょう。徐々にVue特有のコンポーネント志向や単一ファイルコンポーネント、Vue 3のComposition APIなどに触れ、ステップアップしていくことで、無理なくモダンなフロントエンド開発手法を習得できるでしょう。今後の学習では、さらに状態管理（Pinia）やルーティング、テスト手法など実務で必要となる項目も出てきますが、まずは本稿の内容を踏まえてVueの基本を押さえていただければ幸いです。

**引用・参考:** Vue公式ガイドおよび各種文献 ([Getting started with Vue - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Frameworks_libraries/Vue_getting_started#:~:text=Vue%20is%20a%20modern%20JavaScript,for%20a%20library%20like%20jQuery)) ([Angular vs React vs Vue: The Best Framework for 2025 is… | Zero To Mastery](https://zerotomastery.io/blog/angular-vs-react-vs-vue/#:~:text=Category%20Angular%20React%20Vue%20Type,Learning%20Curve%20Steep%20Moderate%20Easy)) ([Form Input Bindings | Vue.js](https://vuejs.org/guide/essentials/forms#:~:text=When%20dealing%20with%20forms%20on,bindings%20and%20change%20event%20listeners))他。

了解です！JavaScript + jQuery 経験者がVueを業務開発で活用できるようになるためのステップ2の中級知識について、各項目を丁寧に解説し、具体例と業務での使いどころを交えて深掘りしていきます。API通信についてはモックAPIを前提とし、将来的なバックエンド連携も視野に入れた説明を行います。

調査が完了しましたら、実務目線で理解しやすく構造化されたレポート形式でお届けします。少々お待ちください。

# Vue中級ロードマップ: コンポーネント間通信から状態管理まで

Vue.jsを使った本格的なアプリ開発に進むにあたり、jQuery的なやり方との違いを理解しつつ、Vue特有の機能を習得することが重要です。本稿では、**JavaScript+jQueryの経験者**を対象に、Vue学習ロードマップのステップ2（中級レベル）に相当する以下の項目を深掘りして解説します。各項目について、**jQueryではどうしていたか**、**Vueでは何を使うか**を対比しながら、具体例やコードサンプル、業務での適用シーンを示します。  

- コンポーネント間のデータのやり取り（Props / Emits / Slot）  
- Composition API の使い方（`setup()`, `ref()`, `reactive()`, `computed()`, `watch()`、Composable関数）  
- 状態管理（`provide`/`inject`、およびPinia）  
- Vue Router（動的ルート / ネストされたルート / ナビゲーションガード）  
- API通信と非同期処理（axios / fetch / async-await、エラーハンドリングとローディング状態管理）  

まず大前提として、**VueとjQueryの考え方の違い**を押さえておきましょう。jQueryはDOM操作主体のライブラリで、開発者が手続き的にDOMを書き換えてUIを更新します。一方Vue.jsは**宣言的なフレームワーク**で、コンポーネントの状態（データ）に応じてVueが自動的にDOMを更新します。このため、jQueryでは毎回自分でDOM操作のコードを書く必要がありますが、Vueでは必要なDOM操作がフレームワーク内部で行われるため効率的に開発できます ([Vue.jsとは？jQueryとの違いや使用のメリットを紹介](https://digitalidentity.co.jp/blog/creative/javascript-vuejs.html#:~:text=jQuery%E3%81%AF%E7%B0%A1%E5%8D%98%E3%81%AB%E5%B0%8E%E5%85%A5%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%80%81%E5%AD%A6%E7%BF%92%E3%82%B3%E3%82%B9%E3%83%88%E3%82%82%E3%81%9D%E3%81%93%E3%81%BE%E3%81%A7%E9%AB%98%E3%81%8F%E3%81%AA%E3%81%84%E3%81%AE%E3%81%A7%E3%80%81%E7%B0%A1%E5%8D%98%E3%81%AA%E3%82%A2%E3%83%8B%E3%83%A1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%84%E3%82%B9%E3%83%A9%E3%82%A4%E3%83%89%E3%82%B7%E3%83%A7%E3%83%BC%E3%81%AA%E3%81%A9%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%99%E3%82%8B%E9%9A%9B%E3%81%AF%E3%80%81jQuery%E3%81%A7%E4%BA%8B%E8%B6%B3%E3%82%8A%E3%82%8B%E3%81%93%E3%81%A8%E3%82%82%E5%A4%9A%20%E3%81%84%E3%81%A7%E3%81%97%E3%82%87%E3%81%86%E3%80%82%20%E3%81%97%E3%81%8B%E3%81%97%E3%80%81jQuery%E3%81%AF%E8%87%AA%E5%88%86%E3%81%A7%E9%80%90%E4%B8%80%E3%82%B3%E3%83%BC%E3%83%89%E3%82%92%E8%A8%98%E8%BF%B0%E3%81%97%E3%81%A6DOM%E6%93%8D%E4%BD%9C%E3%82%92%E3%81%8A%E3%81%93%E3%81%AA%E3%82%8F%E3%81%AA%E3%81%84%E3%81%A8%E3%81%84%E3%81%91%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82%E4%B8%80%E6%96%B9%E3%80%81Vue))。例えばjQueryでは`$("#element").text("新しいテキスト")`のようにして画面を書き換えていた処理も、Vueではデータを更新するだけで画面上のテキストが変わります。以下、各トピックごとに詳細を見ていきましょう。

## 1. コンポーネント間のデータのやり取り

Vue.jsのコンポーネントは再利用可能なUI部品ですが、業務アプリではタをやり取り**して連携する場面が頻繁にあります。Vueでは主に**親子関係にあるコンポーネント間**でデータの受け渡しを行うために、親から子へは`Props`、子から親へは`Emits`（カスタムイベント）、そして柔軟な内容挿入には`Slot`（スロット）という仕組みを使います。これは、jQueryにおけるDOM操作やカスタムイベントでのやり取りを、Vueのコンポーネントシステムに沿って行う方法です。  

### PropsとEmitsによる親子間通信

**Props（プロパティ）**は親コンポーネントが子コンポーネントに対して渡すデータです。親側のテンプレートで子コンポーネントタグに属性として指定し、子側では受け取りを宣言して使います。**Emits**（$emitによるイベント送信）はその逆で、子コンポーネントから親コンポーネントへ通知やデータ伝達を行う仕組みです。Vueにおける基本原則は「**親から子へはProps、子から親へはイベント**」です。この関係は「*Propsは親から子へデータを送り、$emit()は子から親へ情報を渡すために使われる*」という一文にも表れています ([Vue $emit() Method](https://www.w3schools.com/vue/vue_emit.php#:~:text=Props%20are%20used%20to%20send,child%20component%20to%20the%20parent))。  

VueのPropsは**単方向（一方向）データフロー**である点が重要です。親から渡されたPropは子から直接書き換えることはできません。親がPropの値を更新すれば子には伝わりますが、**子側でPropを変更しようとするとVueから警告が出ます** ([Props | Vue.js](https://vuejs.org/guide/components/props.html#:~:text=All%20props%20form%20a%20one,data%20flow%20harder%20to%20understand))。これにより、子コンポーネントが誤って親の状態を変えてしまうことを防ぎ、データフローを明確にしています（親が子に与えた値を子が勝手に改変しないようになっている）。子で受け取ったPropを加工したい場合は、子コンポーネント内で**計算プロパティ**や**dataにコピー**して使うといった対策を取ります（後述の`computed`で派生値を作る方法などがあります）。  

では具体的に、親子コンポーネント間でPropsとEmitsを使ったデータの流れをコードで見てみましょう。以下に親コンポーネントから子コンポーネントへ数値を渡し、子でボタンがクリックされたら親にイベントで知らせて値を増やす例を示します。さらに、子コンポーネントのボタンの表示ラベルを、親からスロットを使って差し込む実装も加えてみます（後述のSlotの例を兼ねています）。

```vue
<!-- ParentComponent.vue : 親コンポーネント -->
<template>
  <div>
    <h2>親コンポーネント</h2>
    <p>カウント: {{ count }}</p>
    <!-- 子コンポーネントに count を渡し、incrementイベントを監視 -->
    <ChildComponent :count="count" @increment="onIncrement">
      追加ボタン <!-- 子コンポーネントのデフォルトslotに挿入するコンテンツ -->
    </ChildComponent>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import ChildComponent from './ChildComponent.vue';

// 親側のデータ
const count = ref(0);
// 子から受け取ったイベントで親のデータを更新
const onIncrement = () => {
  count.value++;
};
</script>

<!-- ChildComponent.vue : 子コンポーネント -->
<template>
  <div>
    <h3>子コンポーネント</h3>
    <p>受け取った count: {{ count }}</p>
    <!-- ボタン押下で increment イベントを親に emit。slotでボタン表示内容を受け入れ -->
    <button @click="emitIncrement"><slot>Increment</slot></button>
  </div>
</template>

<script setup>
import { defineProps, defineEmits } from 'vue';
// 親から受け取るPropを定義（ここでは count という Number）
const props = defineProps({
  count: Number
});
// 親へ送信するイベントを定義（ここでは increment）
const emit = defineEmits(['increment']);
// クリック時に親へイベント送信
const emitIncrement = () => {
  emit('increment');
};
</script>
``` 

上記の例では、親コンポーネントが`<ChildComponent>`を使用し、`:count="count"`で数値を渡しています。子コンポーネント側では`defineProps`で受け取り、テンプレートで表示しています。また、子のボタンをクリックすると`$emit('increment')`によって親にカスタムイベント`increment`を送出し、親側の`@increment="onIncrement"`ハンドラが反応して`count`を増加させています。親→子のデータ伝達と子→親のイベント通知により、**親の状態が子に渡され、子の操作で親の状態が更新される**という双方向のやり取りを実現しています。

**jQueryとの対比:** jQueryでは、別々のモジュール間でデータを渡すのにグローバル変数やイベントシステム（`$(element).trigger('event')`と`$(element).on('event', ...)`）を使っていたかもしれません。しかしVueでは、上記のようにコンポーネント間で**明示的にPropsとイベントを通じて**やり取りします。このほうが、どのデータがどこから来てどこへ伝わるかが明確になります。特に、一方向データフローのおかげで**データの流れが見通しやすく**、アプリの状態管理が複雑になっても原因を追いやすいというメリットがあります。

### スロット(slot)によるコンテンツ挿入

**スロット(slot)**は、子コンポーネントの特定の箇所に、親コンポーネントから提供された任意のテンプレート内容を挿入できる仕組みです。Propsがテキストや数値などの**データ**を渡すのに対し、Slotは**マークアップやコンポーネントそのもの**を親から子に渡せる点が特徴です。例えば、ボタンコンポーネントにおいてボタンの中身（ラベルやアイコン）を親側で指定したい場合にスロットが使えます。

基本的な使い方は、子コンポーネントのテンプレート内に`<slot></slot>`要素（スロットの挿入口）を置き、親側のコンポーネントで子を呼び出す際に、そのタグの中身として渡したい内容を書く、という形になります。子コンポーネント側の`<slot>`は「**親から提供されたスロットコンテンツを埋め込む場所**」を示します ([Slots | Vue.js](https://vuejs.org/guide/components/slots.html#:~:text=The%20%60,slot%20content%20should%20be%20rendered))。先ほどの例でも、子コンポーネントのボタン内に`<slot>Increment</slot>`と記述することで、親が`<ChildComponent>...内容...</ChildComponent>`タグの中に書いた「追加ボタン」という文字列が、その場所に差し込まれています。親が何も指定しなければ`<slot>`タグのデフォルト内容（例では"Increment"）が表示されます。

スロットを使うことで、**コンポーネントの枠組み（外観）は子側が持ち、具体的な中身は親側で差し替え可能**という柔軟な設計が可能になります。たとえば、共通のモーダルダイアログコンポーネントに対して、タイトルやボディ部分の内容を毎回親側から差し込むことで、レイアウトやスタイルは共通化しつつ内容だけ変える、といった用途に便利です。上級編として、名前付きスロット（複数の挿入口を名前で区別）やスコープ付きスロット（子コンポーネントからスロット内容に値を渡す）もありますが、中級段階ではまず基本的な使い方を押さえれば十分です。  

**jQueryとの対比:** jQueryにはコンポーネントの概念がないため、類似のことをするにはHTML文字列を組み立てて直接DOMに挿入する（例えば`$(parent).append(childHtml)`）といった実装になっていたでしょう。Vueのスロットはそれを**コンポーネントのテンプレート機能として宣言的にサポート**したもので、テンプレート内の見通しが良くなり、再利用性も高まります。

## 2. Composition API の使い方

Vue 3系ではコンポーネントのロジック記述に**Composition API**が導入されました。従来のOptions API（dataやmethodsオプションにオブジェクトで記述する方式）に比べ、Composition APIでは`setup()`関数内でコンポーネントのロジックを記述し、Vueが提供するリアクティブAPI（`ref`や`reactive`など）を直接扱います。これにより、**関連するデータや関数をまとめて管理しやすく**なり、大規模開発で可読性と再利用性を向上させることができます。ここでは、Composition APIの主要な関数である`setup()`, `ref()`, `reactive()`, `computed()`, `watch()`について解説し、さらに**Composable**（コンポーザブル）と呼ばれる再利用可能な関数の作り方にも触れます。  

### Composition APIの基礎 (`setup`, `ref`, `reactive`, `computed`, `watch`)

- **`setup()`関数:** コンポーネントのオプションオブジェクトに代わり、コンポーネントの初期化処理や変数定義を行う関数です。各コンポーネントで自動的に呼ばれ、その中でリアクティブ変数を宣言したり、ライフサイクルフック（Composition API版の`onMounted`等）を登録したりします。`setup()`内でreturnしたオブジェクトや変数はテンプレートから直接参照できます（もしくは<script setup>構文を使う場合はreturn不要でそのままテンプレートに使えます）。

- **`ref()`:** 単一の値（プリミティブやオブジェクトでも可）をリアクティブな変数にするAPIです。例えば`const count = ref(0)`とすると、`count.value`に数値0が入り、`count.value`を変更するとそれに紐づくテンプレートの表示も更新されます。テンプレート内では`.value`を明示せずに`count`と書くだけで中身が参照されます（Vueがテンプレート内では自動で`.value`を解決してくれるため）。**なぜ`.value`が必要か？** refで作られた変数は**Refオブジェクト**という特殊なラッパーになるためです。複雑に感じるかもしれませんが、後述の`reactive()`との使い分けで覚えるとよいでしょう。

- **`reactive()`:** オブジェクトや配列をそのままリアクティブにするAPIです。例えば`const user = reactive({ name: 'Taro', age: 30 })`のように使います。この場合、`user.name`や`user.age`にアクセス・代入するとリアクティブに反応します。`ref()`との違いは、refは**値そのもの**をラップしますが、reactiveは**オブジェクト全体**をProxyして反応させる点です。基本的にオブジェクトに複数のプロパティがある場合は`reactive`を使うとコードがシンプルになります。一方、`reactive`で作ったオブジェクトからプロパティを分割代入で取り出すとリアクティブではなくなる（内部的にはリアクティブ効果が及ばない別変数になる）という注意点があります。そのため、コンポーネント外へ持ち出すグローバル状態などは後述のPiniaや`ref`で管理するケースもあります。

- **`computed()`:** 他のリアクティブな変数から計算される派生値を定義するためのAPIです。例えば`const doubled = computed(() => count.value * 2)`のように書くと、`count`が変化するたびに自動的に`doubled`の値（countの2倍）が更新されます。**算出プロパティ**と呼ばれ、Vue 2の頃からある`computed`オプションに対応する機能ですが、Composition APIでは関数として利用します。テンプレート内には通常の変数同様に`doubled.value`ではなく`doubled`として使えます（computedもrefと同様にRefオブジェクトを返すためですが、テンプレートでは自動解決されます）。

- **`watch()`:** 指定したリアクティブな変数や式を監視し、変化があった際に副作用の処理（コールバック関数）を実行するAPIです。Vue 2からの`watch`オプションに対応します。使用例: `watch(() => user.name, (newVal, oldVal) => { ... })` のように書くと、`user.name`が変化するたびに指定した関数が呼ばれます。第一引数には監視する対象（無名関数内で参照）を指定し、第二引数に実行したい関数を取ります。API通信の実行や、タイマーのスタート/ストップ、コンポーネント外への通知など**副作用**処理に利用します。なお、`watchEffect`という自動依存追跡版のwatchもありますが、基本的な使い所は同様です。

これらのAPIを組み合わせてコンポーネントの状態とロジックを記述します。以下に簡単な例を示します。カウントとメッセージを持つコンポーネントで、ボタンを押すとカウントが増加し、メッセージを書き換えるとwatchでログに出力するようなコードです。  

```vue
<script setup>
import { ref, reactive, computed, watch } from 'vue';

const count = ref(0);
const state = reactive({ message: 'こんにちは' });

// countの2倍の値を計算するcomputed
const doubleCount = computed(() => count.value * 2);

// state内のmessage変化を監視してログ出力
watch(() => state.message, (newVal, oldVal) => {
  console.log('メッセージ変更:', oldVal, '→', newVal);
});

// countを増やすメソッド
function increment() {
  count.value++;
}
</script>

<template>
  <div>
    <p>現在のカウント: {{ count }} / 2倍: {{ doubleCount }}</p>
    <button @click="increment">Increment</button>
    <p>
      メッセージ: <input v-model="state.message">
    </p>
  </div>
</template>
```

上記の例で、`ref`と`reactive`で定義した変数はいずれもリアクティブです。`count`を変更するとそれを利用した`doubleCount`も自動更新され、画面に即時反映されます。`state.message`を変更すると`watch`のコールバックが呼ばれ、コンソールに古い値と新しい値が表示されます。**jQueryの場合**、クリック時にカウントを増やして表示を書き換えるなら手動で`textContent`を更新し、インプットのイベントリスナで値変化を検知して…といった手続きを踏んだでしょう。Vue + Composition APIでは、そのようなDOM操作やイベントの細かな設定はほぼ不要で、状態を宣言し必要ならwatchで副作用を書くだけで済みます。裏ではVueが効率よくDOMを更新してくれます。

### Composable（カスタムComposition関数）の設計

Composition APIの強力な利点の一つが、**ロジックの再利用**を関数単位で行える点です。この再利用可能な関数のことを**Composable（コンポーザブル）**と呼びます。公式の定義では「Composableとは、Vue Composition APIを活用して状態ロジックをカプセル化・再利用する関数」のことです ([Coding Better Composables: Flexible Arguments (2/5) | Vue Mastery](https://www.vuemastery.com/blog/coding-better-composables-2-of-5/#:~:text=According%20to%20the%20Vue%20documentation%2C,to%20encapsulate%20and%20reuse%C2%A0stateful%20logic%E2%80%9D))。要するに、コンポーネント内で使うことのできる**カスタムフック**のようなものです。

例えば「カウントアップのロジック」は様々なコンポーネントで使いたくなるかもしれません。その場合、Composable関数として`useCounter`を定義しておけば、どのコンポーネントからでも呼び出して同じ機能を利用できます。Composable関数は通常`useSomething`という名前で定義し、その中で`ref`や`reactive`によるリアクティブな状態や関数を作成してreturnします。Composableを使う側のコンポーネントでは、まるでVueの組み込み関数のように呼び出して、その返り値を使えばOKです。

以下に簡単なComposable関数と、その利用例を示します。

```vue
<script setup>
// カウンター用のComposable関数を定義
import { ref } from 'vue';
function useCounter(initialValue = 0) {
  const count = ref(initialValue);
  const increment = () => {
    count.value++;
  };
  return { count, increment };
}

// Composableを使う（初期値10でカウンター作成）
const { count, increment } = useCounter(10);
</script>

<template>
  <div>
    <p>Counter: {{ count }}</p>
    <button @click="increment">+1</button>
  </div>
</template>
```

`useCounter`関数は内部で`count`というrefと、`increment`という関数を定義し、それらをオブジェクトにまとめてreturnしています。こうすることで、どのコンポーネントでも`useCounter()`を呼べば独立したカウンター状態を得られます。上記の例では、初期値10のカウンターを作成し、テンプレートで表示・ボタンで更新しています。Composableは**状態（state）とそれに関わるロジックを一纏めにして再利用できる**ため、たとえば「ウィンドウのサイズを監視する`useWindowSize`」や「フォーム入力を管理する`useForm`」など、アプリ共通の関心事を切り出すのに適しています。

実際の業務開発では、Composable関数をコンポーネントとは別ファイルに切り出して`hooks/useXyz.ts`のように配置し、必要なところでインポートして使います。これにより**ロジックの重複を減らし**、テストもしやすくなります。jQueryでは関数やモジュールとして共通処理をまとめるくらいしか再利用策がありませんでしたが、VueのComposableはリアクティブな状態管理も含めてカプセル化できる点で強力です。「ある機能を別のコンポーネントでもまた使いたい」と思ったら、Composable化を検討するとよいでしょう。

## 3. 状態管理（スケーラビリティのために）

アプリが大きくなるにつれて、コンポーネント間で共有すべき**グローバルな状態**や、遠く離れたコンポーネント同士でデータをやり取りしたいケースが出てきます。Vueではこうしたニーズに応える仕組みとして、**コンポーネントツリー全体にデータを供給できる`provide`/`inject`**と、さらに大規模向けには**状態管理ライブラリのPinia（旧Vuexの後継）**があります。

### provide/injectによる依存性の共有

`provide`と`inject`は、親子（祖先子孫）関係にあるコンポーネント間で、直接の親子関係を越えてデータや機能を受け渡す仕組みです。通常、親から子へはPropsで渡せますが、階層が深くなるとネストの途中のすべてのコンポーネントで同じPropを受け渡す「**プロップの掘り下げ (prop drilling)**」が必要になり煩雑です ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject#:~:text=Image%3A%20prop%20drilling%20diagram))。`provide`/`inject`を使うと、ある祖先コンポーネントがデータを提供（provide）し、何階層も下の子孫コンポーネントがそれを直接注入（inject）できます ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject#:~:text=We%20can%20solve%20props%20drilling,up%20in%20its%20parent%20chain))。中間のコンポーネントで渡し直す必要がないため、ツリーの深い場所へのデータ受け渡しが格段に楽になります。

 ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject)) *Prop Drilling: 中間のFooterコンポーネントは実際には不要なpropsまで受け渡さなければならない（赤矢印が通常のProp伝達経路）* ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject#:~:text=Image%3A%20prop%20drilling%20diagram))

 ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject)) *Provide/Inject: Rootコンポーネントがprovideした値をDeepChildが直接injectできる（紫の点線の経路）* ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject#:~:text=We%20can%20solve%20props%20drilling,up%20in%20its%20parent%20chain))

上図のように、たとえば最上位のAppコンポーネントで現在ログイン中のユーザー情報を`provide`しておけば、どんなに深くネストした子孫コンポーネントからでも`inject`によってそのユーザー情報にアクセスできます。コード例を示します。

```vue
<!-- App.vue (ルートコンポーネント、provide側) -->
<script setup>
import { reactive, provide } from 'vue';
// アプリ全体で共有したい状態（例：ログインユーザー情報）
const userInfo = reactive({ name: 'Alice', role: 'Admin' });
provide('userInfo', userInfo);
</script>
<template>
  <Header />  <!-- 中略：どこか深い子孫でUserInfoDisplayを使う -->
  <Main>
    <Footer>
      <UserInfoDisplay />  <!-- DeepChild的な位置 -->
    </Footer>
  </Main>
</template>

<!-- UserInfoDisplay.vue (深い子孫コンポーネント、inject側) -->
<script setup>
import { inject } from 'vue';
const userInfo = inject('userInfo');  // provideされた値を取得
</script>
<template>
  <p>ユーザー名: {{ userInfo.name }} ({{ userInfo.role }})</p>
</template>
```

`App.vue`で`provide('userInfo', userInfo)`とすると、以降の子孫であればどこでも`inject('userInfo')`で同じオブジェクトにアクセスできます。ここでは`reactive`なオブジェクトを提供していますが、`ref`や`computed`でも問題ありません。**提供されたオブジェクトがリアクティブであれば、注入先でも同じリアクティブさを共有**できます ([Provide / Inject | Vue.js](https://vuejs.org/guide/components/provide-inject#:~:text=const%20count%20%3D%20ref,count))。実際、上記の`userInfo`を子孫で更新すれば、提供元であるApp.vueでも値が変化しますし、その逆も然りです（単一方向のPropsとは異なり、同じオブジェクト参照を共有するイメージです）。これを乱用するとコンポーネント間の結合が強くなりすぎますが、**避けられないグローバルな状態や、プラグイン的に提供される機能**（テーマ設定やロケール情報など）はprovide/injectを使うと便利です。

**jQueryとの対比:** jQueryではグローバル変数や`$(window)`等にデータを保存して他のスクリプトから参照する、といった手段を用いることが多かったでしょう。Vueのprovide/injectはそうした**グローバル共有データを明示的かつ局所的に扱う**ための仕組みです。たとえばフォーム全体（親）でフォームコントロール（子孫）に設定を渡す場合など、jQueryだと各コントロール初期化時に共通設定オブジェクトを参照させたりしましたが、Vueなら上位でprovideして子孫でinjectすればスッキリ解決できます。

### グローバル状態管理ストア Pinia（Vuexの代替）

アプリケーションがさらに大規模になると、コンポーネントとは独立した**集中管理された状態管理**が求められます。Vue 2の頃から使われてきた公式の状態管理ライブラリにVuexがありますが、Vue 3ではその後継として**Pinia**というライブラリが公式に推奨されています。PiniaはVuexの思想を引き継ぎつつ、よりシンプルなAPIで実装されたストアです ([State Management | Vue.js](https://vuejs.org/guide/scaling-up/state-management#:~:text=Pinia%20is%20a%20state%20management,Vue%202%20and%20Vue%203))。2022年以降、Vue公式チームは新規プロジェクトではVuexではなくPiniaを使うことを推奨しており、Vuexは保守モードに入っています ([State Management | Vue.js](https://vuejs.org/guide/scaling-up/state-management#:~:text=Existing%20users%20may%20be%20familiar,use%20Pinia%20for%20new%20applications))。

**Piniaの基本**: Piniaではストア（グローバルな状態オブジェクト）を**モジュール**として定義し、それをコンポーネントからインポートして利用します。具体的には、`defineStore`関数を使ってストアを定義します。ストアには`state`（アプリ全体で共有するリアクティブな状態）、`getters`（stateから計算される派生値）、`actions`（stateを変更するメソッド）を持たせることができます。Vuexと異なり、Mutationsの定義は不要で、直接stateを変更するアクションを書ける点がシンプルです。

以下にPiniaストアの定義と利用の例を示します（疑似コード形式）。

```js
// stores/counter.js - カウンター用ストアの定義
import { defineStore } from 'pinia';
export const useCounterStore = defineStore('counter', {
  state: () => ({
    count: 0
  }),
  getters: {
    doubleCount: (state) => state.count * 2
  },
  actions: {
    increment() {
      this.count++;
    }
  }
});
```

```js
// コンポーネント内でのストア利用例
import { useCounterStore } from '@/stores/counter';
const counterStore = useCounterStore();
console.log(counterStore.count);    // グローバルなcount値の参照
counterStore.increment();           // アクションの実行（countが+1される）
console.log(counterStore.doubleCount); // ゲッターの参照（countの2倍の値）
```

Piniaストアは上記のように`useXxxStore`という関数（**Composableと同様の形**）として定義し、`use...Store()`を呼び出すとストアのインスタンス（シングルトン）が得られます。以降はそのインスタンスのプロパティを操作することでアプリ全体の状態が読み書きできます。PiniaはVue DevToolsとも連携し、時間遡行デバッグや各コンポーネントからのストア参照を視覚化できるなど、開発支援機能も充実しています。

**どんな時にPiniaを使うべきか？** 例えば、「ユーザーがログインしているかどうか」「カートに入っている商品一覧」「現在開いているモーダルの種類」といった**複数のページやコンポーネントに跨る状態**は、Piniaストアで一元管理すると便利です。jQueryではこれらを管理するためにグローバル変数やCookie/LocalStorageを直接扱ったりしていましたが、Piniaを使えばリアクティブかつ構造化された形で扱えます。先述のprovide/injectは主に**限定されたツリー内**での受け渡しでしたが、Piniaはアプリ全域にまたがるグローバルストアとして機能し、かつVueコンポーネントから手軽に利用できます。

**業務での具体例:** シングルページアプリケーションでログインしているユーザー情報をどこからでも参照したい場合、Piniaに`useAuthStore`を作り`user`オブジェクトや`isLoggedIn`状態を持たせておきます。ナビバーコンポーネントやプロフィール編集ページなど、どのコンポーネントでも`const auth = useAuthStore()`として`auth.user`を参照できます。ログイン処理を行ったら`auth.user`を設定し、ログアウト処理では`auth.$reset()`（状態リセット）や`auth.user = null`とすることで、全ての関連コンポーネントの表示が自動更新されます。こうした**集中管理**により、状態の変更が予測しやすくなり、大規模開発でも一貫性を保ちやすくなります。

## 4. Vue Router（ページ遷移）

シングルページアプリケーション(SPA)では、ページ遷移やURLの管理に**Vue Router**を使用します。Vue Routerは公式のルーティングライブラリで、Vue 3ではバージョン4系が対応しています。ルーティング設定によってURLパスとコンポーネントを結び付け、ユーザーが特定のURLにアクセスしたときに対応するコンポーネント（ページ）が表示されるようにします。また、動的なパスパラメータやネストしたルート、遷移時のガード処理など高度な機能も備えています。ここでは、**動的ルートマッチング**、**ネストされたルート**、**ナビゲーションガード**に注目して解説します。

### 動的ルートとパラメータ

**動的ルート**とは、URLの一部を変数のように扱い、その値に応じて同じコンポーネントを表示する仕組みです。Vue Routerでは、ルート定義の`path`にコロン（`:`）で始まるセグメントを入れると動的パラメータとして扱われます。例えば`{ path: '/users/:id', component: UserDetails }`と定義すると、`/users/1`でも`/users/abc`でも`/users/:id`にマッチし、UserDetailsコンポーネントが描画されます ([Dynamic Route Matching with Params | Vue Router](https://router.vuejs.org/guide/essentials/dynamic-matching.html#:~:text=,))。`:`に続く部分がパラメータ名（ここでは`id`）となり、マッチしたURLではその値が`$route.params.id`としてコンポーネント内で参照できます ([Dynamic Route Matching with Params | Vue Router](https://router.vuejs.org/guide/essentials/dynamic-matching.html#:~:text=A%20param%20is%20denoted%20by,s%20template%20to%20this))。  

具体例として、ユーザー一覧ページからユーザー詳細ページに遷移するケースを考えましょう。ユーザー詳細ページ用コンポーネントを`UserDetails.vue`として、ルーターに以下のような定義を追加します。

```js
// ルート定義の一部（動的ルート）
const routes = [
  { path: '/users', component: UsersPage },                // ユーザー一覧
  { path: '/users/:id', component: UserDetails, props: true }  // ユーザー詳細（IDを受け取る）
];
```

`props: true`とすると、`$route.params`の値（`id`など）をそのままコンポーネントのpropsとして渡すこともできます。この場合UserDetailsコンポーネント側で`props: ['id']`と受け取れば、`id`を直接データとして利用できます。あるいはコンポーネント内で`$route.params.id`を参照しても構いません。いずれにせよ、URL上の`:id`部分が動的に変更されても同じUserDetailsコンポーネントが使い回され、表示内容（特定のユーザーの情報）だけ変わるという仕組みです。

**jQueryとの対比:** jQueryだけでSPA的なことを実現しようとすると、`location.hash`を使ったり`History API`を駆使してURLに応じたコンテンツ切り替えを実装する必要がありました。Vue Routerを使えば、上記のような定義をするだけで自動的にブラウザのアドレスバーと表示コンポーネントが連動します。履歴管理（戻る・進む）もVue Routerが処理してくれるため、開発者は各ページコンポーネントの中身実装に集中できます。

### ネストされたルート

ルート（ページ）にも**親子関係**を持たせることができます。例えばユーザー詳細ページ内にさらにタブ切り替えで「プロフィール」と「投稿一覧」を表示したい場合、`/users/:id/profile`や`/users/:id/posts`のようにさらに階層化したURLを定義できます。Vue Routerでは、あるルート定義に`children`配列を持たせることで**ネストしたルート**を表現します ([Nested Routes | Vue Router](https://router.vuejs.org/guide/essentials/nested-routes#:~:text=As%20you%20can%20see%2C%20the,as%20much%20as%20you%20need))。子ルートは親ルートのコンポーネント内に設置した`<router-view>`の中に表示されます。

具体例として、ユーザー詳細ページ`UserDetails.vue`をレイアウトコンポーネントとし、その中にプロフィール`UserProfile.vue`と投稿一覧`UserPosts.vue`をネスト表示する設定を示します。

```js
import UserLayout from './components/UserLayout.vue';
import UserProfile from './components/UserProfile.vue';
import UserPosts from './components/UserPosts.vue';

const routes = [
  {
    path: '/users/:id',
    component: UserLayout,
    meta: { requiresAuth: true },
    children: [
      { path: '', component: UserProfile },    // /users/:id にマッチしたとき
      { path: 'posts', component: UserPosts }  // /users/:id/posts にマッチしたとき
    ]
  },
  { path: '/login', component: LoginPage }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});
```

上記では、`/users/:id`にマッチするとまずUserLayoutコンポーネントが表示され、その内部の`<router-view>`に`children`の中でpathが''（空文字）のルート、つまり`UserProfile`が表示されます。URLが`/users/123/posts`であれば同じUserLayoutが表示された上で、内部`<router-view>`には`UserPosts`コンポーネントが表示されます。このように、**親ルートのコンポーネントをレイアウトや共通枠とし、子ルートを差し替える**ことで複数画面にまたがる共通UIを持たせることができます。子ルートはさらにchildrenを持たせてネストを深くすることも可能です ([Nested Routes | Vue Router](https://router.vuejs.org/guide/essentials/nested-routes#:~:text=As%20you%20can%20see%2C%20the,as%20much%20as%20you%20need))。実務上は2段階か3段階程度のネストにとどまることが多いですが、設計次第で柔軟にルーティング構造を表現できます。

**注意点:** ネストしたルートを定義した場合、親ルートの`<router-view>`が子コンポーネントの表示場所になります。親コンポーネント側に`<router-view>`を書くのを忘れると子ルートが表示されないので注意してください。また、子ルートがない状態で親ルートだけにアクセスした場合に表示するデフォルト子コンポーネント（上記例ではUserProfileのようなもの）は、子ルート定義で`{ path: '' ... }`として明示する必要があります。

### ナビゲーションガード（認証や画面遷移制御）

**ナビゲーションガード**とは、ルート間の遷移が発生する際に、遷移をキャンセルしたり他のページへリダイレクトしたりできるフック関数です。ログインが必要なページに未認証ユーザーがアクセスした場合にログインページへ飛ばす、といった認可処理によく使われます。Vue Routerのガードは**グローバルガード**, **ルート定義ごとのガード**, **コンポーネント内ガード**の3種類があります ([Navigation Guards | Vue Router](https://router.vuejs.org/guide/advanced/navigation-guards.html#:~:text=As%20the%20name%20suggests%2C%20the,component))。ここでは最も代表的な**グローバルガード**（全ての遷移に対して実行される）を例に説明します。

先ほどのルート定義例では、`/users/:id`のルートオブジェクトに`meta: { requiresAuth: true }`というカスタムメタフィールドを付与しています。これを利用し、「requiresAuthがtrueのルートに遷移しようとしたらログイン必須チェックをする」というガードを設定してみます。

```js
router.beforeEach((to, from) => {
  // meta.requiresAuth が設定されたルートにアクセスし、かつ未ログインなら…
  if (to.meta.requiresAuth && !isLoggedIn()) {
    return { path: '/login' };  // ログインページにリダイレクト
  }
  // ※ next()やfalseの省略記法として、上記のようにオブジェクトをreturnするとその地点で遷移先が差し替わります
});
```

`router.beforeEach`に渡した関数は、ルート変更のたびに実行されます。`to`には遷移先のルート情報が入り（`to.path`や`to.meta`でアクセス）、`from`には現在のルートが入ります。上記の例ではログイン判定関数`isLoggedIn()`（仮定）で未ログインとわかった場合に`/login`へリダイレクトするようにしています。`return false`とすれば遷移自体をキャンセルできます。グローバルガード以外にも、特定のルート定義に対して`beforeEnter`プロパティで関数を指定すればそのルートに入るときだけ実行されるガードになります。また、コンポーネント実装内で`beforeRouteEnter`などのメソッドを定義することで、ページごとのガード処理を書くこともできます。

**実務での使用例:** 典型的なのは**認可処理**です。上記のようにメタフィールド`requiresAuth`を使ってログイン必須ページを判定したり、逆にログイン済みユーザーがログインページに行こうとしたらトップページに飛ばす、といった制御も可能です。また、ページ遷移時に「保存していない変更がありますが離れてよいですか？」と確認する場合にも、コンポーネント内の`beforeRouteLeave`ガードを使って`confirm()`ダイアログを出す実装が考えられます。

**jQueryとの対比:** jQuery自体にはルーティングの概念がないため、SPA的な画面遷移制御は開発者が独自に実装する必要がありました。例えば`window.onhashchange`イベントでURLハッシュを監視し、特定の値なら特定の関数を実行する…といった具合です。Vue Routerではそのあたりがフレームワークに組み込まれており、ナビゲーションガードも提供されています。これにより**認可やエラー時の一括ハンドリング**が書きやすく、画面遷移の挙動を中央集権的に管理できます。

## 5. API通信と非同期処理

フロントエンドアプリがサーバーと通信してデータをやり取りする場合、Vue単体では組み込みの通信機能はありませんが、ブラウザ標準の`fetch`関数や外部ライブラリの**axios**を用いてAJAXリクエストを行います。jQueryでは`$.ajax`や`$.get`などが用意されていましたが、Vue（というより現代のフロントエンド）では**Promise**ベースのAPIであるfetchやaxiosを使用し、コードを**async/await**で書くのが一般的です。ここではモックAPIを使った例で、Vueコンポーネント内でのAPI通信の実装パターンと、通信中のローディング状態・エラーの扱いについて説明します。

### axios/fetchとasync/awaitによるAPIコール

まずは実際にデータ取得を行う処理を見てみましょう。典型的には**コンポーネントのマウント時**（表示されたタイミング）にAPIリクエストを送り、得られたデータをdataに保存して画面に表示します。Composition APIの場合、`onMounted`フックの中や`setup()`内で直接関数を呼び出しても構いません。以下の例では、JSONPlaceholderという公開モックAPIから記事一覧を取得して表示するコンポーネントを示します。

```vue
<script setup>
import { ref, onMounted } from 'vue';

const posts = ref([]);
const loading = ref(false);
const error = ref(null);

// APIから記事一覧を取得する関数
const fetchPosts = async () => {
  loading.value = true;
  error.value = null;
  try {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts');
    if (!res.ok) {
      throw new Error(`HTTPエラー: ${res.status}`);
    }
    posts.value = await res.json();
  } catch (err) {
    error.value = err.message;
  } finally {
    loading.value = false;
  }
};

// コンポーネントがマウントされたらデータ取得を実行
onMounted(fetchPosts);
</script>

<template>
  <div v-if="loading">読み込み中...</div>
  <div v-else>
    <ul>
      <li v-for="post in posts" :key="post.id">
        {{ post.title }}
      </li>
    </ul>
    <p v-if="error" class="error">エラー: {{ error }}</p>
  </div>
</template>
```

ポイントを整理します:

- `fetchPosts`関数で`fetch` APIを使いHTTP GETリクエストを送っています。`await fetch(...)`でレスポンスを待ち、`res.json()`でJSONデータを取得しています（axiosを使う場合は`const res = await axios.get(url); posts.value = res.data;`とシンプルに書けます）。  
- 通信中かどうかを示す`loading`フラグと、エラー内容を保持する`error`を用意しています。通信開始時に`loading=true`、終了時に`loading=false`とし、テンプレート側で`v-if="loading"`によりローディング表示を制御しています。エラーが起きれば`error`にメッセージを入れ、テンプレートで表示しています。  
- 通信処理には`try...catch...finally`を使い、成功時と失敗時の処理を分けています。**async/await**構文のおかげで、非同期処理でありながら直列の手続きのように記述でき、可読性が高いです。jQueryの`$.ajax`ではコールバック関数（successやerror）やPromiseの`done().fail()`チェーンで書いていたところですが、async/awaitなら同期処理に近い感覚で書けます。可読性が上がるだけでなく、エラーハンドリングも`catch`に集約できるというメリットがあります。

### エラーハンドリングとローディング状態の管理

上記のコードでは、通信中の「読み込み中...」表示とエラーメッセージの表示を実装しました。これは**ローディングスピナー**や**エラーダイアログ**のシンプルな例と言えます。非同期処理ではユーザーに進行状況を知らせ、失敗時にはフィードバックを出すことが重要です。

- **ローディング状態管理:** 複数のAPIを同時に呼ぶ場合や、より洗練されたローディング表示が必要な場合は、コンポーネントごとにフラグを持つより**グローバルに管理**する方法もあります。一例として、axiosを使う場合にリクエストごとにインターセプター（axiosの処理フック）を設定し、リクエスト開始時にグローバルな`loadingCount`を+1、終了時に-1して、`loadingCount>0`なら共通のローディングスピナーコンポーネントを表示するといった実装も可能です。小規模なうちは各画面で個別に`loading`フラグを持たせる方法で十分ですが、**全画面共通のローディング指標**が欲しい場合にはPiniaストアなどで一元管理すると便利です。

- **エラーハンドリング:** API通信の失敗要因にはネットワーク不通、サーバーエラー、認証切れなど様々あります。基本的には上記のように`catch`で例外を捕捉し、ユーザーにわかる形でメッセージを出すようにします。場合によってはエラー種別に応じて処理を分けることもあります（例: 401エラーならログインページに誘導、500エラーなら再試行案内など）。Vue自体にはエラー表示の仕組みは組み込まれていませんが、ユーザー通知用にToast（ポップアップメッセージ）コンポーネントを作りPiniaでメッセージ状態を管理する、といった応用も考えられます。**jQueryではどうしていたか？** おそらく`$.ajax`のerrorコールバックで`alert()`を出したり、画面上に`$("#error").text("...")`で表示していたでしょう。Vueでもやること自体は同じですが、状態管理がリアクティブなので、一度エラーメッセージをステートに入れておけばテンプレート側は自動で更新されます。手動でDOMを探してテキストを書き換える必要はありません。

**モックAPIでの実装例:** 上記のコードがまさにモックAPIを使った例ですが、実際に業務でAPI連携を行う際もほぼ同じ形になります。違いがあるとすれば、URLが本番サーバーのものになることと、認証トークンが必要ならヘッダーに付与する処理が加わる程度です。たとえばaxiosであれば、リクエスト時に`axios.get('/api/items', { headers: { Authorization: 'Bearer <token>' } })`のように書けます。こういった認証ヘッダー付与も、毎回書くのは煩雑なので**axiosのインスタンス**を作り共通設定で入れておく、またはインターセプターで自動付与する、といった工夫をします（詳細は上級編になるため割愛します上記の各セクションで見てきたように、Vue.jsはjQueryとは異なる**コンポーネント志向・宣言的UI**のアプローチでフロントエンド開発を効率化します。jQueryの知識はDOM操作やイベントの基礎として役立ちますが、Vueでは**データバインディングとリアクティブシステム**に任せる部分が多くなります。  

**まとめ - jQueryからVueへの置き換えポイント:**

- **DOM操作:** jQueryでは要素を取得してテキスト変更等を行っていたが、Vueではデータを変更すれば自動でDOMも更新される。複雑な条件分岐やループもテンプレート構文（`v-if`, `v-for`など）で宣言的に記述できるため、直接のDOM操作はほぼ不要。  
- **イベントハンドリング:** jQueryの`$(elem).on('click', handler)`は、Vueではテンプレート中に`@click="handler"`のように書ける。メソッドはコンポーネント内で定義し、`this`を介してデータにアクセス・更新する。  
- **コンポーネント分割:** jQueryの開発では1ページにまとめて複数機能を書いていたかもしれないが、VueではUIや機能単位でコンポーネントに分割する。これにより再利用性と可読性が向上し、大規模開発でもチームで作業しやすくなる。  
- **グローバルな状態:** jQueryでのグローバル変数管理は、Vueの提供/injectやPiniaストアに置き換える。これにより状態変更が自動でUIに反映され、かつどこでどのように状態が使われているか把握しやすくなる。  
- **非同期処理:** jQueryの`$.ajax`などは、Vueアプリではaxiosやfetch+async/awaitで書くようになる。Promiseベースの処理によりエラー処理やローディング表示を洗練させやすい。Vueと直接は関係ない部分だが、**Vuex/Piniaと組み合わせてAPIデータをグローバルストアで管理**するなど高度なパターンも可能。

最後に、Vueを実務で活用するコツとしては、**公式ドキュメントやコミュニティの情報**を積極的に参照することが挙げられます。Vue 3系はまだ新しい情報も多く、日本語のドキュメントや質問サイト（Stack Overflowなど）も充実しています。また、ここで紹介した中級知識を踏まえた上で、さらに**TypeScriptの導入**や**テスト**、**パフォーマンス**、**アクセシビリティ**などに目を向けると、より実務で信頼されるアプリ開発スキルへと繋がるでしょう。

以上、Vue中級ロードマップに沿って主要なトピックを解説しました。jQuery脳からVue脳への切り替えには最初少し慣れが要りますが、**「状態を更新すればUIも更新される」というリアクティブ原則**に沿って設計すれば、複雑なUIも簡明なコードで実現できるようになります。ぜひ小さな社内ツールからでもVueを取り入れ、ここで学んだコンセプトを実際のコードに活かしてみてください。



了解しました。JavaScript + jQuery 経験者向けに、Vueステップ3の内容を丁寧に解説し、ToDoアプリの実装を軸に、社内システムに適したUIフレームワークの導入、開発効率化ツールの活用、そしてGitHub Pagesを用いたデプロイ方法について、実務への応用を交えたレポート形式で深掘りします。

調査が完了しましたら、具体例付きでわかりやすくまとめてお届けします。少々お待ちください。

# Vue実践アプリ開発ステップ3 – jQuery経験者のためのロードマップ解説

対象読者は**JavaScript + jQueryの経験者**で、これからVue.jsで業務アプリを開発しようとしている方です。ここでは Vue 学習ロードマップのステップ3「Vueで実践アプリ開発」に沿って、以下の項目を解説します。各項目では**jQueryとVueの考え方の違い**や、業務での使いどころ・導入時の注意点にも触れながら、丁寧に説明していきます。

## 小さなアプリの実装: ToDoアプリで学ぶVueの基礎

まずは小規模な**ToDoリストアプリ**を題材に、Vueの基本的な使い方を確認します。Vueでは**コンポーネント指向**と**データバインディング**を活用してアプリを構築しますが、これは従来のjQuery中心の開発とは大きく異なります。

- **コンポーネント構成:** VueではUIを部品（コンポーネント）単位に分割します。例えばToDoアプリでは、タスクの一覧表示部分、タスクの入力フォーム部分、タスク項目（チェックボックス付き）の部分などをそれぞれコンポーネントとして定義できます。コンポーネント間は**親子関係**で構成され、親から子へは`props`でデータを渡し、子から親へはイベント(`$emit`)で通知するのが基本パターンです。jQueryでは全てをDOM要素とイベントで直接操作していましたが、Vueでは役割ごとにコンポーネントを分けることで**コードの見通しと再利用性**が向上します。

- **データ管理と双方向バインディング:** Vueでは各コンポーネントが自分の状態（データ）を持ち、そのデータをテンプレートにバインドして画面に表示します。例えばタスク一覧を表す`tasks`という配列データを持ち、テンプレートで`v-for`ディレクティブを使って反復表示します。新しいタスクを追加するときは、その配列にオブジェクトを追加するだけで、UI上も自動的に新タスクの項目が追加表示されます。これは**リアクティブなデータバインディング**によるもので、jQueryのように手動で`append()`したりテキストを書き換えたりする必要がありません。例えばVueでは以下のようにデータとイベントを定義します。

  ```html
  <ul>
    <li v-for="(todo, index) in tasks" :key="index">
      <input type="checkbox" v-model="todo.done" />
      {{ todo.text }}
      <button @click="removeTask(index)">削除</button>
    </li>
  </ul>
  <input v-model="newTask" @keyup.enter="addTask" placeholder="新しいタスク..." />
  ```

  ```js
  data() {
    return {
      tasks: [],       // タスクのリスト（{ text: '内容', done: false }のオブジェクト配列）
      newTask: ""      // 新規タスク入力欄のテキスト
    }
  },
  methods: {
    addTask() {
      if (!this.newTask) return;
      this.tasks.push({ text: this.newTask, done: false });
      this.newTask = "";
      // ローカルストレージにも保存（後述）
      localStorage.setItem("tasks", JSON.stringify(this.tasks));
    },
    removeTask(index) {
      this.tasks.splice(index, 1);
      localStorage.setItem("tasks", JSON.stringify(this.tasks));
    }
  }
  ```

  上記の例では、タスク配列`tasks`を`v-for`で一覧表示し、新規タスク入力には`v-model`で`newTask`と入力フィールドを双方向バインドしています。ボタンやEnterキーで`addTask()`メソッドが呼ばれると配列が更新され、**DOM操作なし**で画面が再描画されます。このデータ駆動の仕組みにより、jQueryで`$('ul').append('<li>...</li>')`のようにDOM操作をしていた部分が不要になります。実際、Vueではボタンのクリックでデータを変更するだけで、対応するDOM要素（タスクリストの項目）が自動更新されます ([Making the Move from jQuery to Vue | CSS-Tricks](https://css-tricks.com/making-the-move-from-jquery-to-vue/#:~:text=el%3A%20%27,)) ([Making the Move from jQuery to Vue | CSS-Tricks](https://css-tricks.com/making-the-move-from-jquery-to-vue/#:~:text=In%20this%20example%2C%20we%E2%80%99re%20using,inner%20text%20will%20change%20automatically))。  

- **ローカルストレージの利用:** 業務アプリでも、ユーザーデータを一時的にブラウザに保存したい場合があります。ToDoアプリではタスクをブラウザの`localStorage`に保存して、ページをリロードしてもタスクが消えないようにしてみましょう。Vueではコンポーネントの**ライフサイクルフック**や**ウォッチャ**を使って、データの永続化処理を仕込むことができます。例えば、上記`addTask`や`removeTask`メソッド内で`localStorage.setItem`を呼んでいるように、タスクデータ変更のタイミングで保存する方法があります。また、コンポーネントがマウント（表示）された直後に`localStorage`からデータを読み込んで初期状態に反映させることもできます。Vueの`mounted()`フック内で以下のように実装します。

  ```js
  mounted() {
    const saved = localStorage.getItem("tasks");
    if (saved) {
      this.tasks = JSON.parse(saved);
    }
  }
  ```

  これでページ初期表示時に保存済みタスクを復元できます ([Creating a To-Do List with Vue.js: A Practical Tutorial | by Raymundo Bojorges | Frontend at Accenture | Medium](https://medium.com/frontend-at-accenture/creating-a-to-do-list-with-vue-js-a-practical-tutorial-d785df6ab02d#:~:text=onMounted%28%28%29%20%3D,%7C%7C%20%5B%5D%3B%20%7D))。さらに応用として、Vueの`watch`機能を使えば、`tasks`配列が変化するたびに自動で`localStorage`に保存することも可能です ([Quick LocalStorage Usage in Vue | CSS-Tricks](https://css-tricks.com/quick-localstorage-usage-in-vue/#:~:text=we%E2%80%99ll%20update%20))。簡単な例では上記のようにメソッド内で毎回保存するアプローチでも問題ありません。

**【jQueryとの違いとポイント】**  
jQueryではDOM要素に対してイベントをバインドし、イベント発火時にコールバック内で`localStorage`操作やDOM生成を行っていました。一方、Vueでは**状態（データ）を中心に**据え、イベントハンドラ内では状態を更新するだけです。DOM操作や表示更新はVueが自動的に行います。この違いにより、コードが宣言的で見通しやすくなり、バグも減ります。また、ローカルストレージ連携も、jQueryだと`window.onload`時に保存データを読み込んだり、適宜`localStorage.setItem`を呼ぶなど手動管理でしたが、Vueではライフサイクルフック（例えば`mounted`）やデータウォッチャを使って明確に記述できます。  

さらに、Vueコンポーネントは**単一ファイルコンポーネント (SFC)** として`.vue`ファイルにテンプレート・スクリプト・スタイルを統合できます。これによりHTMLとJSが分離していたjQuery開発とは異なり、一つのコンポーネントに関するコードが一箇所にまとまります。例えば「タスク入力フォーム」コンポーネントの中に、そのHTML構造とVueのロジック、スタイルをまとめて記述できます。SFCはファイル内でテンプレート、<script>、<style>を持ち、HTMLテンプレート上で`v-model`や`v-on` (縮約記法で`@`) などを用いて直感的に動的機能を記述できる点も特徴です ([Creating a To-Do List with Vue.js: A Practical Tutorial | by Raymundo Bojorges | Frontend at Accenture | Medium](https://medium.com/frontend-at-accenture/creating-a-to-do-list-with-vue-js-a-practical-tutorial-d785df6ab02d#:~:text=Inside%20the%20input%20element%20used,variable%20to%20capture%20the%20task)) ([Creating a To-Do List with Vue.js: A Practical Tutorial | by Raymundo Bojorges | Frontend at Accenture | Medium](https://medium.com/frontend-at-accenture/creating-a-to-do-list-with-vue-js-a-practical-tutorial-d785df6ab02d#:~:text=We%20want%20to%20trigger%20a,the%20Enter%20key%20is%20pressed))。これはjQueryの`$("input").val()`や`$("selector").on("click", ...)`でDOMとコードが分離していたのとは対照的です。

以上のToDoアプリの実装を通じて、Vueの基本である**コンポーネント化**・**リアクティブなデータバインディング**・**ライフサイクルフックを用いた処理**が体験できます。小規模なアプリでもこれらの考え方に慣れることが、業務で複雑なVueアプリを構築する際の土台となります。

## UIフレームワークの導入と選定

業務システムの開発では、一からデザインやUIコンポーネントを作り込むよりも、**UIフレームワーク（コンポーネントライブラリ）**を導入して生産性とデザインの一貫性を高めるのが一般的です。Vueエコシステムには多くのUIライブラリがありますが、ここでは社内業務システムに適した以下の4つを比較・紹介します。

- **Vuetify:** Vue向けでは最も有名なUIフレームワークの一つで、GoogleのMaterial Designに準拠した洗練されたコンポーネントを豊富に提供します ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Vuetify%20is%20a%20Material%20Design,js%20UI))。38k以上のGitHubスターがあり、企業での採用実績も多い成熟した選択肢です ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=With%2038k%2B%20stars%20on%20GitHub,quickly%20create%20a%20customized%20theme))。VuetifyはVueのAPIをフル活用しており、テーマのカスタマイズ性も高く、プロのデザイナーがいなくても**モダンで統一感あるUI**を構築しやすいのが強みです ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=well%20appreciated%20by%20Vue%20users,quickly%20create%20a%20customized%20theme))。反面、コンポーネント数が多く機能がリッチな分、**ファイルサイズが大きめ**で学習コストも若干あります。しかしドキュメントが充実しコミュニティも大規模なので、困ったときの情報も手に入りやすく安心感があります ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Vuetify%20is%20acknowledged%20by%20many,companies%20due%20to%20the%20following))。業務システムでも、例えば**フォーム入力**や**ダッシュボード**などMaterial DesignのUIが受け入れられる環境であればVuetifyは有力です。導入は`npm install vuetify`後、プラグインとして`createVuetify()`を用いてアプリに組み込みます。例えば main.js で:

  ```js
  import { createApp } from 'vue';
  import { createVuetify } from 'vuetify';
  import App from './App.vue';
  import 'vuetify/styles'; // 必要なCSS
  import { aliases, mdi } from 'vuetify/iconsets/mdi'; // アイコン (Material Design Icons) 
  const vuetify = createVuetify({ /* オプション設定 */ });
  createApp(App).use(vuetify).mount('#app');
  ```

  その後、テンプレート中で`<v-btn color="primary">ボタン</v-btn>`のようにVuetify提供のコンポーネントを使えます。ボタンやフォーム、レイアウトグリッドなど一通り揃っているため、自前でCSSを書く量が減り開発効率が上がります。

- **Element Plus:** こちらはVue 3対応のUIライブラリで、元はElement UI（Vue 2向け）として広く使われていたものの後継です。**シンプルで洗練されたデザイン**と、業務アプリに役立つ実用的なコンポーネントが多数揃っています（日時ピッカー、ツリー表示、通知メッセージ、テーブル等） ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Element%20made%20a%20name%20for,trees%2C%20timelines%2C%20and%20calendar%20components)) ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=we%20need%20to%20create%20a,trees%2C%20timelines%2C%20and%20calendar%20components))。Element Plusは「派手すぎない落ち着いたデザイン」で**デスクトップ業務システムにマッチ**しやすく、国際化(i18n)や詳細なカスタマイズもサポートされています ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Element%20Plus%20offers%20even%20the,in))。例えば社内システムで**フォームが主体**の画面を作る場合、Element Plusのフォームコンポーネントやバリデーション機能は実装を大いに簡略化できます。Element Plus自体もGitHubスター2万超えで週8万以上のダウンロードがある人気ライブラリであり、品質やアップデートの頻度も高く安心して使えます ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=even%20add%20a%20language%20that,in))。導入は`npm install element-plus`でパッケージを追加し、`app.use(ElementPlus)`でプラグイン登録します。その後`<el-button>OK</el-button>`のように`el-`プレフィックス付きのタグをテンプレートで使います。Vue CLIのプロジェクトではプラグイン追加コマンドで組み込むこともできます。Element Plusは**中国発祥**のライブラリですが、日本語リソースも含め多言語対応しており、日本の開発者にも使いやすいものとなっています。

- **Naive UI:** Vue 3時代になって登場した新興のUIライブラリで、**70種類以上のモダンなコンポーネント**を提供しつつ、カスタムテーマの作成が容易であることが特徴です ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Naive%20UI%20ships%20with%2070%2B,in%20any%20Vue%203%20app))。Naive UIのドキュメントサイトではリアルタイムにテーマカラーやフォントを変えてプレビューでき、その設定をダウンロードしてプロジェクトに適用することも可能です ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Naive%20UI%20ships%20with%2070%2B,in%20any%20Vue%203%20app))。これにより自社のデザインガイドラインに沿った見た目を作り込みやすくなっています。また、TypeScriptサポートが第一級で、軽量でパフォーマンスも良好です ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=Naive%20UI%20ships%20with%2070%2B,in%20any%20Vue%203%20app)) ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=With%20its%20support%20for%20light,both%20reliable%20and%20performant%20interfaces))。デザインはシンプルで現代的な雰囲気なので、社内ツールでも**スタイリッシュで軽快なUI**を実現したい場合に向いています。コミュニティはVuetifyほど大きくありませんが成長中で、公式の更新も頻繁です ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=BootstrapVue))。導入は`npm install naive-ui`後、必要なコンポーネントだけを按需（Tree-shaking）でインポートして使う形が推奨されています（全て一括も可能）。例えば main.js で:

  ```js
  import { createApp } from 'vue';
  import App from './App.vue';
  import { create, NButton } from 'naive-ui';
  const naive = create({
    components: [NButton]
  });
  createApp(App).use(naive).mount('#app');
  ```

  こうしておけばテンプレート内で`<n-button type="primary">Primary</n-button>`のように使用可能です。Naive UIは**軽量性と現代的な開発体験**を重視する場合に魅力的な選択肢です ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Built%20for%20Vue%203%20applications%2C,development%20of%20modern%2C%20responsive%20user)) ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Naive%20UI%20Simple%20and%20user,developers%20familiar%20with%20Bootstrap%20Easy))。

- **BootstrapVue:** BootstrapVueはその名の通り**Bootstrap** (世界で広く使われているCSSフレームワーク) をVueで手軽に使えるようにしたライブラリです ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=BootstrapVue%20integrates%20Bootstrap%20with%20Vue,or%20require%20a%20familiar%20framework))。Bootstrapに馴染みのある開発者なら、クラス名やレイアウト概念が共通しているため習得が容易で、既存のBootstrapテーマとも組み合わせやすい利点があります。「社内システムはとりあえず見た目はBootstrapでOK」という場合、BootstrapVueを使えばVueコンポーネントとしてBootstrapの各種UI部品（ボタン、フォーム、モーダル、カード等）を配置できます ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=BootstrapVue%20integrates%20Bootstrap%20with%20Vue,or%20require%20a%20familiar%20framework))。例えば`<b-button variant="success">Save</b-button>`のように使います。文法もシンプルで公式ドキュメントやコミュニティも充実しています ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Review%20from%20Quora%2C%20Reddit%3A%20BootstrapVue,use%20syntax%20and%20comprehensive%20documentation))。注意点として、**現時点（Vue 3 時代）ではBootstrapVueの公式対応が遅れている**点があります。BootstrapVueはVue 2 + Bootstrap 4向けに作られており、Vue 3 + Bootstrap 5対応のプロジェクト（BootstrapVue Next）が進行中ですが、2025年時点でも完全な安定版には至っていない状況です ([vue.js - BootstrapVue in VueJS 3 - Stack Overflow](https://stackoverflow.com/questions/73264271/bootstrapvue-in-vuejs-3#:~:text=BootstrapVue%20in%20VueJS%203%20%C2%B7,Titus)) ([bootstrap-vue-3 - NPM](https://www.npmjs.com/package/bootstrap-vue-3#:~:text=bootstrap,last%20published%3A%202%20years%20ago))。そのためVue 3でBootstrap系デザインを使いたい場合、**代替案**として以下があります: (1) BootstrapのCSSを直接読み込んで、レイアウトはBootstrapのグリッドを使いつつ、細かな部品は自作 or 別ライブラリで補う、(2) community版のBootstrapVue 3（Bootstrap 5対応版）を利用する。いずれにせよ、Bootstrap自体はjQuery依存がなくなっているのでVueと共存可能です ([What is the story with BootstrapVue now? : r/vuejs - Reddit](https://www.reddit.com/r/vuejs/comments/11f9yq5/what_is_the_story_with_bootstrapvue_now/#:~:text=Bootstrap%205%20itself%20works%20fine,to%20the%20removal%20of%20jQuery))。ファイルサイズはBootstrapのCSS分少し大きくなりますが、**デザインにこだわらず迅速にUIを構築したい場合**に有力です ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=BootstrapVue%20Easy%20to%20use%20for,js))。特に既存でBootstrapベースの社内ツールがありVueへリプレースしていくケースでは、見た目を踏襲しやすいというメリットがあります。

**【UIフレームワーク選定のポイント】**  
社内業務システムでは、「デザインの一貫性」と「開発スピード」が重要になります。Vue用UIフレームワークを使うことで、**統一された見た目のコンポーネント**（ボタン、入力フォーム、テーブル、ダイアログ等）を素早く配置できます。選定にあたっては以下の観点を考慮します:

- *デザイン方針:* Material DesignならVuetify、シンプルなビジネス向けならElement Plus、最新のフラットデザインでカスタムしたいならNaive UI、Bootstrap風で良いならBootstrapVueといった具合に、プロダクトの要求に合うスタイルかどうか。
- *導入の容易さ:* ドキュメントの充実度や学習コスト。BootstrapVueやElement Plusは取っ付きやすく、Vuetifyも情報が豊富です。Naive UIもシンプルさを売りにしているだけあってAPIは直感的ですが、日本語情報は他より少なめかもしれません。
- *コミュニティと継続性:* 業務システムでは長期間の保守を考える必要があります。VuetifyやElement Plusは大型アップデートにも対応しており、今後も安定して使える可能性が高いです ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=match%20at%20L175%20Vuetify%20is,companies%20due%20to%20the%20following)) ([The best UI frameworks for Vue 3 - LogRocket Blog](https://blog.logrocket.com/best-ui-frameworks-vue-3/#:~:text=match%20at%20L113%20Element%20Plus,high%20customizability%20via%20SCSS%20variables))。Naive UIも急速に普及してきていますが、新興ゆえに今後の成熟を見守る部分があります。BootstrapVue (Next) はプロジェクトの進捗状況を確認しつつ採用すべきです。

なお、複数のUIフレームワークを**併用するのは避ける**のが無難です。スタイルの衝突やバンドルサイズ増大を招くため、プロジェクト開始時にどれか一つを選び、全体で統一することをおすすめします。

## 開発効率化ツール: Vue DevToolsとコード品質管理

Vueによる開発をスムーズに進め、コードの品質を維持するための便利なツール類について解説します。jQuery開発ではあまり意識しなかった開発支援ツールも、SPA開発では積極的に活用することがポイントです。

### Vue DevToolsの基本的な使い方

**Vue DevTools**は、Vue.js公式のブラウザ拡張機能で、アプリの内部状態を視覚的にデバッグできる強力なツールです。ChromeやFirefoxの拡張として提供されており、インストールするとブラウザの開発者ツール内に「Vue」という専用タブが追加されます ([Vue.js devtoolsの使い方まとめ #JavaScript - Qiita](https://qiita.com/haykubo/items/fce1674365b2b622c70c#:~:text=Vue,%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82)) ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E3%83%87%E3%83%99%E3%83%AD%E3%83%83%E3%83%91%E3%83%BC%E3%83%84%E3%83%BC%E3%83%AB%E3%82%92%E9%96%8B%E3%81%8F%E3%81%A8%E3%80%81Vue%20%E3%82%BF%E3%83%96%E3%82%92%E8%A6%8B%E3%81%A4%E3%81%91%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20Image))。

- **導入:** Chromeの場合、Chromeウェブストアで「Vue.js devtools」を検索してインストールできます（提供元が公式のもの）。インストール後、ローカルファイルにアクセスできる権限を有効にしておくと、`file://`で開いたページでも動作します ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E6%A4%9C%E7%B4%A2%E6%AC%84%E3%81%A7%20%E3%80%8Cvue%20js%20devtools%E3%80%8D%E3%81%8B%E3%82%89%E6%8F%90%E4%BE%9B%E5%85%83%E3%81%8Chttps%3A%2F%2Fvuejs,%E3%81%AB%E8%BF%BD%E5%8A%A0%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Image))。

- **利用方法:** Vueアプリのページを開くと、拡張機能のVueアイコンが有効化されます ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E4%B8%8B%E8%A8%98%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%20Vue%20%E3%81%AE%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3%E3%81%8C%E6%B4%BB%E6%80%A7%E5%8C%96%E3%81%97%E3%81%A6%E3%81%84%E3%82%8C%E3%81%B0%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%A7%E3%81%99%E3%80%82%20Image))。ブラウザの開発者コンソールを開き「Vue」タブを選択すると、現在開いているページ上のVueコンポーネントツリーが表示されます ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E4%B8%8B%E8%A8%98%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%20Vue%20%E3%81%AE%E3%82%A2%E3%82%A4%E3%82%B3%E3%83%B3%E3%81%8C%E6%B4%BB%E6%80%A7%E5%8C%96%E3%81%97%E3%81%A6%E3%81%84%E3%82%8C%E3%81%B0%E3%80%81%E4%BD%BF%E7%94%A8%E5%8F%AF%E8%83%BD%E3%81%A7%E3%81%99%E3%80%82%20Image))。コンポーネントツリーでは、ルートのVueインスタンスから子孫のコンポーネントまで階層構造で一覧できます。任意のコンポーネントを選択すると、そのコンポーネントが持つ**データ(data)**や**プロパティ(props)**、**算出プロパティ(computed)**の現在値が右ペインに表示されます ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E7%8F%BE%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A6%AA%E5%AD%90%E9%96%A2%E4%BF%82%E3%81%8C%E3%83%84%E3%83%AA%E3%83%BC%E4%B8%8A%E3%81%A7%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E6%B3%A8%E7%9B%AE%E3%81%97%E3%81%9F%E3%81%84%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E3%83%95%E3%82%A9%E3%83%BC%E3%82%AB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%A8%E3%80%81%E5%AF%BE%E8%B1%A1%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%20props%20%E3%82%84%20data%E3%80%81computed%20%E3%81%AE%E5%80%A4%E3%81%AA%E3%81%A9%E3%82%92%E8%A6%8B%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%A7%E3%81%84%E3%81%A1%E3%81%84%E3%81%A1%E3%82%B3%E3%83%B3%E3%82%BD%E3%83%BC%E3%83%AB%E3%81%AB%E5%80%A4%E3%82%92%E5%87%BA%E3%81%97%E3%81%A6%E7%A2%BA%E8%AA%8D%E3%81%97%E3%81%AA%E3%81%8F%E3%81%A6%E3%82%82%E3%81%84%E3%81%84%E3%81%A7%E3%81%99%E3%81%AD%21))。これにより「コンソールに`console.log`で値を出力しなくても、リアルタイムにコンポーネントの状態を確認・編集できる」ようになります ([Vue.js devtoolsの使い方まとめ #JavaScript - Qiita](https://qiita.com/haykubo/items/fce1674365b2b622c70c#:~:text=Vue,%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82))。

  - **データの編集:** DevTools上で表示されているデータは直接編集することもできます。例えばタスク一覧配列を持つコンポーネントで、その配列の中身をDevTools上から操作すると、即座に実際のアプリ画面にも反映されます。これを利用して**一時的に状態を書き換えて動作検証**する、といったことも可能です。Vue DevToolsを使うことで「コンポーネントを選んでデータをいじれば画面が変わる」という直感的なデバッグができます。

  - **イベントとVuex/Pinia:** DevToolsには他にも**Eventsタブ**や**Vuexタブ (Vue 2の場合) / Piniaタブ (Vue 3の場合)**などがあります。Eventsタブではカスタムイベントの発火履歴を時間順に追いかけることができ、どのコンポーネントからどんなペイロードでイベントが飛んだかがわかります ([How To Debug Components, State, and Events with Vue.js Devtools | DigitalOcean](https://www.digitalocean.com/community/tutorials/how-to-debug-components-state-and-events-with-vue-js-devtools#:~:text=the%20inner%20workings%20of%20their,Vuex%20actions%2C%20getters%2C%20and%20mutations))。これによりコンポーネント間通信の流れを把握しやすく、イベント駆動部分のデバッグが容易です。また、状態管理ライブラリ（VuexやPinia）を使っている場合、専用のタブでストアの中身を閲覧・操作できます。**時間遡行デバッグ (Time Travel Debugging)**の機能も統合されており、ストアのミューテーション履歴を遡って過去の状態を再現するといった高度なデバッグも可能です ([Introduction | Vue DevTools](https://devtools.vuejs.org/getting-started/introduction#:~:text=,application%27s%20state%20changes%20over%20time))。これは複雑な業務ロジックのバグ追跡に非常に役立ちます。

Vue DevToolsにより、Vueアプリ開発の生産性とバグ修正効率は格段に向上します ([Introduction | Vue DevTools](https://devtools.vuejs.org/getting-started/introduction#:~:text=Vue%20DevTools%20is%20a%20tool,js%20developer))。jQuery開発ではDOMそのものを調べていましたが、Vueでは**コンポーネントとその持つデータの単位でアプリを把握できる**点が大きな違いです。例えば「あるボタンをクリックしても動作しない」場合でも、DevToolsでそのボタンコンポーネントの`props`や内部データを確認したり、イベント発火ログを追ったりすることで原因究明がスムーズになります。Vue DevToolsは公式が提供しているだけあって信頼性も高く、業務でVueを使うなら必須とも言えるツールです。 ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=Vue,%E3%81%AE%E7%8A%B6%E6%85%8B%E3%82%84%E6%A7%8B%E9%80%A0%E3%80%81Vuex%20%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%97%E3%81%A6%E3%81%84%E3%82%8C%E3%81%B0%20Store%20%E3%81%AE%E7%8A%B6%E6%85%8B%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Event%20%E3%81%AE%E5%B1%A5%E6%AD%B4%E3%82%82%E8%BF%BD%E3%81%A3%E3%81%8B%E3%81%91%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%AE%E3%81%A7%E3%80%81%E5%8A%B9%E7%8E%87%E3%82%88%E3%81%8F%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))

### ESLintとPrettierを使ったコード品質維持

**ESLint**と**Prettier**は、JavaScript/TypeScriptのコードの品質とスタイルを維持するためによく使われるツールです。Vue.jsプロジェクトでもこれらを導入することで、チーム開発でも読みやすく安定したコードベースを保つことができます。jQueryで数百行程度のスクリプトを書いていた頃はあまり意識しなかったかもしれませんが、Vueでアプリケーション開発を行う場合、コード量も増大しがちなためリンターやフォーマッターの助けが重要になります。

- **ESLint (リンター):** ESLintはコードを静的解析してバグの元になるコードやスタイル規約に違反しているコードを検出し、警告・エラー表示してくれるツールです ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Linting%20is%20an%20automated%20process,and%20follows%20the%20best%20practices))。例えば**セミコロンの付け忘れ**、**未使用の変数**、**未定義の変数へのアクセス**、**不適切な比較演算子の使用**など、実行する前に問題を指摘してくれます ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Linting%20is%20an%20automated%20process,and%20follows%20the%20best%20practices))。またプロジェクトで決めたコーディング規約（インデント幅やクォートの種類、スペースの有無など）に則っているかもチェック可能です。ESLint自体はルールの集合で、必要に応じて有名なスタイルガイド（例えばAirbnbスタイルガイド）やVue用のプラグイン(`eslint-plugin-vue`)を組み合わせて設定します。Vue CLIやViteでプロジェクトを作成する際にESLint導入を選択すれば、基本的な設定が最初から含まれるのでおすすめです。ESLintをエディタ（VSCodeなど）と連携すれば、保存時や入力中に問題箇所をリアルタイムで指摘してくれます。Lintツールを導入することで、**ヒューマンエラーを早期に発見**し、コードレビューの負担も減らすことができます。

- **Prettier (フォーマッター):** Prettierはプログラムの構文を解析して、自動的にコードを整形してくれるツールです。ESLintが主にエラーやコード上の問題検出にフォーカスしているのに対し、Prettierは**コードの書式（フォーマット）統一**に特化しています ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=The%20thing%20is%20that%20the,single%2Fdouble%20quotes%2C%20and%20so%20on))。たとえばクォートをシングルかダブルか統一する、インデントのスペース数を揃える、不要なカンマや括弧の位置を調整するといったルールに従って、コードをきれいに整形します。Prettierを使えば開発者各自の書き方のクセを強制的になくし、プロジェクト全体で一貫したスタイルを保てます。「フォーマッターが勝手にやってくれる」ので開発者同士でスタイルの些細な違いで議論する必要もなくなります。Prettierは**ESLintではカバーしきれないフォーマット部分を包括的に担う**存在といえ、ESLint+Prettierを組み合わせることでコード品質管理がほぼ自動化できます ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Prettier%20is%20a%20more%20complete,coding%20standards%20in%20the%20codebase))。

- **ESLintとPrettierの併用:** 二つのツールは目的が異なるため併用が推奨されています。実際、Vue公式CLIで`ESLint + Prettier`オプションを選ぶと、ESLintの設定にPrettier用の拡張（`eslint-config-prettier`）が組み込まれ、競合するルールを無効化するようになっています ([How To Configure ESLint and Prettier for Vue.js | DigitalOcean](https://www.digitalocean.com/community/tutorials/vuejs-vue-eslint-prettier#:~:text=Add%20%60,property%20after))。これによりESLintでコード問題を検出しつつ、フォーマット部分はPrettierに任せるというすみ分けができます。開発ワークフローとしては、**ESLint**をCIに組み込んでコード品質を担保し、**Prettier**はエディタの保存時フックなどで自動整形するようにすると効率的です。「Lint→Fix→Format」のサイクルを開発の中に組み込むことで、人手によるレビューより先に機械的な品質チェックが入る仕組みになります。

**【業務開発でのメリットと注意点】**  
jQueryでの開発ではコード量も少なめでチーム開発でなければ、コーディングスタイルは各人に委ねられていました。しかし業務アプリ開発では**複数人で大量のコードを書く**ケースが増えます。ESLintとPrettierを使えば、「うっかりミスで動かないコードをリリースしてしまう」ことを防ぎ ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Linting%20is%20an%20automated%20process,and%20follows%20the%20best%20practices))、「プロジェクト内でタブとスペースが混在して見にくい」といった事態も避けられます ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=The%20thing%20is%20that%20the,single%2Fdouble%20quotes%2C%20and%20so%20on))。特にVueの単一ファイルコンポーネントではテンプレート内にHTML、スクリプト内にJSが混在するため、Lint/フォーマットツールで整形する効果が大きいです。

導入の際の注意点として、既存プロジェクトに適用すると大量のLintエラーやフォーマット差分が出ることがあります。一度に修正しきれない場合はルールを徐々に厳しくするか、段階的に適用するのも手です。またPrettier適用でdiffが増えるため、プロジェクトの最初期に導入してしまうのが理想です。VSCodeなどでは公式の**Volar**拡張（Vue 3用）とESLint拡張を入れておくと、`.vue`ファイル内でもLint結果がインライン表示されたり、フォーマットオンセーブが効くので開発体験が向上します ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry International](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Setting%20Up%20ESLint%20%26%20Prettier,When))。

## デプロイ方法: GitHub Pagesを用いたVueアプリの公開

開発が一通り完了したら、作成したVueアプリを社内またはインターネット上に**デプロイ（公開）**して実際に使えるようにする必要があります。ここでは**GitHub Pages**を使ったデプロイ手順と、業務ツールとして公開する際の実用的なポイントを説明します。GitHub Pagesは静的サイトホスティングサービスで、Vueによるシングルページアプリケーション（SPA）もビルド後の静的ファイルをホスティングする形で公開できます。

### GitHub Pagesへの基本的なデプロイ手順

1. **プロダクションビルドの実行:** まずVueアプリを本番用にビルドします。Vue CLIプロジェクトなら`npm run build`（viteやvue-cli-serviceにより`dist/`フォルダが生成されます）、Viteプロジェクトでも`npm run build`で同様に生成物が得られます。これにより、最適化・圧縮された静的ファイル一式（HTML, CSS, JS, 画像など）が`dist`ディレクトリに出力されます。

2. **GitHubリポジトリの用意:** 公開用にGitHub上にリポジトリを作成します。GitHub Pagesはリポジトリごとに1サイト公開できます。基本的に**パブリックなリポジトリ**であれば無料プランでもPagesを利用可能です（プライベートリポジトリだと制限あり） ([〖Vue.js〗アプリをGitHub  Pagesにデプロイする方法 | macocci7s blog](https://macocci7.net/blog/2024/01/21/%E3%80%90vue-js%E3%80%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92github-pages%E3%81%AB%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/#:~:text=GitHub%E5%85%AC%E9%96%8B%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%81%AE%E4%BD%9C%E6%88%90))。既存のコードをGitHubにプッシュしていない場合、この段階で`git init`→コミット→GitHubにプッシュしてリポジトリを連携させます。

3. **GitHub Pagesで公開:** リポジトリの設定でPagesを有効化します。方法は2通りあります。1つは、**`gh-pages`ブランチ**を使う方法、もう1つは**GitHub Actions**を使ってデプロイする方法です。
   - **gh-pagesブランチを直接使う:** ビルドしてできた`dist`フォルダの中身を、そのままリポジトリの`gh-pages`というブランチにコミット・プッシュします。GitHubの設定でPagesのソースを`gh-pages`ブランチに指定すると、それを公開してくれます。手動でブランチを管理しても良いですが、便利な方法として**npmパッケージの「gh-pages」**を使えます ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=Run%20the%20following%20command%20to,install%20it))。`npm install gh-pages --save-dev`で導入し、`package.json`のscriptsに `"deploy": "gh-pages -d dist"` を追加しておけば、`npm run deploy`コマンド一発でビルド成果物を`gh-pages`ブランチに自動コミット&プッシュしてくれます ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=npm%20install%20gh)) ([Vite+Vue3+TypeScript+Vue RouterのプロジェクトをGithub Pagesでデプロイする #vite - Qiita](https://qiita.com/gaasuu_itnav/items/c8400ab1ecf112c8e9a4#:~:text=3.%20%60yarn%20add%20gh,json%E3%81%AB%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E8%BF%BD%E5%8A%A0))。実行後、自分のリポジトリに`gh-pages`ブランチが作成され、その下に`dist`の内容がアップされます ([Vite+Vue3+TypeScript+Vue RouterのプロジェクトをGithub Pagesでデプロイする #vite - Qiita](https://qiita.com/gaasuu_itnav/items/c8400ab1ecf112c8e9a4#:~:text=match%20at%20L184%20%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%ABgh,test))。リポジトリ設定のPagesを確認すると、自動的に`gh-pages`ブランチが選択され公開状態になっているはずです ([Vite+Vue3+TypeScript+Vue RouterのプロジェクトをGithub Pagesでデプロイする #vite - Qiita](https://qiita.com/gaasuu_itnav/items/c8400ab1ecf112c8e9a4#:~:text=%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%ABgh,test))。この方法はシンプルで、GH Pages用に専用ブランチを管理できる利点があります。
   - **GitHub Actionsを使う:** GitHub Actionsのワークフローを利用して、自動でビルド＆デプロイする方法です。GitHubが用意しているPages公開用の公式Actionや、コミュニティ提供のActionを使うことで、例えば`main`ブランチにプッシュしたらCIが走り、自動でビルドして`gh-pages`ブランチまたは`docs`フォルダにデプロイする、といった自動化が可能です ([【Vue3】GitHub Pagesのデプロイだけでなくビルドも自動化する](https://zenn.dev/tinytony/articles/8db0967a239635#:~:text=Settings%E3%82%BF%E3%83%96%E3%82%92%E9%96%8B%E3%81%8D%E3%80%81%E5%B7%A6%E3%81%AE%E4%B8%80%E8%A6%A7%E3%81%8B%E3%82%89Pages%E3%82%92%E9%81%B8%E6%8A%9E%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E7%94%BB%E5%83%8F%E4%B8%AD%E5%A4%AE%E3%81%AE%E3%80%8CBuild%20and%20deployment%E3%80%8D%E3%81%8C%E5%AF%BE%E8%B1%A1%E3%81%AE%E8%A8%AD%E5%AE%9A%E9%A0%85%E7%9B%AE%E3%81%A7%E3%81%99%E3%80%82%202,Build%20and%20deployment%E3%82%92%E3%80%8CGitHub)) ([〖Vue.js〗アプリをGitHub  Pagesにデプロイする方法 | macocci7s blog](https://macocci7.net/blog/2024/01/21/%E3%80%90vue-js%E3%80%91%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92github-pages%E3%81%AB%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%99%E3%82%8B%E6%96%B9%E6%B3%95/#:~:text=3,17))。Vue CLIでもテンプレートが用意されています。この方法だと開発者が手元でビルド・デプロイ作業をする必要がなくなり、デプロイミスも減ります。初期設定は多少手間ですが、一度構築すれば以降はPushするだけで常に最新がデプロイされる流れになります。

4. **公開URLの確認:** GitHub Pagesで公開されたサイトは、URLが **`https://<GitHubユーザ名>.github.io/<リポジトリ名>/`** となります（プロジェクトページの場合） ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=If%20you%E2%80%99re%20not%20using%20a,subfolder%20by%20default%20like%20this))。ブラウザでそのURLにアクセスし、アプリが正しく動作するか確認します。もし表示されない場合は、リポジトリ設定のPages項目やデプロイログ（Actionsを使った場合）を確認してみましょう。

### デプロイ時の注意点と業務での実用ポイント

GitHub Pagesへのデプロイは比較的簡単ですが、いくつか**ハマりやすい点**や**考慮すべき事項**があります。

- **パスの設定 (Base URL):** GitHub Pagesでホストされるプロジェクトページは`/<リポジトリ名>/`以下にコンテンツが配置されます ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=If%20you%E2%80%99re%20not%20using%20a,subfolder%20by%20default%20like%20this))。そのため、ビルドされたアプリが内部で参照する静的リソース（JSやCSSファイル、画像など）のパスもそれに対応する必要があります。Vue CLIの場合、`vue.config.js`に`publicPath`オプションを設定することで解決できます。例えばリポジトリ名が`my-app`なら、`publicPath: '/my-app/'`とします。Viteの場合はプロジェクトの`vite.config.js`で`base: '/my-app/'`のように指定します ([Vite+Vue3+TypeScript+Vue RouterのプロジェクトをGithub Pagesでデプロイする #vite - Qiita](https://qiita.com/gaasuu_itnav/items/c8400ab1ecf112c8e9a4#:~:text=base%3A%20process,vue%28%29%5D%2C))。これによりビルド時に生成されるファイル参照パスが修正され、GitHub Pages上でも正しくファイルを読み込めるようになります。もしこの設定を忘れると、ページを開いても真っ白で、ブラウザのコンソールに404エラー（ファイルが見つからない）がたくさん出る、といったことになりがちです。「ローカルでは動くのにPagesに上げたら動かない」という場合はまずこのパス設定を疑ってみてください ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=%60https%3A%2F%2F))。

- **ルーティングモードの選択:** Vue Routerを使っているSPAをGitHub Pagesで公開する場合、**ヒストリーモード**だと直接URLを打ち込んだ際に404エラーになる問題があります。GitHub Pagesは静的ホスティングなので、存在しないパスに対するリクエストをサーバ側で処理できないためです。対策として、**ハッシュモード (`createWebHashHistory` を使用)** に切り替えるか、404.htmlを設置してSPAにリダイレクトする方法があります。簡単なのはハッシュモードにすることで、URLが`#/home`のようになってサーバには`index.html`へのリクエストしか飛ばないようになります。業務ツールで社内利用ならURLの見た目はそれほど問題にならないことも多いので、手っ取り早くハッシュモードを採用するのも一案です。ヒストリーモードでどうしても運用したい場合は、GitHub Pagesでは公式に404.htmlを使ったSPA対応策が紹介されていますので検討してください。

- **公開範囲とセキュリティ:** GitHub Pagesで公開したサイトは**基本的にインターネット上に公開**されます。リポジトリがパブリックであれば誰でもURLを知っていればアクセス可能です。もし**社内ツールとして社外に秘匿したい**場合は注意が必要です。GitHub Enterprise Cloudを利用している場合、**Pagesのアクセス制限**機能が使え、リポジトリに閲覧権限を持つユーザーのみに公開サイトを限定できます ([Changing the visibility of your GitHub Pages site - GitHub Enterprise Cloud Docs](https://docs.github.com/enterprise-cloud@latest/pages/getting-started-with-github-pages/changing-the-visibility-of-your-github-pages-site#:~:text=With%20access%20control%20for%20GitHub,with%20members%20of%20your%20enterprise))。ただしこれは有料のEnterpriseプラン限定機能です。無料利用では、コードをプライベートリポジトリに置いてもPagesサイト自体は公開されてしまう（2024年から一部制限付きでプライベートPagesも試験提供されていますが一般ユーザには現時点では公開のみ）点に留意してください ([About GitHub Pages](https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages#:~:text=About%20GitHub%20Pages%20GitHub%20Pages,If%20you))。社内だけで使いたいがEnterprise利用ではない場合、**公開後すぐにURLを共有しない**（セキュリティ通过にあまり意味はありませんが）程度しか対策がありません。あるいは、GitHub Pagesはあくまで開発・検証用途に留め、本番運用は社内サーバやクラウド上の保護された環境にデプロイする判断も必要です。

- **その他の実用ポイント:** 業務での公開では、可能なら**自動デプロイの仕組み**を取り入れるとよいでしょう。例えば上記のGitHub Actionsを使った自動デプロイは、本番環境への反映ミスを減らし部署内でのデプロイ作業の属人化を防ぎます。また、Pagesで公開したツールに**ベーシック認証**などを付けたい場合がありますが、Pages自体は静的でサーバサイド処理がないため認証機能を持ちません。その場合は、簡易的にクライアントサイドでログインUIを作り許可されたパスワードを入力したら利用可能にするといった実装を入れる例もあります（セキュリティ強度は高くありませんがないよりマシです）。重要情報を扱う場合はそもそもPagesに置かないほうが良いです。

GitHub Pagesは**無料で手軽**に使えるため、業務アプリのプロトタイプ共有や小規模ツール公開には大いに役立ちます。実際の運用で要件が増えてきたら、将来的に社内サーバへの移行やクラウドサービス（AWS Amplify, Netlify, Vercelなど静的サイトホスティング＋認証サービスが使えるもの）への展開も視野に入れるとよいでしょう。一旦Pagesで公開しておけば、そこで得たデプロイ知見やビルド成果物は他環境へも活かせます。

---

以上、Vueによる実践アプリ開発のステップ3に沿って、「ToDoアプリ実装」「UIフレームワーク導入」「開発効率化ツール」「デプロイ方法」の各テーマについて解説しました。**jQueryからVueへのパラダイムシフト**として、DOM操作中心から**コンポーネントとデータ中心**の開発になる点が全編に共通するキーポイントです。最初は戸惑うかもしれませんが、小さなアプリで基本を掴み、UIライブラリで生産性を上げ、ツールで品質を担保し、デプロイまで一通り経験することで、業務レベルのVueアプリ開発に必要なスキルセットが身につきます。jQueryの経験は決して無駄にならず、イベントの扱いやJavaScriptの知識はVueでも活きますので、ぜひ段階的にVue開発に慣れていってください。その先には、さらに大規模な状態管理(VuexやPinia)や型導入(TypeScript)などのステップもありますが、まずは今回解説した内容を自分のプロジェクトで試してみることをおすすめします。今までjQueryで培った経験にVueのパワーを掛け合わせて、快適で保守性の高い業務アプリを開発していきましょう。  

**参考文献・資料:** Vue公式ガイド、各種UIフレームワーク公式ドキュメント、および以下の出典を参照しました。

- Vue vs jQueryのアプローチ比較 ([Making the Move from jQuery to Vue | CSS-Tricks](https://css-tricks.com/making-the-move-from-jquery-to-vue/#:~:text=el%3A%20%27,)) ([Making the Move from jQuery to Vue | CSS-Tricks](https://css-tricks.com/making-the-move-from-jquery-to-vue/#:~:text=In%20this%20example%2C%20we%E2%80%99re%20using,inner%20text%20will%20change%20automatically))
- Vue.jsによるToDoアプリ実装例（LocalStorage連携） ([Creating a To-Do List with Vue.js: A Practical Tutorial | by Raymundo Bojorges | Frontend at Accenture | Medium](https://medium.com/frontend-at-accenture/creating-a-to-do-list-with-vue-js-a-practical-tutorial-d785df6ab02d#:~:text=const%20addTask%20%3D%20%28%29%20%3D,)) ([Creating a To-Do List with Vue.js: A Practical Tutorial | by Raymundo Bojorges | Frontend at Accenture | Medium](https://medium.com/frontend-at-accenture/creating-a-to-do-list-with-vue-js-a-practical-tutorial-d785df6ab02d#:~:text=onMounted%28%28%29%20%3D,%7C%7C%20%5B%5D%3B%20%7D))
- Vuetify/Element Plus/Naive UI/BootstrapVue 各UIライブラリの特徴 ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Vuetify%20is%20a%20Material%20Design,js%20UI)) ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Review%20from%20Quora%2C%20Reddit%3A%20Element,level%20applications)) ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=Built%20for%20Vue%203%20applications%2C,development%20of%20modern%2C%20responsive%20user)) ([Top 10 Vue.js UI Libraries for Modern Web Development 2025 - Top Mobile App Development Company in Singapore | Vinova SG](https://vinova.sg/2025/01/13/vue-js-ui-libraries-web-development-2025/#:~:text=BootstrapVue%20integrates%20Bootstrap%20with%20Vue,or%20require%20a%20familiar%20framework))
- Vue DevToolsの概要と機能 ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=Vue,%E3%81%AE%E7%8A%B6%E6%85%8B%E3%82%84%E6%A7%8B%E9%80%A0%E3%80%81Vuex%20%E3%82%92%E5%B0%8E%E5%85%A5%E3%81%97%E3%81%A6%E3%81%84%E3%82%8C%E3%81%B0%20Store%20%E3%81%AE%E7%8A%B6%E6%85%8B%E3%81%AE%E7%A2%BA%E8%AA%8D%E3%82%82%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82Event%20%E3%81%AE%E5%B1%A5%E6%AD%B4%E3%82%82%E8%BF%BD%E3%81%A3%E3%81%8B%E3%81%91%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%82%8B%E3%81%AE%E3%81%A7%E3%80%81%E5%8A%B9%E7%8E%87%E3%82%88%E3%81%8F%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82)) ([Vue.js devtoolsで開発効率アップ! - ブログ - 株式会社Smallit（スモーリット）](https://smallit.co.jp/blog/841/#:~:text=%E7%8F%BE%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%E8%A6%AA%E5%AD%90%E9%96%A2%E4%BF%82%E3%81%8C%E3%83%84%E3%83%AA%E3%83%BC%E4%B8%8A%E3%81%A7%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E6%B3%A8%E7%9B%AE%E3%81%97%E3%81%9F%E3%81%84%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E3%83%95%E3%82%A9%E3%83%BC%E3%82%AB%E3%82%B9%E3%81%99%E3%82%8B%E3%81%A8%E3%80%81%E5%AF%BE%E8%B1%A1%E3%81%AE%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AE%20props%20%E3%82%84%20data%E3%80%81computed%20%E3%81%AE%E5%80%A4%E3%81%AA%E3%81%A9%E3%82%92%E8%A6%8B%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%A7%E3%81%84%E3%81%A1%E3%81%84%E3%81%A1%E3%82%B3%E3%83%B3%E3%82%BD%E3%83%BC%E3%83%AB%E3%81%AB%E5%80%A4%E3%82%92%E5%87%BA%E3%81%97%E3%81%A6%E7%A2%BA%E8%AA%8D%E3%81%97%E3%81%AA%E3%81%8F%E3%81%A6%E3%82%82%E3%81%84%E3%81%84%E3%81%A7%E3%81%99%E3%81%AD%21))
- ESLintとPrettierによるコード品質管理の解説 ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Linting%20is%20an%20automated%20process,and%20follows%20the%20best%20practices)) ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=The%20thing%20is%20that%20the,single%2Fdouble%20quotes%2C%20and%20so%20on)) ([Setting Up ESLint & Prettier In A Vue.js Project - Redberry](https://redberry.international/setting-up-eslint-prettier-in-a-vue-js-project/#:~:text=Prettier%20is%20a%20more%20complete,coding%20standards%20in%20the%20codebase))
- GitHub Pagesへのデプロイ手順と注意点 ([How to Deploy Your Vite/Vue 3 Application in GitHub Pages 2023 | by Monica K | Medium](https://mkay11.medium.com/how-to-deploy-your-vite-vue-3-application-in-github-pages-2023-2b842f50576a#:~:text=If%20you%E2%80%99re%20not%20using%20a,subfolder%20by%20default%20like%20this)) ([Vite+Vue3+TypeScript+Vue RouterのプロジェクトをGithub Pagesでデプロイする #vite - Qiita](https://qiita.com/gaasuu_itnav/items/c8400ab1ecf112c8e9a4#:~:text=%E8%87%AA%E5%8B%95%E7%9A%84%E3%81%ABgh,test))


ありがとうございます。Vueステップ4の応用フェーズについて、以下の前提をもとに丁寧な解説と具体例を含むレポート形式で深掘りします：
- SSR/SSG（Nuxt 3）については初期表示速度改善を目的として注目。
- テストは未経験で、特にコンポーネントテストを重点的に知りたい。
- パフォーマンス最適化は必須ではないが基本知識として知っておきたい。

調査が完了次第、実務への応用を交えた形式でご報告します。しばらくお待ちください。

# Vue学習ステップ4：応用と発展レポート

## 1. SSRとSSG：Nuxt 3入門

### Nuxtの役割と導入意義（初期表示速度の改善を軸に）
**SSR（Server-Side Rendering）**とは、WebページのHTMLをサーバ側で生成し、完成した状態でブラウザに送る仕組みです。これによりユーザーのブラウザは受け取ったHTMLをすぐ表示できるため、初回のページ表示が高速になります ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%20SSR%20%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B%E5%89%8D%E3%81%AB%E3%80%81%E3%81%BE%E3%81%9A%E5%95%8F%E3%81%86%E3%81%B9%E3%81%8D%E8%B3%AA%E5%95%8F%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E6%9C%AC%E5%BD%93%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%A9%E3%82%8C%E3%81%A0%20%E3%81%91%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%81%8B%E6%AC%A1%E7%AC%AC%E3%81%A7%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E7%A4%BE%E5%86%85%E5%90%91%E3%81%91%E3%81%AE%E3%83%80%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9C%E3%83%BC%E3%83%89%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E6%95%B0%E7%99%BE%E3%83%9F%E3%83%AA%E7%A7%92%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%81%9D%E3%82%8C%E3%81%BB%E3%81%A9%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%80%81SSR%20%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E7%B5%B6%E5%AF%BE%E7%9A%84%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AB%E3%81%8A%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81SSR,%E3%81%AF%E6%9C%80%E5%A4%A7%E9%99%90%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E9%81%94%E6%88%90%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82))。特に**初期表示速度**（ファーストビュー）を重視する場合、SSRは大きな効果を発揮し、ユーザーはページ遷移直後にコンテンツを目にできます ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%20SSR%20%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B%E5%89%8D%E3%81%AB%E3%80%81%E3%81%BE%E3%81%9A%E5%95%8F%E3%81%86%E3%81%B9%E3%81%8D%E8%B3%AA%E5%95%8F%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E6%9C%AC%E5%BD%93%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%A9%E3%82%8C%E3%81%A0%20%E3%81%91%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%81%8B%E6%AC%A1%E7%AC%AC%E3%81%A7%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E7%A4%BE%E5%86%85%E5%90%91%E3%81%91%E3%81%AE%E3%83%80%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9C%E3%83%BC%E3%83%89%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E6%95%B0%E7%99%BE%E3%83%9F%E3%83%AA%E7%A7%92%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%81%9D%E3%82%8C%E3%81%BB%E3%81%A9%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%80%81SSR%20%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E7%B5%B6%E5%AF%BE%E7%9A%84%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AB%E3%81%8A%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81SSR,%E3%81%AF%E6%9C%80%E5%A4%A7%E9%99%90%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E9%81%94%E6%88%90%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82))。一方で、通常のSPAのような**CSR（Client-Side Rendering）**では、まず最小のHTMLと大量のJavaScriptを受け取り、ブラウザ上でレンダリング処理を行います。そのためページによっては、ユーザーが最初のコンテンツを見るまでにローディング画面が表示されたり空白時間が生じたりします。SSRはこの欠点を補い、**SEO（検索エンジン最適化）**の観点でも有利です（検索クローラーが完全なHTMLコンテンツを取得できるため） ([Top 10 Nuxt.js Secrets to Boost Your App's Performance - DEV Community](https://dev.to/hakimov_dev/top-10-nuxtjs-secrets-to-boost-your-apps-performance-564d#:~:text=SSR%20renders%20Vue%20components%20on,page%20loads%20and%20improved%20SEO))。

もっとも、SSR導入にはトレードオフもあります。例えば**サーバー負荷**や**実装の複雑さ**です。サーバ側でVueアプリケーションを動かしHTMLを生成するため、静的ファイルを配信するだけの場合よりサーバーのCPU負荷が高くなります ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=))。また、Node.jsサーバーのデプロイや、ブラウザ固有APIを使用する際の制約など、開発と運用がやや複雑になります ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=)) ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=,%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%A7%E3%81%8D%E3%82%8B%E7%92%B0%E5%A2%83%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82))。そのため、すべてのプロジェクトでSSRが必要とは限りません。**社内向けダッシュボード**のように「初期ロードが数百ミリ秒遅れても問題ない」ケースでは、SSRはオーバーエンジニアリングになるでしょう ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%20SSR%20%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B%E5%89%8D%E3%81%AB%E3%80%81%E3%81%BE%E3%81%9A%E5%95%8F%E3%81%86%E3%81%B9%E3%81%8D%E8%B3%AA%E5%95%8F%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E6%9C%AC%E5%BD%93%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%A9%E3%82%8C%E3%81%A0%20%E3%81%91%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%81%8B%E6%AC%A1%E7%AC%AC%E3%81%A7%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E7%A4%BE%E5%86%85%E5%90%91%E3%81%91%E3%81%AE%E3%83%80%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9C%E3%83%BC%E3%83%89%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E6%95%B0%E7%99%BE%E3%83%9F%E3%83%AA%E7%A7%92%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%81%9D%E3%82%8C%E3%81%BB%E3%81%A9%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%80%81SSR%20%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E7%B5%B6%E5%AF%BE%E7%9A%84%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AB%E3%81%8A%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81SSR,%E3%81%AF%E6%9C%80%E5%A4%A7%E9%99%90%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E9%81%94%E6%88%90%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82))。しかし、ユーザー向けサービスやマーケティングサイトのように**コンテンツ表示速度がビジネス上重要**な場合には、SSRによって最大限の初期ロードパフォーマンスを得られます ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%20SSR%20%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B%E5%89%8D%E3%81%AB%E3%80%81%E3%81%BE%E3%81%9A%E5%95%8F%E3%81%86%E3%81%B9%E3%81%8D%E8%B3%AA%E5%95%8F%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E6%9C%AC%E5%BD%93%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%A9%E3%82%8C%E3%81%A0%20%E3%81%91%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%81%8B%E6%AC%A1%E7%AC%AC%E3%81%A7%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E7%A4%BE%E5%86%85%E5%90%91%E3%81%91%E3%81%AE%E3%83%80%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9C%E3%83%BC%E3%83%89%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E6%95%B0%E7%99%BE%E3%83%9F%E3%83%AA%E7%A7%92%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%81%9D%E3%82%8C%E3%81%BB%E3%81%A9%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%80%81SSR%20%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E7%B5%B6%E5%AF%BE%E7%9A%84%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AB%E3%81%8A%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81SSR,%E3%81%AF%E6%9C%80%E5%A4%A7%E9%99%90%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E9%81%94%E6%88%90%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82))。

**SSG（Static Site Generation）**もSSRと並ぶ手法です。SSGではアプリケーションをビルドする時にあらかじめページのHTMLを生成（プリレンダリング）しておき、リクエスト時には**静的ファイル**としてそのHTMLを返します ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E9%9D%99%E7%9A%84%E3%82%B5%E3%82%A4%E3%83%88%E3%82%B8%E3%82%A7%E3%83%8D%E3%83%AC%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%EF%BC%88SSG%EF%BC%89%20%E3%81%AF%E3%80%81%E3%83%97%E3%83%AA%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%A8%E3%82%82%E5%91%BC%E3%81%B0%E3%82%8C%E3%80%81%E9%AB%98%E9%80%9F%E3%81%AA%E3%82%A6%E3%82%A7%E3%83%96%E3%82%B5%E3%82%A4%E3%83%88%E3%82%92%E6%A7%8B%E7%AF%89%E3%81%99%E3%82%8B%E3%80%81%E3%82%82%E3%81%86%201%20%E3%81%A4%E3%81%AE%E4%BB%A3%E8%A1%A8%E7%9A%84%E3%81%AA%E6%8A%80%E8%A1%93%E3%81%A7%E3%81%99%E3%80%82%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AE%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%20%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E3%80%81%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B6%E3%83%BC%E3%81%AB%E5%AF%BE%E3%81%97%E3%81%A6%E5%90%8C%E3%81%98%E3%81%A7%E3%81%82%E3%82%8C%E3%81%B0%E3%80%81%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E3%81%8C%E6%9D%A5%E3%82%8B%E3%81%9F%E3%81%B3%E3%81%AB%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%99%E3%82%8B%E4%BB%A3%E3%82%8F%E3%82%8A%E3%81%AB%E3%80%81%E3%81%82%E3%82%89%E3%81%8B%E3%81%98%E3%82%81%E3%83%93%E3%83%AB%E3%83%89%E6%99%82%E3%81%AB%E4%B8%80%E5%BA%A6%E3%81%A0%E3%81%91%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%97%E3%81%A6%E3%81%8A%E3%81%8F%E3%81%93,%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%83%97%E3%83%AA%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AF%E3%80%81%E9%9D%99%E7%9A%84%E3%81%AA%20HTML%20%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%97%E3%81%A6%E7%94%9F%E6%88%90%E3%83%BB%E6%8F%90%E4%BE%9B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。原理上、全ユーザーに対して同じ内容を提供できるページであれば都度サーバーでレンダリングする必要はなく、ビルド時に一回だけ描画しておけば良い、という考え方です。 ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%83%97%E3%83%AA%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AF%E3%80%81%E9%9D%99%E7%9A%84%E3%81%AA%20HTML%20%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%97%E3%81%A6%E7%94%9F%E6%88%90%E3%83%BB%E6%8F%90%E4%BE%9B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))そのため**SSGはSSRと同等の初期表示速度**を持ちながら、生成物が静的HTMLである分デプロイが容易で運用コストも低く抑えられます ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%83%97%E3%83%AA%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AF%E3%80%81%E9%9D%99%E7%9A%84%E3%81%AA%20HTML%20%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%A8%E3%81%97%E3%81%A6%E7%94%9F%E6%88%90%E3%83%BB%E6%8F%90%E4%BE%9B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。ただし、データが更新されるたびにサイト全体を再ビルド・再デプロイする必要があるため、頻繁に内容が変わるページには向きません ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=SSG%20%E3%81%AF%20SSR%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E5%90%8C%E3%81%98%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E7%89%B9%E6%80%A7%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%8A%E3%82%8A%E3%80%81%E5%84%AA%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E6%80%A7%E8%83%BD%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E5%90%8C%E6%99%82%E3%81%AB%E3%80%81%E5%87%BA%E5%8A%9B%E5%86%85%E5%AE%B9%E3%81%8C%E9%9D%99%E7%9A%84%E3%81%AA%20HTML,static%EF%BC%88%E9%9D%99%E7%9A%84%EF%BC%89%20%E3%81%A8%E3%81%84%E3%81%86%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%81%A7%E3%81%99%3A%20SSG%20%E3%81%AF%E9%9D%99%E7%9A%84%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%80%81%E3%81%A4%E3%81%BE%E3%82%8A%E3%83%93%E3%83%AB%E3%83%89%E6%99%82%E3%81%AB%E6%97%A2%E3%81%AB%E5%86%85%E5%AE%B9%E3%81%8C%E5%88%86%E3%81%8B%E3%81%A3%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E9%96%93%E3%81%A7%E5%A4%89%E6%9B%B4%E3%81%95%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AE%E3%81%AA%E3%81%84%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%99%E3%82%8B%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E3%81%AE%E3%81%BF%E9%81%A9%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%A4%89%E6%9B%B4%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%81%B3%E3%81%AB%E6%96%B0%E3%81%97%20%E3%81%84%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82))。もしサイトの内容が**ほぼ静的**（例えば会社紹介ページやブログ記事）であれば、SSRよりSSGの方が適切でしょう ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=SSG%20%E3%81%AF%20SSR%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A8%E5%90%8C%E3%81%98%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E7%89%B9%E6%80%A7%E3%82%92%E6%8C%81%E3%81%A3%E3%81%A6%E3%81%8A%E3%82%8A%E3%80%81%E5%84%AA%E3%82%8C%E3%81%9F%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E6%80%A7%E8%83%BD%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E5%90%8C%E6%99%82%E3%81%AB%E3%80%81%E5%87%BA%E5%8A%9B%E5%86%85%E5%AE%B9%E3%81%8C%E9%9D%99%E7%9A%84%E3%81%AA%20HTML,static%EF%BC%88%E9%9D%99%E7%9A%84%EF%BC%89%20%E3%81%A8%E3%81%84%E3%81%86%E3%82%AD%E3%83%BC%E3%83%AF%E3%83%BC%E3%83%89%E3%81%A7%E3%81%99%3A%20SSG%20%E3%81%AF%E9%9D%99%E7%9A%84%E3%81%AA%E3%83%87%E3%83%BC%E3%82%BF%E3%80%81%E3%81%A4%E3%81%BE%E3%82%8A%E3%83%93%E3%83%AB%E3%83%89%E6%99%82%E3%81%AB%E6%97%A2%E3%81%AB%E5%86%85%E5%AE%B9%E3%81%8C%E5%88%86%E3%81%8B%E3%81%A3%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E3%83%AA%E3%82%AF%E3%82%A8%E3%82%B9%E3%83%88%E9%96%93%E3%81%A7%E5%A4%89%E6%9B%B4%E3%81%95%E3%82%8C%E3%82%8B%E3%81%93%E3%81%A8%E3%81%AE%E3%81%AA%E3%81%84%E3%83%87%E3%83%BC%E3%82%BF%E3%82%92%E6%8F%90%E4%BE%9B%E3%81%99%E3%82%8B%E3%83%9A%E3%83%BC%E3%82%B8%E3%81%AB%E3%81%AE%E3%81%BF%E9%81%A9%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E3%83%87%E3%83%BC%E3%82%BF%E3%81%8C%E5%A4%89%E6%9B%B4%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%81%B3%E3%81%AB%E6%96%B0%E3%81%97%20%E3%81%84%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%8C%E5%BF%85%E8%A6%81%E3%81%A7%E3%81%99%E3%80%82))。一方、ユーザーごとに異なるダッシュボードページなど**動的データ**を扱う場合はSSRが適しています。

こうしたSSR/SSGをVueで実現するために登場したフレームワークが **Nuxt 3** です。Nuxtは「Vueを便利にしたヤツ」と言われるほど、既存のVue開発に数多くの強力な機能を付与します ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=Nuxt%E3%81%A8%E3%81%AF%E3%80%81%E4%B8%80%E8%A8%80%E3%81%A7%E8%A8%80%E3%81%86%E3%81%A8%E3%80%8CVue%E3%82%92%E4%BE%BF%E5%88%A9%E3%81%AB%E3%81%97%E3%81%9F%E3%83%A4%E3%83%84%E3%80%8D%E3%81%A7%E3%81%99%E3%80%82))。その最大の意義が**SSR/SSGの手軽な導入**にあります。Nuxt 3を使うと、開発者はSSR用の複雑な設定やサーバーとのやり取りを一から構築する必要がありません。Nuxtが用意するコマンドでプロジェクトを作成すれば、デフォルトでSSR対応の開発サーバーが立ち上がり、ビルド時に設定次第でSSG（静的サイト書き出し）も可能です。実際にNuxt 3では、プロジェクトの設定で`target: 'server'`（サーバーレンダリング）や`target: 'static'`（静的サイト生成）を選ぶだけで、SSRとSSGのどちらにも対応できます。また、Nuxtはサーバーサイドでレンダリングした後、クライアント側でVueを**ハイドレーション（復元）**する仕組みも備えており、SSRで生成された静的HTMLをそのままインタラクティブなSPAとして継続利用できます。これらの仕組みにより、**Nuxtを導入することで初期表示速度の高速化を容易に実現できる**のです ([Top 10 Nuxt.js Secrets to Boost Your App's Performance - DEV Community](https://dev.to/hakimov_dev/top-10-nuxtjs-secrets-to-boost-your-apps-performance-564d#:~:text=SSR%20renders%20Vue%20components%20on,page%20loads%20and%20improved%20SEO))。

**業務開発での利点:** ユーザーにコンテンツをいち早く届けることはUX向上や離脱率低下に直結します。例えばプロダクトのランディングページやECサイトの商品ページでSSRを使えば、ユーザーがアクセスした瞬間に商品情報や画像が表示され、スムーズに閲覧を開始できます。これはビジネス上のコンバージョンにも好影響を与えるでしょう。また検索エンジンはSSR/SSGによって得られるプレレンダリング済みのページを好むため、SEO面でも有利になります。Nuxt 3はこれらを**フレームワークレベルでサポート**してくれるため、SSRの恩恵を受けつつ生産的に開発を進められます。

### Nuxt 3のディレクトリ構造と自動ルーティング
Nuxt 3ではプロジェクトのディレクトリ構成があらかじめ定められており、これにより多くの機能が**規約に従って自動化**されています。特に重要なのが`pages/`ディレクトリで、ここに置いたVueファイルがそのままアプリのルート（URL）として扱われます ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60public%60%3A%20%E9%9D%99%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%EF%BC%88%E7%94%BB%E5%83%8F%E3%80%81%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%B7%E3%83%BC%E3%83%88%E3%80%81%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88.txt%E3%81%AA%E3%81%A9%EF%BC%89%E3%82%92%E6%A0%BC%E7%B4%8D%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E3%81%AE%E3%83%91%E3%82%B9%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。Nuxtの**ファイルシステムベースのルーティング**では、開発者が明示的にルーティング設定を記述しなくても、ファイル構造に応じてURLパスが自動生成されます ([Routing · Get Started with Nuxt](https://nuxt.com/docs/getting-started/routing#:~:text=One%20core%20feature%20of%20Nuxt,JavaScript%20for%20the%20requested%20route))。

例えば、`pages/index.vue`を作成すればサイトのトップページ(`/`)として表示され、`pages/about.vue`を作成すれば`/about`というURLに対応します ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=))。実際にブラウザで`/about`にアクセスすると、`pages/about.vue`で定義したコンポーネントが表示されます ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=))。さらに、Nuxtではフォルダを切って`index.vue`を置くことでネストしたルートにも対応できます。例えば`pages/about/index.vue`という構造でも`/about`として認識され、同ディレクトリに`about.vue`と`about/index.vue`の両方が存在する場合は`about.vue`が優先されます ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=%E3%80%8C%2F%E3%80%8D%E3%81%AE%E3%82%88%E3%81%86%E3%81%AB%E3%83%AB%E3%83%BC%E3%83%88%E3%81%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%8C%E3%81%82%E3%81%A3%E3%81%9F%E5%A0%B4%E5%90%88%E3%81%AF%20))。

**動的ルーティング**（パラメータを含むURL）もファイル名で表現できます。たとえばユーザーIDに応じたページ`/users/1`や`/users/2`を扱いたい場合、`pages/users/[id].vue`というファイルを用意します ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=%E3%83%80%E3%82%A4%E3%83%8A%E3%83%9F%E3%83%83%E3%82%AF%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0))。`[ ]`で囲んだ部分が動的パラメータを示し、実行時には`$route.params.id`でその値にアクセスできます（Vue Routerの機能をNuxtがラップして提供） ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=%E3%83%80%E3%82%A4%E3%83%8A%E3%83%9F%E3%83%83%E3%82%AF%E3%83%AB%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0)) ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=%60))。同様に、`pages/users/[id]/likes.vue`のような階層構造にすれば、`/users/1/likes`といったネストした動的ルートも簡単に定義可能です ([〖Nuxt 3〗基本機能をなんとなく理解する #JavaScript - Qiita](https://qiita.com/whopper1962/items/b8bd91a7a5124c0306c8#:~:text=%E3%83%91%E3%83%A9%E3%83%A1%E3%83%BC%E3%82%BF%E5%90%8D%E3%81%AF%E8%87%AA%E7%94%B1%E3%81%AB%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%60%2Fpages%2Fusers%2F))。このようにファイルとフォルダの命名規則に沿って配置するだけで、Nuxtが自動的にルーティング設定を生成してくれるため、開発者は**ルーター設定の記述に煩わされることなく新規ページを追加できる**のです。

Nuxt 3の代表的なディレクトリと役割をまとめると以下のようになります ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60middleware)) ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60public%60%3A%20%E9%9D%99%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%EF%BC%88%E7%94%BB%E5%83%8F%E3%80%81%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%B7%E3%83%BC%E3%83%88%E3%80%81%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88.txt%E3%81%AA%E3%81%A9%EF%BC%89%E3%82%92%E6%A0%BC%E7%B4%8D%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E3%81%AE%E3%83%91%E3%82%B9%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82)):

- **`pages/`**: 前述のとおり、各ページコンポーネントを配置する場所です。ファイル名やフォルダ構造に基づき自動でルートが生成されます。例えば`pages/contact.vue`を置けば`/contact`ページができあがります ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60public%60%3A%20%E9%9D%99%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%EF%BC%88%E7%94%BB%E5%83%8F%E3%80%81%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%B7%E3%83%BC%E3%83%88%E3%80%81%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88.txt%E3%81%AA%E3%81%A9%EF%BC%89%E3%82%92%E6%A0%BC%E7%B4%8D%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E3%81%AE%E3%83%91%E3%82%B9%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。
- **`components/`**: 再利用可能なVueコンポーネント群を置くディレクトリです。Nuxt 3では`components/`配下のコンポーネントを**自動インポート**できるため、`import`文を書くことなくどこからでも利用できます ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60composables%60%3A%20Vue%203%E3%81%AEComposition))。これは大規模開発時にコンポーネントの管理を楽にします。
- **`layouts/`**: アプリケーションの共通レイアウトを定義するディレクトリです。ヘッダーやフッターなど全ページに共通の構造をレイアウトとして記述し、各ページコンポーネントはレイアウト内の `<NuxtPage>` にレンダリングされます。複数のレイアウトを用意すれば、ページごとに異なる枠組みも簡単に適用できます。
- **`plugins/`**: Vueプラグインや外部ライブラリの初期化コードを置く場所です。ここに定義したプラグインはアプリ起動時に自動的に読み込まれ、全コンポーネントで利用可能になります ([Nuxt3のディレクトリ構成 一覧](https://zenn.dev/r0227n/articles/nuxt3_directory_structure_memo#:~:text=,%60public%60%3A%20%E9%9D%99%E7%9A%84%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%EF%BC%88%E7%94%BB%E5%83%8F%E3%80%81%E3%82%B9%E3%82%BF%E3%82%A4%E3%83%AB%E3%82%B7%E3%83%BC%E3%83%88%E3%80%81%E3%83%AD%E3%83%9C%E3%83%83%E3%83%88.txt%E3%81%AA%E3%81%A9%EF%BC%89%E3%82%92%E6%A0%BC%E7%B4%8D%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%82%89%E3%81%AE%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AF%E3%81%9D%E3%81%AE%E3%81%BE%E3%81%BE%E3%81%AE%E3%83%91%E3%82%B9%E3%81%A7%E5%85%AC%E9%96%8B%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82))。たとえばjQuery時代でいうグローバルなプラグイン拡張を、この機構で実現できます。

こうした規約に沿った構成により、Nuxtでは**「決められた場所にファイルを置くだけ」で多くの設定が完了**します。特にページの追加やルート設計が直感的に行える点は、jQueryベースの従来開発（HTMLファイルやサーバサイドテンプレートを都度用意して、手動でリンクを繋ぐ作業）に比べて生産性が高く、プロジェクトの規模が大きくなってもルーティングの全体像を把握しやすいというメリットがあります。

さらにNuxtのルーティングでは、各ページコンポーネントを**必要になるまで遅延ロード（Lazy load）**する仕組みが組み込まれています ([Routing · Get Started with Nuxt](https://nuxt.com/docs/getting-started/routing#:~:text=One%20core%20feature%20of%20Nuxt,JavaScript%20for%20the%20requested%20route))。具体的には、ビルド時に`pages/`配下の各ページが分割された別個のJavaScriptチャンクとして用意され、実行時にはアクセスされたページのコードだけが動的インポートされます ([Routing · Get Started with Nuxt](https://nuxt.com/docs/getting-started/routing#:~:text=One%20core%20feature%20of%20Nuxt,JavaScript%20for%20the%20requested%20route))。これにより、初期ロード時にアプリ全体のコードを読み込まずに済み、ユーザーが使うページに応じて**必要最小限のコード**だけを送信することでパフォーマンスを最適化できます ([Routing · Get Started with Nuxt](https://nuxt.com/docs/getting-started/routing#:~:text=One%20core%20feature%20of%20Nuxt,JavaScript%20for%20the%20requested%20route))。この自動コード分割機能もNuxtを使う大きな利点の一つです。

**業務開発での利点:** Nuxtのディレクトリ構造と自動ルーティングにより、チーム開発での役割分担やプロジェクトのスケーリングが容易になります。新しいページを追加する際も**決まりに従ってファイルを置くだけ**なので、誰が実装しても同じように動作し、レビュー時も構造を理解しやすいでしょう。ページ数が増えてもルーティング設定が肥大化しないため保守性が高く、URL設計の変更もフォルダ名の変更で対応できるなど柔軟です。また、自動コード分割のおかげで、大規模な業務アプリでも不要なコードをユーザーに読み込ませない設計が標準で適用されるため、**パフォーマンスと開発効率の両立**が図れます。

## 2. Vueアプリのテスト

### ユニットテスト（Vitest/Jest）の概要
**ユニットテスト**とは、アプリケーションの最小単位（関数やクラス、コンポーネント内のメソッドなど）が意図したとおりに動作するか検証するテストです。Vueの場合、コンポーネントの内部ロジックや独立したユーティリティ関数などを対象に、「入力に対して期待する出力が得られるか」を確認するイメージになります ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%84%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AA%E5%87%A6%E7%90%86%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AB%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E8%A1%8C%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E6%96%B0%E3%81%97%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%8C%E6%A7%8B%E7%AF%89%E3%81%95%E3%82%8C%E3%81%9F%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8C%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%A6%E3%82%82%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E6%A9%9F%E8%83%BD%E7%9A%84%E3%81%A7%E5%AE%89%E5%AE%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%82%92%E4%BF%9D%E3%81%A4%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20Vue%20%E3%81%A7%E3%81%AF%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%86%85%E3%81%AE%E5%80%8B%E3%80%85%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E3%81%99%E3%82%8B%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%81%A7%E3%81%99%E3%80%82))。ユニットテストを導入しておくと、新機能の追加やリファクタリングを行っても既存機能が破壊されていないことを自動で確認できるため、**アプリケーションの安定性を保つ**上で非常に有効です ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%84%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AA%E5%87%A6%E7%90%86%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AB%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E8%A1%8C%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E6%96%B0%E3%81%97%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%8C%E6%A7%8B%E7%AF%89%E3%81%95%E3%82%8C%E3%81%9F%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8C%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%A6%E3%82%82%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E6%A9%9F%E8%83%BD%E7%9A%84%E3%81%A7%E5%AE%89%E5%AE%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%82%92%E4%BF%9D%E3%81%A4%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20Vue%20%E3%81%A7%E3%81%AF%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%86%85%E3%81%AE%E5%80%8B%E3%80%85%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E3%81%99%E3%82%8B%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%81%A7%E3%81%99%E3%80%82))。これは業務開発において、バグの早期発見やリリース前の品質保証に直結します。

Vueアプリで利用される主なユニットテストフレームワークとしては、**Jest**と**Vitest**があります ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%83%95%E3%83%AC%E3%83%BC%E3%83%A0%E3%83%AF%E3%83%BC%E3%82%AF%E3%81%AF%20,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。Jestは従来から多く使われてきたテストランナーで、豊富な機能と実績があります。一方、**Vitest**はViteベースのプロジェクト向けに開発された新しいテストランナーで、高速な実行とViteとのシームレスな統合が特徴です ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=))。Vue CLIやViteでプロジェクトを作成する際にテスト環境を含めるオプションを選ぶと、標準でJestかVitestが組み込まれます。特に現在のVue3 + Vite環境ではVitestの採用が増えており、Viteの設定や変換パイプラインをそのまま利用できるため設定が簡素で高速にテストが実行できます ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=))。公式ガイドでも「ViteベースのVueプロジェクトではVitestを使うことを推奨」すると明記されています ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=))。

ユニットテストでは、Vueコンポーネントのテストにも**ヘッドレスな実行環境**が用いられます。たとえばVitestやJestは、Node.js上で仮想的なDOM環境（JSDOMやhappy-dom）を用意し、その中でVueコンポーネントをレンダリングしてテストすることが可能です ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=,utils%20%E3%82%92%E4%BD%BF%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%83%86%E3%82%B9%E3%83%88%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82))。これにより、ブラウザを開かずともコンポーネントや関数の挙動を検証できます。例えば以下のような単純な関数はユニットテストで直接検証できます。

```js
// 例: ユニットテスト対象の関数
function add(a, b) {
  return a + b;
}

// テストコード（Jest/Vitest形式）
test('add関数の結果が正しいことを確認', () => {
  expect(add(2, 3)).toBe(5);
  expect(add(-1, 1)).toBe(0);
});
```

上記のテストでは`add`関数にさまざまな入力を与え、`expect`で期待値と比較しています。テストが通れば関数は正しく動作していると言えます。このように**ビジネスロジック部分**（計算処理やデータ変換処理など）をユニットテストで網羅しておくことで、「コードを書き換えたら計算結果が変わってしまった」等の不具合を早期に検出できます ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%82%84%E6%B1%8E%E7%94%A8%E7%9A%84%E3%81%AA%E5%87%A6%E7%90%86%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AB%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E5%8D%98%E4%BD%93%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E8%A1%8C%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%80%81%E6%96%B0%E3%81%97%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%8C%E6%A7%8B%E7%AF%89%E3%81%95%E3%82%8C%E3%81%9F%E3%82%8A%E3%80%81%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8C%E3%83%AA%E3%83%95%E3%82%A1%E3%82%AF%E3%82%BF%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%A6%E3%82%82%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%8C%E6%A9%9F%E8%83%BD%E7%9A%84%E3%81%A7%E5%AE%89%E5%AE%9A%E3%81%97%E3%81%9F%E7%8A%B6%E6%85%8B%E3%82%92%E4%BF%9D%E3%81%A4%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%E3%80%82%20Vue%20%E3%81%A7%E3%81%AF%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E5%86%85%E3%81%AE%E5%80%8B%E3%80%85%E3%81%AE%E3%83%AD%E3%82%B8%E3%83%83%E3%82%AF%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88%E3%82%92%E3%81%99%E3%82%8B%E3%82%A4%E3%83%A1%E3%83%BC%E3%82%B8%E3%81%A7%E3%81%99%E3%80%82))。

Vueコンポーネントにおいても、単純な計算や文字列整形であればコンポーネントから切り出して独立関数としてテストしたり、コンポーネント内部のメソッドを直接呼び出してテストしたりすることもできます。しかしコンポーネントはUI要素を含むため、より現実的には次に述べる**コンポーネントテスト**の手法を用いて、見た目や挙動を含めたテストを行うことになります。

**業務開発での利点:** jQuery中心の開発では、DOM操作が直接的である反面、ロジックと表示が密結合しているため自動テストが難しいケースが多々ありました。Vueにユニットテストを導入することで、例えば**日付フォーマット関数**や**料金計算ロジック**といった部分を確実に検証でき、リグレッション（変更による不具合）のリスクを抑えられます。これは複数人で開発するプロジェクトや長期間メンテナンスするプロダクトにおいて、コードの信頼性と開発効率を向上させる重要な要素です。テストが整備されていればリファクタリングや機能追加のたびに手動で画面をチェックする手間が減り、結果として**開発スピードと品質の両立**が実現できます。

### コンポーネントテスト（Vue Testing Library）に重点を置いた具体例と解説
**コンポーネントテスト**とは、単一のVueコンポーネントが**想定通りのレンダリング結果と振る舞い**を示すか検証するテストです ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%20Component%20%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%BB%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%82%92%E8%A1%8C%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。コンポーネントの入力（Props、ユーザー操作、データの変更など）に対して出力（DOMに描画される内容や発行されるイベント）が正しいかをチェックします。ユニットテストが部品レベルのロジック検証だとすれば、コンポーネントテストはUI部品単位の振る舞い検証と位置付けられます。 ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%20Component%20%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%BB%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%82%92%E8%A1%8C%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))

Vueには公式の低レベルテストユーティリティである**Vue Test Utils**（@vue/test-utils）がありますが、最近ではこれを抽象化し、より**ユーザー視点でテストが書ける**ように設計された**Vue Testing Library**（@testing-library/vue）が推奨されています ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF%20,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。Vue Testing Library（以下VTL）は、React向けのTesting Libraryと同様に「できるだけユーザーと同じ方法でコンポーネントを操作・検証する」ことを理念としており ([testing-library、何が嬉しいのか](https://zenn.dev/p_craft/articles/5edd2456232257#:~:text=testing,%E3%81%A7%E3%81%AE%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81Vue%20Testing%20Library%20%E3%82%92%E3%81%94%E8%A6%A7%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82))、Vue Test Utilsを内部で利用しつつ、テストコード上ではDOM上のテキストや要素を直接扱える便利なAPIを提供しています ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF%20,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。Vueで初めてテストを書く場合、実装の詳細を意識せず直感的に書けるVTLの使用が特におすすめされています ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=,%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%82%92%E3%81%8A%E5%8B%A7%E3%82%81%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。

Vue Testing Libraryを使ったコンポーネントテストの具体例として、簡単な**動作確認コンポーネント**を考えてみましょう。以下の`HelloMessage.vue`コンポーネントはボタンを押すとメッセージを切り替える機能を持っています（jQueryで言えば、ボタンのclickイベントでDOMのテキストを書き換える処理に相当します）。

```vue
<!-- HelloMessage.vue -->
<template>
  <div>
    <p>{{ message }}</p>
    <button @click="updateMessage">挨拶</button>
  </div>
</template>

<script setup>
import { ref } from 'vue';
const message = ref('Vueアプリへようこそ');
const updateMessage = () => {
  message.value = 'こんにちは、Vue!';
};
</script>
```

初期状態では`<p>`タグに「Vueアプリへようこそ」と表示され、ボタン（「挨拶」ラベル）をクリックすると`message`が更新され「こんにちは、Vue!」に変わるシンプルなコンポーネントです。これに対するテストコードを、Vue Testing Libraryを用いて書いてみます。

```js
// HelloMessage.spec.js
import { render, fireEvent, screen } from '@testing-library/vue';
import HelloMessage from './HelloMessage.vue';

test('ボタンをクリックするとメッセージが更新される', async () => {
  // コンポーネントをレンダリングして仮想DOMに配置
  render(HelloMessage);
  // 初期メッセージが表示されていることを確認
  expect(screen.getByText('Vueアプリへようこそ')).toBeInTheDocument();
  // ボタンをクリック
  const button = screen.getByText('挨拶');
  await fireEvent.click(button);
  // メッセージが更新されたことを確認
  expect(screen.getByText('こんにちは、Vue!')).toBeInTheDocument();
});
```

上記のテストでは、まず`render(HelloMessage)`で対象コンポーネントを描画し、仮想的なDOMに挿入します。次に`screen.getByText('Vueアプリへようこそ')`で現在表示されているテキスト要素を取得し、`toBeInTheDocument()`アサーションによってそれがDOM上に存在する（つまり正しく表示されている）ことを確認しています。続いて、同じく`getByText('挨拶')`で「挨拶」と書かれたボタン要素を取得し、`fireEvent.click(button)`でクリックのユーザー操作をシミュレートします。その後、`screen.getByText('こんにちは、Vue!')`でクリックによって表示されるはずの新しいテキストを取得し、存在確認を行っています。この一連の流れにより、「初期状態では特定のメッセージが表示され、ボタンクリック後にメッセージが期待通り変化する」というコンポーネントの仕様をテストで保証できます。

実際の業務開発でも、上記のようなテストを書くことでコンポーネントの振る舞いを**ドキュメント化**かつ**自動検証**できます。例えば後続の開発者が誤ってボタンのテキストを変更したり挙動を変えたりした場合でも、このテストが失敗することで意図しない改変に気付き、バグの混入を防げます。

Vue Testing Libraryを使うメリットは、**ユーザー目線に近い記述**ができる点です。従来のVue Test Utilsだけを用いた場合、特定の要素を探すのに`wrapper.findAll('button')`でボタン要素を全て取得し、その中からテキストを比較して目的のボタンを見つける、といった処理が必要でした ([testing-library、何が嬉しいのか](https://zenn.dev/p_craft/articles/5edd2456232257#:~:text=Vue%20Test%20Utils%20%E3%81%A7%E3%81%AF%E3%80%81%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%A9%E3%83%99%E3%83%AB%E3%82%84%E6%96%87%E5%AD%97%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E8%A6%81%E7%B4%A0%E3%82%92%E7%9B%B4%E6%8E%A5%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82%20%E3%81%9D%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81,%E3%81%A7%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E5%8F%96%E5%BE%97%E3%81%97%E3%80%81%E3%81%9D%E3%81%AE%E4%B8%AD%E3%81%8B%E3%82%89%E3%80%8C%E4%BF%9D%E5%AD%98%E3%80%8D%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E6%8E%A2%E3%81%99%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。あるいはテンプレートに`data-test="save-button"`のようなカスタム属性を埋め込み、それをキーに検索する方法も取られます。しかしそれらは「画面上のテキストやラベルでボタンを探す実際のユーザーの動き」とはかけ離れており、テストの記述が冗長になったり、data属性の書き漏らし・変更によってテストが壊れるリスクもあります ([testing-library、何が嬉しいのか](https://zenn.dev/p_craft/articles/5edd2456232257#:~:text=Vue%20Test%20Utils%20%E3%81%A7%E3%81%AF%E3%80%81%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%81%A6%E3%81%84%E3%82%8B%E3%83%A9%E3%83%99%E3%83%AB%E3%82%84%E6%96%87%E5%AD%97%E3%81%AB%E5%9F%BA%E3%81%A5%E3%81%84%E3%81%A6%E8%A6%81%E7%B4%A0%E3%82%92%E7%9B%B4%E6%8E%A5%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82%20%E3%81%9D%E3%81%AE%E3%81%9F%E3%82%81%E3%80%81,%E3%81%A7%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E5%8F%96%E5%BE%97%E3%81%97%E3%80%81%E3%81%9D%E3%81%AE%E4%B8%AD%E3%81%8B%E3%82%89%E3%80%8C%E4%BF%9D%E5%AD%98%E3%80%8D%E3%83%9C%E3%82%BF%E3%83%B3%E3%82%92%E6%8E%A2%E3%81%99%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82)) ([testing-library、何が嬉しいのか](https://zenn.dev/p_craft/articles/5edd2456232257#:~:text=%E7%9B%B4%E6%8E%A5%E5%8F%96%E5%BE%97%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%20%60data))。これに対しTesting Library系では、**画面に見えるテキストや役割（role）で要素を直接取得できます**。上の例ではボタンそのものにユニークなIDが無くても「挨拶」というラベルテキストで取得できており、まさにユーザーが「あの『挨拶』ボタンをクリックする」という操作をなぞらえたテストになっています。

また、テストすべきはコンポーネントの「表現（アウトプット）」であり内部実装ではない、という指針もTesting Libraryでは重視されています ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=))。例えばコンポーネントの内部状態（dataやComposableの値）を直接参照してその値をアサートするようなテストは避け、あくまでDOMに期待される変化が起きたかどうかで判断します ([テスト | Vue.js](https://ja.vuejs.org/guide/scaling-up/testing#:~:text=))。この方針に沿うことで、テストがコンポーネントの実装詳細に依存せず**リファクタリングに強い**ものとなります。仮に内部的な実装を変更しても、外部から見た挙動が変わらなければテストは通過し続け、挙動に差異があればテストが失敗して検知できる、というわけです。

**業務開発での利点:** Vue Testing Libraryを用いたコンポーネントテストにより、UIの品質を高めることができます。例えばフォームコンポーネントのバリデーション動作（必須項目を空で送信ボタンを押したらエラーメッセージが表示される等）をテストしておけば、将来の変更でバリデーションが機能しなくなってしまった場合でもすぐに検出できます。jQuery開発では人手による画面確認に頼っていた部分も、自動テストが担ってくれるため、リリース前のテスト工数削減やバグの早期発見につながります。また、テストコードはある意味**生きたドキュメント**でもあります。新しく参加したチームメンバーがテストコードを読めば、各コンポーネントがどういう入力に対しどんな振る舞いをするか理解でき、仕様把握に役立ちます。総じて、Vueのテストを導入することは、プロジェクトの**保守性・信頼性を大幅に向上**させ、安心して機能追加できる土台を築くことにつながります。

## 3. パフォーマンス最適化

### Lazy loading（遅延読み込み）の仕組みと使いどころ
**Lazy loading（レイジーローディング）**とは、必要になるまでリソースの読み込みを遅らせる手法です。画面表示直後には必ずしも全てのコードや画像を読み込む必要はない場合が多く、後から使うものは後から読み込むことで初期ロードを軽くすることができます。Vueアプリケーションでも、この考え方を適用して**コード分割**を行い、初期表示に不要な機能は後からロードするように構成するのが一般的です ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AF%E3%80%81%E6%9C%80%E5%88%9D%E3%81%AE%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%AD%E3%83%BC%E3%83%89%E5%BE%8C%E3%81%99%E3%81%90%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%A7%E6%9C%80%E3%82%82%E3%82%88%E3%81%8F%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%81%93%E3%82%8C%E3%81%AF%20Vue%20%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E6%A9%9F%E8%83%BD%E3%81%A8%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%80%81%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%84%E3%83%AA%E3%83%BC%E3%81%AE%E5%88%86%E5%89%B2%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%3A))。

具体的には、Vueの**非同期コンポーネント**機能やビルドツール（Vite/Webpack）の**動的インポート**を活用して、コンポーネント単位で別ファイル（チャンク）に分割します ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AF%E3%80%81%E6%9C%80%E5%88%9D%E3%81%AE%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%AD%E3%83%BC%E3%83%89%E5%BE%8C%E3%81%99%E3%81%90%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%A7%E6%9C%80%E3%82%82%E3%82%88%E3%81%8F%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%81%93%E3%82%8C%E3%81%AF%20Vue%20%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E6%A9%9F%E8%83%BD%E3%81%A8%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%80%81%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%84%E3%83%AA%E3%83%BC%E3%81%AE%E5%88%86%E5%89%B2%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%3A))。こうしておけば、対応するコンポーネントが実際に必要になるまでそのチャンクは読み込まれません。たとえばVue Routerを使用しているアプリでは、各ルートコンポーネントを遅延ロードすることが強く推奨されています ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=Vue%20Router%20%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%BC%B7%E3%81%8F%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20Router%20%E3%81%AF%E3%80%81,%E3%81%A8%E3%81%AF%E5%88%A5%E3%81%AB%E3%80%81%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E8%A9%B3%E3%81%97%E3%81%8F%E3%81%AF%20Lazy%20Loading%20Routes%20%E3%82%92%E5%8F%82%E7%85%A7%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82))。ルート定義時にコンポーネントを直接インポートするのではなく、`() => import('...')`という関数で指定することで、該当ページにナビゲーションした時点で初めてそのコンポーネントコードが読み込まれます。公式ガイドでもVue Routerと組み合わせた遅延ロード方法（**Lazy Loading Routes**）が解説されており、これによって「最初のページロード時に全画面のコードを読み込まない」設計が容易に実現できます ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=Vue%20Router%20%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%BC%B7%E3%81%8F%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20Router%20%E3%81%AF%E3%80%81,%E3%81%A8%E3%81%AF%E5%88%A5%E3%81%AB%E3%80%81%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E8%A9%B3%E3%81%97%E3%81%8F%E3%81%AF%20Lazy%20Loading%20Routes%20%E3%82%92%E5%8F%82%E7%85%A7%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82))。

**例:** 例えばユーザーがログイン後にしかアクセスしない「設定ページ」や「管理者用ダッシュボード」などがあるとします。こういった機能は一般利用者の初期表示には不要なので、遅延読み込みを使っておけばユーザーがそのページを開いた時にだけコードを読み込めば十分です。Vue Routerでの実装例は以下のようになります。

```js
// 遅延読み込みを用いたルート定義例
const routes = [
  { path: '/', component: () => import('@/pages/Home.vue') },           // ホーム（即時読み込み）
  { path: '/settings', component: () => import('@/pages/Settings.vue') } // 設定（遅延読み込み）
];
```

上記では`/settings`ルートに対応するコンポーネントを動的インポートしています。ビルド時に`Settings.vue`は別ファイルに分割されるため、ユーザーが`/settings`ページに移動しない限りそのコードはダウンロードされません。これにより**初回ロードのバンドルサイズ削減**と**ナビゲーション時の高速化**が図れます。

同様に、大きな**画像**や**動画**についてもスクロールして見えるまで読み込まない遅延ロード手法が取られることがあります。Vue自体の機能ではありませんが、ブラウザのネイティブ機能（例えば`<img loading="lazy">`属性）やVue向けのプラグイン（`vue-lazyload`等）を使えば、長い一覧ページで下のほうにある画像を遅延表示してパフォーマンスを高めることができます。重要なのは「ユーザーに今必要なものだけを先に読み込み、そうでないものは後回しにする」という発想で、これによって**ユーザー体感速度の向上**と**無駄なリソース消費の削減**が可能になります。

**適用すべき場面:** 遅延読み込みが特に効果を発揮するのは、**初期表示時に使わない可能性がある大きなリソース**です ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%81%AF%E3%80%81%E6%9C%80%E5%88%9D%E3%81%AE%E3%83%9A%E3%83%BC%E3%82%B8%E3%83%AD%E3%83%BC%E3%83%89%E5%BE%8C%E3%81%99%E3%81%90%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84%E6%A9%9F%E8%83%BD%E3%81%A7%E6%9C%80%E3%82%82%E3%82%88%E3%81%8F%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%81%93%E3%82%8C%E3%81%AF%20Vue%20%E3%81%AE%E9%9D%9E%E5%90%8C%E6%9C%9F%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E6%A9%9F%E8%83%BD%E3%81%A8%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E3%80%81%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%84%E3%83%AA%E3%83%BC%E3%81%AE%E5%88%86%E5%89%B2%E3%83%81%E3%83%A3%E3%83%B3%E3%82%AF%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%A7%E3%81%8D%E3%81%BE%E3%81%99%3A))。典型例としては以下があります:

- **ルートページが複数あるSPA**: ユーザーが訪れないページのコードまで最初に読み込むのは非効率なので、各ページコンポーネントを分割し遅延ロードする（Nuxtはこれを自動で行ってくれます）。
- **モーダルダイアログやタブ**: アプリ内でボタンを押したときに開く詳細情報ダイアログや、タブ切り替えで表示するサブ機能などは、事前には読み込まず実際に表示するときにロードする。Vueでは`defineAsyncComponent`でコンポーネントをラップすることで実装できます。
- **重量のあるライブラリ**: 例えば地図表示用のライブラリやグラフ描画ライブラリなど、読み込むと数百KBを超えるような外部ライブラリも、必要なページでのみimportするか、コンポーネントごと遅延ロードして初期バンドルから外す戦略が有効です。

以上のようにLazy loadingは**初期表示を高速化しつつ、必要な機能は後から問題なく提供する**ためのテクニックです。現状の業務で致命的なパフォーマンス問題がなくても、アプリが肥大化してきたときにこの知識があると適切な箇所に導入してボトルネックを解消できるでしょう。Vueでは公式に「Vue Routerを使うアプリではルートコンポーネントの遅延ロードを強く推奨」 ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=Vue%20Router%20%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%BC%B7%E3%81%8F%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20Router%20%E3%81%AF%E3%80%81,%E3%81%A8%E3%81%AF%E5%88%A5%E3%81%AB%E3%80%81%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E8%A9%B3%E3%81%97%E3%81%8F%E3%81%AF%20Lazy%20Loading%20Routes%20%E3%82%92%E5%8F%82%E7%85%A7%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82))と述べられているように、比較的低コストで導入できる最適化なので、積極的に活用したいところです。

### Virtual DOMと再レンダリング最適化の基本概念とVueでの活用法
Vueを含むモダンなフロントエンドフレームワークは、内部に**Virtual DOM（仮想DOM）**という仕組みを持っています。仮想DOMとは実際のDOMをJavaScriptのオブジェクトで軽量に表現し直したもので、UIの状態をメモリ上で管理するためのものです ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=2))。Vueの場合、コンポーネントのデータが変化すると新しい仮想DOMツリーが再生成され、直前に保持していた古い仮想DOMと**差分比較（diff）**を行います ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=3))。この差分計算によって「どの部分が変化したか」が特定できるため、最後に実行する実際のDOM更新は**変更があった部分に限って**行われます ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=%EF%BC%882%EF%BC%89%E3%81%A7%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%81%9F%E6%96%B0%E3%81%97%E3%81%84%E4%BB%AE%E6%83%B3DOM%E3%81%A8%E3%80%81%E3%81%9D%E3%81%AE%E5%89%8D%E3%81%AB%E7%94%9F%E6%88%90%E3%81%95%E3%82%8C%E3%81%9F%E4%BB%AE%E6%83%B3DOM%E3%82%92%E6%AF%94%E8%BC%83%E3%81%97%E3%81%A6%E3%80%81%E3%81%A9%E3%81%AE%E9%83%A8%E5%88%86%E3%81%8C%E5%A4%89%E6%9B%B4%E3%81%95%E3%82%8C%E3%81%9F%E3%81%8B%E3%82%92%E8%A8%88%E7%AE%97%E3%81%97%E3%81%BE%E3%81%99%E3%80%82))。言い換えれば、**再レンダリング＝全てが描画し直される**わけではなく、Vueが変更点だけを効率よく更新してくれるのです。

このVirtual DOM + Diffアルゴリズムにより、開発者は細かいDOM操作の最適化を意識しなくても、Vueが多くのケースで**高い描画パフォーマンス**を発揮するよう設計されています ([Vueを学ぶ - Zenn](https://zenn.dev/jy8752/scraps/940af319bee703#:~:text=Vue%E3%82%92%E5%AD%A6%E3%81%B6%20,memo%2C%20%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF))。例えばjQueryでは、小さなテキスト更新であってもプログラマが明示的に`$("#elem").text("新しいテキスト")`と指定し、そのたびにブラウザは対象要素を書き換えてレイアウトを再計算する、といった処理が発生していました。Vueではデータを更新するだけで（`this.message = "新しいテキスト"`のように）仮想DOM上の変更として蓄積され、フレームワークが適切なタイミングでDOMをまとめて更新します。このため、複数の変更も一括反映されたり、変化がない部分は全く触らなかったりと、自動的に無駄を省いてくれます。

再レンダリングの最適化について、Vueは**デフォルトで多くの最適化**を行っています。具体的にはテンプレートコンパイル時に**静的な部分を見極めてキャッシュ**したり、不変な要素には毎回触れないようにする仕組みがあります ([レンダリングの仕組み - Vue.js](https://ja.vuejs.org/guide/extras/rendering-mechanism#:~:text=%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AE%E4%BB%95%E7%B5%84%E3%81%BF%20,DOM%20%E3%81%AE%E5%AE%9F%E8%A1%8C%E6%99%82%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%82%92%E5%90%91%E4%B8%8A%E3%81%95%E3%81%9B%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AB%E8%A1%8C%E3%81%A3%E3%81%9F%E3%80%81%E4%B8%BB%E8%A6%81%E3%81%AA%E6%9C%80%E9%81%A9%E5%8C%96%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6%E3%81%84%E3%81%8F%E3%81%A4%E3%81%8B%E8%A7%A3%E8%AA%AC%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20%E9%9D%99%E7%9A%84%E3%81%AA%E9%83%A8%E5%88%86%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5))。そのため開発者は通常、特別な対策をしなくとも十分な速度が得られます ([Vueを学ぶ - Zenn](https://zenn.dev/jy8752/scraps/940af319bee703#:~:text=Vue%E3%82%92%E5%AD%A6%E3%81%B6%20,memo%2C%20%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF))。しかしながら、アプリケーション規模が大きくなったり特殊なケースでは追加の工夫が役立つこともあります。Vueで再レンダリングを最適化・制御する代表的なテクニックをいくつか紹介します。

- **コンポーネント分割:** 大きなコンポーネントより、小さく責務が明確なコンポーネントに分割した方が、変更の影響範囲を局所化できます。変更が発生した際に再レンダリングが必要な範囲（仮想DOMツリーの部分）が小さくなるため、結果として更新処理も高速化しやすくなります。Vueでは親から子へのデータ伝搬をpropsで制御できるので、どの部分が更新されるかを見通しながら設計できます。
- **`v-once`ディレクティブ:**  一度描画したら以後は更新しない静的なコンテンツには、`v-once`を適用することで再レンダリングをスキップできます。適用した要素やその子要素は初回のみ描画し、以降のデータ変更では更新されなくなります ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=%3Ctemplate%3E%20%3Ch1%20v,template))。例えば大量のアイコンや装飾要素など、初期表示後は変わらない部分に使うと無駄なdiff計算やDOM操作を省けます。
- **`computed`や`watch`の活用:** Vueの**算出プロパティ（computed）**は、依存するデータが変わった時だけ再計算し、そうでなければキャッシュを返す仕組みがあります。頻繁に実行される重い計算をテンプレート内で直接書くより、computedにしておけば無駄な再計算を防げます。**ウォッチャ（watch）**も、データ変化に応じて副作用処理を最適なタイミングで行うのに役立ちます。これらを適切に使うことで、レンダリングサイクル毎に不必要な処理が走らないようにできます。
- **Vue 3の`v-memo`:** Vue 3.2から導入された`v-memo`ディレクティブは、指定した式の結果が前回と同じ場合、その要素の再レンダリングをスキップできる機能です。複雑なリストレンダリングなどで「特定の計算結果が以前と変わらない場合は同じ仮想DOMを再利用する」といった高度な最適化が可能になります ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=%E3%80%8Cv)) ([〖Vue / パフォーマンス最適化〗「v-once」「v-memo」を使って再レンダリングを制御 #JavaScript - Qiita](https://qiita.com/whopper1962/items/64672a3615ee6ca68298#:~:text=DOM%E3%81%AF%E3%83%84%E3%83%AA%E3%83%BC%E7%8A%B6%E3%81%A7%E5%BD%A2%E6%88%90%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82%E8%A6%AA%E3%81%AB%E3%81%82%E3%81%9F%E3%82%8B%E8%A6%81%E7%B4%A0%E3%81%8C%E5%86%8D%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%9F%E5%A0%B4%E5%90%88%E3%80%81%E3%81%9D%E3%81%AE%E5%AD%90%E8%A6%81%E7%B4%A0%E3%82%82%E4%B8%80%E7%B7%92%E3%81%AB%E5%86%8D%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%95%E3%82%8C%E3%81%A6%E3%81%97%E3%81%BE%E3%81%84%E3%81%BE%E3%81%99%E3%80%82))（ただし通常は使う機会は多くありません）。

以上のような手段でVueの再レンダリングを微調整できますが、強調したいのは**「必要になったときに初めて適用すれば良い」**という点です。先述のとおりVue自体が一般的なケースでは高性能に動作するよう設計されているため、闇雲に最適化のためのコードを書き込むより、まずはシンプルに実装し、パフォーマンス上問題が出てきた箇所に絞って上記のような対策を講じるのが望ましいです ([Vueを学ぶ - Zenn](https://zenn.dev/jy8752/scraps/940af319bee703#:~:text=Vue%E3%82%92%E5%AD%A6%E3%81%B6%20,memo%2C%20%E9%81%85%E5%BB%B6%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF))。たとえば「この一覧描画は重いな」と感じたときに`v-once`で静的要素を固定する、明らかに無駄な再計算が起きている箇所にcomputedを導入する、などです。

**業務開発での利点:** jQueryによるDOM操作では、開発者自身が「どのタイミングでどの要素を更新するか」を制御していました。一方VueではVirtual DOMと再レンダリング最適化機構により、そうした制御の多くをフレームワークに任せられます。これにより**実装のシンプルさとパフォーマンスの両立**が可能になっています。例えば、複数箇所のテキストを一度に書き換えるような処理も、Vueなら単にデータを更新するだけで最終的に画面が正しく更新され、高速化も自動的に担保されます。開発者はビジネスロジックの実現に注力でき、結果として開発効率も向上します。ただし、性能要件が厳しいアプリ（大量のデータを扱うダッシュボードなど）では、上述のようなテクニックを駆使してフレームワークの挙動をより深く理解し、問題箇所を的確に最適化することが求められるでしょう。その際にもVirtual DOMの仕組みを知っておくことは不可欠であり、Vueの挙動を把握することで無用な最適化と必要な最適化を見極められるようになります。

### コンポーネントキャッシング（<keep-alive>）の用途と業務での実例
Vueには**<keep-alive>**という組み込みコンポーネントがあり、これを使うと動的に切り替わるコンポーネントを**キャッシュ（インスタンスの保持）**することができます ([KeepAlive | Vue.js](https://ja.vuejs.org/guide/built-ins/keep-alive#:~:text=))。通常、あるコンポーネントから別のコンポーネントに切り替えると、前のコンポーネントは破棄され必要に応じてまた生成し直されます。しかし <keep-alive> で囲まれたコンポーネントは非表示になってもインスタンスが破棄されずメモリ上に保持されるため、再度表示する際に**初回の状態が復元**され、再レンダリングや再初期化のコストが発生しません ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%23%20keep))。

主な利点は**不要な再レンダリングの防止**と**状態の保持**です ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=keep))。再レンダリングを行わないことでパフォーマンスが向上し、かつユーザーが入力した値やスクロール位置などの状態が保持されるためUXの向上にもつながります ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=Vue%20%E3%81%AE%20%60keep,%E3%81%A7%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E3%81%A8%E3%81%8D%20%E3%82%84%20%E3%82%BF%E3%83%96%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%20UI%20%E3%81%A7%E6%9C%89%E5%8A%B9%E3%81%A7%E3%81%99%E3%80%82))。特に**ページ遷移やタブ切り替え**のシナリオで威力を発揮します ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=Vue%20%E3%81%AE%20%60keep,%E3%81%A7%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E3%81%A8%E3%81%8D%20%E3%82%84%20%E3%82%BF%E3%83%96%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%20UI%20%E3%81%A7%E6%9C%89%E5%8A%B9%E3%81%A7%E3%81%99%E3%80%82)) ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%23%20keep))。

- **SPAにおけるページ切り替え:**  `<router-view>`（ビューコンポーネントが切り替わる場所）を `<keep-alive>` でラップすると、あるページから別ページに遷移した際に前ページのコンポーネントインスタンスが破棄されず残ります ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%E9%80%9A%E5%B8%B8%E3%80%81%60%3Crouter,%E3%81%A7%E5%9B%B2%E3%82%80%E3%81%A8%E3%80%81%E4%B8%80%E5%BA%A6%E8%A1%A8%E7%A4%BA%E3%81%97%E3%81%9F%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AF%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AB%E4%BF%9D%E6%8C%81%E3%81%95%E3%82%8C%E3%80%81%E5%86%8D%E6%8F%8F%E7%94%BB%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。ユーザーがブラウザの「戻る」で前のページに戻ったり、アプリ内リンクで再度そのページに来たりしたとき、以前の状態（フォームの入力値、スクロール位置、取得済みデータなど）がそのまま復元されます ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=Vue%20%E3%81%AE%20%60keep,%E3%81%A7%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E3%81%A8%E3%81%8D%20%E3%82%84%20%E3%82%BF%E3%83%96%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%20UI%20%E3%81%A7%E6%9C%89%E5%8A%B9%E3%81%A7%E3%81%99%E3%80%82))。例えば検索一覧ページ→詳細ページ→検索一覧ページと移動するようなケースで、一覧ページをkeep-aliveしておけばユーザーは毎回検索結果を再取得したりスクロール位置を探したりせずに済みます。結果としてページ復帰が瞬時に行われ、操作感が良くなります。
- **タブUIの切り替え:** 単一ページ内で複数のタブ（コンポーネント）を切り替えるUIでも、keep-aliveが有効です。タブを切り替えるたびに非表示になったタブの中身が破棄されるのではなく、バックグラウンドで保持されるため、再度そのタブに戻ったとき即座に前回の状態が表示されます ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%23%20keep)) ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%3Ckeep,div))。例えば入力フォームが3つのタブに分かれている画面で、別タブに移動しても元のタブの入力内容がそのまま残っている、といった体験を簡単に実現できます。

実装方法はシンプルで、テンプレートで動的コンポーネントやrouter-viewを<keep-alive>タグで囲むだけです ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%E9%80%9A%E5%B8%B8%E3%80%81%60%3Crouter,%E3%81%A7%E5%9B%B2%E3%82%80%E3%81%A8%E3%80%81%E4%B8%80%E5%BA%A6%E8%A1%A8%E7%A4%BA%E3%81%97%E3%81%9F%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AF%E3%83%A1%E3%83%A2%E3%83%AA%E3%81%AB%E4%BF%9D%E6%8C%81%E3%81%95%E3%82%8C%E3%80%81%E5%86%8D%E6%8F%8F%E7%94%BB%E3%81%95%E3%82%8C%E3%81%AA%E3%81%8F%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。デフォルトではkeep-alive配下の全コンポーネントがキャッシュされますが、属性で細かく制御することもできます ([〖Vue.js〗インスタンスキャッシュ(keep-alive)の使用方法 - freamap ブログ](https://blog.freamap.co.jp/vue-keep-alive/#:~:text=))。たとえば`include`にキャッシュ対象とするコンポーネント名のパターンを指定したり、`exclude`で除外したり、`max`で最大キャッシュ数を制限することも可能です ([〖Vue.js〗インスタンスキャッシュ(keep-alive)の使用方法 - freamap ブログ](https://blog.freamap.co.jp/vue-keep-alive/#:~:text=)) ([〖Vue.js〗インスタンスキャッシュ(keep-alive)の使用方法 - freamap ブログ](https://blog.freamap.co.jp/vue-keep-alive/#:~:text=))。キャッシュが有効なコンポーネントは、初回表示時のみ`mounted`フックが呼ばれ、2回目以降の表示では代わりに`activated`フックが呼ばれます（非表示になると`deactivated`フック） ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=match%20at%20L170%20%E9%80%9A%E5%B8%B8%E3%80%81%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AF%20%E8%A1%A8%E7%A4%BA%E3%81%95%E3%82%8C%E3%82%8B%E3%81%9F%E3%81%B3%E3%81%AB,%E3%83%95%E3%83%83%E3%82%AF%E3%82%92%E4%BD%BF%E3%81%86%E5%BF%85%E8%A6%81%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82))。この点に注意すれば、表示のたびにデータを再取得したい場合などもこれらのフック内で処理を書くことで対応可能です。

**業務での実例:** フォーム入力や検索一覧を保持したいケースは業務アプリでよくあります。例えば**複数ステップの入力フォーム**では、ユーザーが途中で別の設定画面に移って戻ってきても、先ほど入力した内容が残っている方が親切です。keep-aliveを利用すれば、フォームコンポーネントをキャッシュして状態を保持できるため、ユーザーが入力をやり直す必要がありません ([〖Vue.js〗インスタンスキャッシュ(keep-alive)の使用方法 - freamap ブログ](https://blog.freamap.co.jp/vue-keep-alive/#:~:text=%E3%82%A4%E3%83%B3%E3%82%B9%E3%82%BF%E3%83%B3%E3%82%B9%E3%81%AE%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5%28keep))。また**検索システム**において、検索結果一覧から詳細画面に遷移し、再び一覧に戻った際に結果を再ロードするとユーザーの手間やサーバー負荷が増えます。一覧コンポーネントをkeep-aliveしておけば、戻った時に以前の検索結果やページネーションの位置がそのまま表示され、スムーズな戻る操作を提供できます ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%23%20keep))。

現場で筆者が経験した例では、社内向けの在庫管理システムで商品一覧と詳細の画面をSPAで実装していました。初期はkeep-aliveを使っておらず、一覧→詳細→一覧と戻るたびにAPIから全商品データを再取得していたため、頻繁に操作するユーザーから「戻るたびにリストの先頭に戻ってしまい不便」という指摘を受けました。そこで一覧表示部分を<keep-alive>で囲み、詳細ページから戻った際は前回のスクロール位置・フィルタ条件・選択ページが保持されるように改修したところ、一覧への復帰が体感できるほど速くなり、ユーザーのストレスも解消されました。加えて不要なAPIコールが減ったことでサーバー負荷も下がり、一石二鳥でした。

このように<keep-alive>は**パフォーマンス最適化**と**ユーザビリティ向上**の両面で役立つ機能です。ただし使いどころには注意が必要です。無闇にキャッシュを増やしすぎるとメモリ消費が増大する恐れがありますし、常に最新のデータ表示が求められるコンポーネント（例: リアルタイムな通知一覧など）をキャッシュしてしまうと情報が古いままになることもあります。そのため、「頻繁に行き来する画面」で「戻ったとき前の状態が残っていて欲しい」ケースに絞って活用すると良いでしょう ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=%23%20keep))。典型的には前述のタブUIやマルチページフォーム、マスタ詳細画面の組み合わせなどが該当します。適切に利用すれば、ユーザーにとって快適で業務効率の上がる操作性を提供できるでしょう。

## まとめ

以上、Vue学習ステップ4の各テーマ（SSR/SSG入門、テスト手法、パフォーマンス最適化）について、jQuery開発経験者にも分かりやすいようポイントを整理しました。**SSR/SSG**ではNuxt 3を用いることで初期表示が高速化でき、現代のWeb開発において重要なユーザー体験とSEOに貢献することを説明しました。**テスト**ではユニットテストとコンポーネントテストの考え方を紹介し、Vue Testing Libraryによる実践的なテストコード例を示しました。これによりVueアプリの堅牢性を高め、業務開発での安心感と効率向上につながる点を強調しました。**パフォーマンス最適化**ではLazy loadingやVirtual DOMの仕組みに触れ、さらに<keep-alive>によるコンポーネントキャッシュの活用で現場の具体的なメリットを取り上げました。

jQueryからVueへと技術スタックが変わる中で、戸惑う部分もあるかもしれません。しかしVueは**宣言的なUI記述**や**リアクティブシステム**、**豊富なエコシステム**によって、jQueryでは手間がかかった課題をシンプルに解決できるよう設計されています。今回解説した内容は応用的なトピックでしたが、それぞれ**業務に直結する利点**があります。Nuxtによる高速表示はユーザー満足度と成果に貢献し、テストの導入はプロジェクトの信頼性を高め、パフォーマンス最適化の知見は将来的な課題にも対処できる引き出しとなります。Vueの特徴と利点を正しく理解し活用することで、より良いプロダクト開発へと役立てていただければ幸いです。

**参考資料:** 本レポートでは公式ドキュメント ([サーバーサイドレンダリング（SSR） | Vue.js](https://ja.vuejs.org/guide/scaling-up/ssr#:~:text=%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%20SSR%20%E3%82%92%E7%94%A8%E3%81%84%E3%82%8B%E5%89%8D%E3%81%AB%E3%80%81%E3%81%BE%E3%81%9A%E5%95%8F%E3%81%86%E3%81%B9%E3%81%8D%E8%B3%AA%E5%95%8F%E3%81%AF%E3%80%81%E3%81%9D%E3%82%8C%E3%81%8C%E6%9C%AC%E5%BD%93%E3%81%AB%E5%BF%85%E8%A6%81%E3%81%8B%E3%81%A9%E3%81%86%E3%81%8B%E3%81%A8%E3%81%84%E3%81%86%E3%81%93%E3%81%A8%E3%81%A7%E3%81%99%E3%80%82%E3%81%93%E3%82%8C%E3%81%AF%E3%80%81%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AB%E3%81%A8%E3%81%A3%E3%81%A6%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E3%81%A9%E3%82%8C%E3%81%A0%20%E3%81%91%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%81%8B%E6%AC%A1%E7%AC%AC%E3%81%A7%E3%81%99%E3%80%82%E4%BE%8B%E3%81%88%E3%81%B0%E3%80%81%E7%A4%BE%E5%86%85%E5%90%91%E3%81%91%E3%81%AE%E3%83%80%E3%83%83%E3%82%B7%E3%83%A5%E3%83%9C%E3%83%BC%E3%83%89%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%81%A6%E3%81%84%E3%81%A6%E3%80%81%E6%95%B0%E7%99%BE%E3%83%9F%E3%83%AA%E7%A7%92%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%81%8C%E3%81%82%E3%81%A3%E3%81%A6%E3%82%82%E3%81%9D%E3%82%8C%E3%81%BB%E3%81%A9%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%AF%E3%81%AA%E3%81%84%E5%A0%B4%E5%90%88%E3%80%81SSR%20%E3%81%AF%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%AA%E3%83%B3%E3%82%B0%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82%E3%81%A7%E3%81%99%E3%81%8C%E3%80%81%E3%82%B3%E3%83%B3%E3%83%86%E3%83%B3%E3%83%84%E8%A1%A8%E7%A4%BA%E9%80%9F%E5%BA%A6%E3%81%8C%E7%B5%B6%E5%AF%BE%E7%9A%84%E3%81%AB%E9%87%8D%E8%A6%81%E3%81%A7%E3%81%82%E3%82%8B%E3%82%B1%E3%83%BC%E3%82%B9%E3%81%AB%E3%81%8A%E3%81%84%E3%81%A6%E3%81%AF%E3%80%81SSR,%E3%81%AF%E6%9C%80%E5%A4%A7%E9%99%90%E3%81%AE%E5%88%9D%E6%9C%9F%E3%83%AD%E3%83%BC%E3%83%89%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%81%AE%E9%81%94%E6%88%90%E3%81%AB%E5%BD%B9%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82)) ([パフォーマンス | Vue.js](https://ja.vuejs.org/guide/best-practices/performance#:~:text=Vue%20Router%20%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%A7%E3%81%AF%E3%80%81%E3%83%AB%E3%83%BC%E3%83%88%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%81%AB%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E4%BD%BF%E7%94%A8%E3%81%99%E3%82%8B%E3%81%93%E3%81%A8%E3%81%8C%E5%BC%B7%E3%81%8F%E6%8E%A8%E5%A5%A8%E3%81%95%E3%82%8C%E3%81%BE%E3%81%99%E3%80%82Vue%20Router%20%E3%81%AF%E3%80%81,%E3%81%A8%E3%81%AF%E5%88%A5%E3%81%AB%E3%80%81%E9%81%85%E5%BB%B6%E3%83%AD%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E6%98%8E%E7%A4%BA%E7%9A%84%E3%81%AB%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E3%81%97%E3%81%A6%E3%81%84%E3%81%BE%E3%81%99%E3%80%82%E8%A9%B3%E3%81%97%E3%81%8F%E3%81%AF%20Lazy%20Loading%20Routes%20%E3%82%92%E5%8F%82%E7%85%A7%E3%81%97%E3%81%A6%E3%81%8F%E3%81%A0%E3%81%95%E3%81%84%E3%80%82))や開発者コミュニティの記事 ([「Vue3で保守性の高いテストコード作成方法を解説！Vue3エンジニアが実装とテストの疎結合実装方法を解説！」低コストなモダナイズ開発の実践 | Ragate](https://www.ragate.co.jp/blog/articles/10228#:~:text=%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%81%AF%E3%80%81%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%9F%20Component%20%E3%81%8C%E6%84%8F%E5%9B%B3%E3%81%97%E3%81%9F%E9%80%9A%E3%82%8A%E3%81%AE%E3%83%AC%E3%83%B3%E3%83%80%E3%83%AA%E3%83%B3%E3%82%B0%E3%83%BB%E6%8C%AF%E3%82%8B%E8%88%9E%E3%81%84%E3%82%92%E8%A1%8C%E3%81%AA%E3%81%A3%E3%81%A6%E3%81%84%E3%82%8B%E3%81%8B%E3%82%92%E3%83%86%E3%82%B9%E3%83%88%E3%81%97%E3%81%BE%E3%81%99%E3%80%82%20Vue3%20%E3%81%A7%E4%BD%BF%E7%94%A8%E3%81%95%E3%82%8C%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%86%E3%82%B9%E3%83%88%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA%E3%81%AF,%E3%81%AA%E3%81%A9%E3%81%8C%E3%81%82%E3%82%8A%E3%81%BE%E3%81%99%E3%80%82)) ([Vue.js パフォーマンス最適化完全ガイド | 初心者エンジニアのつぶやき](https://www.takatechskill.com/archives/603#:~:text=Vue%20%E3%81%AE%20%60keep,%E3%81%A7%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%82%8B%E3%81%A8%E3%81%8D%20%E3%82%84%20%E3%82%BF%E3%83%96%E5%88%87%E3%82%8A%E6%9B%BF%E3%81%88%E3%81%AE%E3%82%88%E3%81%86%E3%81%AA%20UI%20%E3%81%A7%E6%9C%89%E5%8A%B9%E3%81%A7%E3%81%99%E3%80%82))を参照し、最新の知見に基づいて内容をまとめました。各項目の詳細については引用元もぜひ参照してください。