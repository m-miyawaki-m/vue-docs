了解しました。Vuetify 3 のデータテーブル系コンポーネント（v-data-table、v-pagination）について、商品一覧を外部APIから取得するユースケースを想定し、これまでと同様の形式で研究テンプレートを作成します。調査完了後に順次お届けしますので、しばらくお待ちください。


# Vuetify 3のデータテーブル (v-data-table) とページネーション (v-pagination) の概要と活用

## 基本説明と主な用途（商品一覧への活用）

**v-data-table**コンポーネントは、データを表形式で表示するために使用され、ソート、検索、ページネーション、グループ化、行選択などの豊富な機能を備えています。商品一覧の表示では、商品データ（商品名、価格、在庫など）を見やすいテーブル形式で一覧化し、ユーザーが項目で並び替えたりキーワード検索したりできるようにするのに適しています。またページネーション機能により、多数の商品をページ分割して表示できます。

**v-pagination**コンポーネントは、ページネーション用のUI部品です。複数ページにわたるデータを扱う際に、現在のページ番号や総ページ数を表示し、ユーザーがページを切り替えるためのページ番号ボタンや「次へ・前へ」ボタン、「最初・最後」へのボタンなどを提供します。商品一覧で商品数が多い場合に、テーブル下部にページ番号リンクを表示してユーザーがページを移動できるようにする、といった用途で活用します。

**商品一覧の主なシナリオ:**  商品データは通常外部APIから取得すると想定されます。Vuetify 3では、クライアント側で全商品データを一括取得してテーブル表示する方法と、ページネーションやソートに応じて都度サーバからデータを取得する方法の両方に対応できます。後者の場合には、v-data-tableとv-paginationを組み合わせて現在のページを管理したり、あるいはVuetify 3で新たに提供される**v-data-table-server**コンポーネントを使ってサーバサイドページネーションを簡易化することも可能です。以下では、v-data-tableとv-paginationの基本について解説し、商品一覧での活用方法やテクニックを紹介します。

## 主な Props 一覧

### v-data-table の主なProps

* **items**: テーブルに表示するデータ配列を指定します。商品一覧では商品の配列をバインドします。例えば`:items="products"`のように使用します。

* **headers**: 列ヘッダーの定義を配列で指定します。各要素はオブジェクトで、少なくとも表示タイトル(`title`)とデータ項目キー(`key`)を含みます。例えば:

  ```js
  headers: [
    { key: 'name', title: '商品名', sortable: true },
    { key: 'price', title: '価格', align: 'end' },
    // ... 他の列定義
  ]
  ```

  ※Vuetify 3ではVuetify 2からプロパティ名が変更されており、列定義で表示テキストは`text`ではなく`title`に、データの識別子は`value`ではなく`key`になっています。

* **search**: テーブル内の簡易検索フィルタ文字列を指定できます。指定した文字列にマッチする行だけが表示されます。例えば商品名や説明に対するキーワード検索に利用します（全列が対象になりますが、`filter-keys`プロパティで検索対象のフィールドを限定することも可能です）。

* **items-per-page**: 1ページあたりに表示する項目数を指定します。デフォルトは5件ですが、10件や20件など用途に合わせて設定できます。`-1`を指定するとページネーションを使わず全件表示します。例: `:items-per-page="10"` とすると1ページ10件表示。

* **page**: 現在表示中のページ番号（1始まり）を指定します。デフォルトは1ページ目です。`v-model:page`を使用してページ番号を外部から同期制御することもできます。

* **sort-by** / **sort-desc**: 初期のソート設定や現在のソート状態を制御します。`sort-by`はソートキー名（またはその配列）で、`sort-desc`は降順かどうかの真偽値（またはその配列）です。例えば`sort-by="price"`とすれば価格列でのソート、`:sort-desc="true"`とすれば降順になります。複数列のソートを許可する場合、後述の**multiSort**を利用します。

* **multi-sort**: 複数列の同時ソートを許可するかを指定します（デフォルト`false`）。`true`にするとShift+クリックで複数の列でのソートが可能になります。

* **must-sort**: ソートを必須にするかどうか。`true`にすると、ユーザーがソートを解除できなくなり、常に何らかのソート順が適用されます。

* **item-value**: 各行アイテムのユニークキーとして使うプロパティ名を指定します。デフォルトは`value`ですが、Vuetify 3ではVuetify 2の`item-key`から名称が変更されています。商品データの中の一意なIDフィールド名（例:`id`）を指定しておくと、選択や展開時の識別に使われます。

* **loading**: 真偽値または文字列。`true`にするとテーブルにローディング状態のスピナーやテキストを表示します。外部APIからデータ取得中に`loading=true`を設定してユーザーに読み込み中であることを示す用途に使えます（このとき`loading-text`プロップで表示文言のカスタマイズも可能）。

* **no-data-text** / **no-results-text**: データがない場合や、検索結果が0件の場合に表示するテキストを指定します。デフォルトでは英語で *"No data available"* 等と表示されますが、必要に応じて日本語に変更できます。

* **server-items-length** (廃止): Vuetify 2で使用されていた、サーバ上の総データ件数を指定するプロパティです。Vuetify 3ではこのプロップは**v-data-table**では廃止され、代わりに後述の**v-data-table-server**コンポーネントで`items-length`として扱われます。そのため、大量データのページネーションには基本的にv-data-table-serverを使用します。

* **show-select**: 行選択用のチェックボックスを各行に表示します。`show-select`を指定すると先頭列にチェックボックスが追加され、複数選択が可能になります（全選択用チェックボックスもヘッダーに自動追加されます）。選択状態の制御には後述のイベント（例えば`update:modelValue`でバインドした選択配列の同期や、`toggle-select-all`イベントなど）を使用します。

※上記の他にも細かなプロップスがありますが、商品一覧の基本用途で特に重要なのはデータ（`items`）、ヘッダー（`headers`）、検索（`search`）、ページネーション関連（`items-per-page`, `page`）およびソート関連（`sort-by`等）です。

### v-pagination の主なProps

* **v-model / modelValue**: 現在のページ番号をバインドします。`v-pagination`は`v-model`によってページ番号を双方向バインディングでき、内部的には`modelValue`プロップとして扱われます。例えば`<v-pagination v-model="page" :length="totalPages">`のように使い、`page`データを現在のページとして同期します。ユーザーがページをクリックすると自動的に`page`が更新されます（イベント名で言えば`@update:modelValue`が発火します）。
* **length**: 総ページ数を指定します。例えば全商品数が100件で1ページあたり10件表示の場合、`length`は10となります。lengthプロップに基づいてページ番号ボタンが生成されます。
* **total-visible**: 同時に表示するページ番号ボタンの数を指定できます。デフォルトではコンテナ幅に応じて自動調整されますが、例えば`:total-visible="5"`とすると最大5つ分のページ番号を表示し、それを超える部分は「…」で省略表示されます。多数のページがある場合に、ページリストをコンパクトにするのに役立ちます。
* **show-first-last-page**: 最初と最後のページへのボタンを表示するかどうかの真偽値です。デフォルトは非表示ですが、`show-first-last-page`を`true`に設定すると、「≪ (First)」および「≫ (Last)」のボタンがページリスト両端に表示されます。長いページ一覧で先頭や末尾に飛びたい場合に有用です。
* **prev-icon／next-icon**: 「前へ」「次へ」ボタンのアイコンをカスタマイズできます。デフォルトではVuetifyの標準アイコン（左向き・右向き矢印）が使われますが、例えば`prev-icon="mdi-chevron-left"`のように指定可能です（first/lastも同様に`first-icon`/`last-icon`で変更可）。
* **size**や**color**: ページネーションコンポーネント全体のサイズ（小さめに表示したい場合など）や色を変更できます。例えば`size="small"`で小サイズ、`color="primary"`でプライマリテーマカラーのボタンにする、といった指定が可能です。

※v-paginationはあくまでページ番号UI専用のコンポーネントであり、表示内容のデータは保持しません。したがって、総ページ数（`length`）や現在ページ（`v-model`）の値は、v-data-table側（もしくはアプリケーション側）で計算して与える必要があります。通常は、v-data-table内蔵のページネーションを使う場合はこれらは自動管理されますが、独自にv-paginationを使う場合にはアプリ側で総件数からページ数を算出します。

## 利用可能な Slots

**v-data-table**はテーブルの各部分をカスタマイズするために多くのスロットを提供しています。主なスロットは以下のとおりです。

* **`#top`**: テーブルの上部（ヘッダーより上の領域）に独自のコンテンツを挿入できます。検索ボックスや「新規商品追加」ボタンなど、テーブル上部に配置したい要素を置くのに適します。
* **`#headers`**: テーブルヘッダー全体をカスタマイズできます。何も出力しないことでヘッダーを非表示にすることも可能です（Vuetify 3では`hide-default-header`プロップが廃止されたため、ヘッダー非表示にはこの空の`headers`スロットを利用します）。
* **`#header.<key>`**: 特定の列ヘッダーの内容をカスタマイズできます。`<key>`は`headers`定義で指定したキー名です。例えば`<template #header.price>...</template>`とすると価格列のヘッダーセル内を独自にレンダリングできます。列見出しにアイコンを追加したり、ツールチップを仕込む場合に使用します。
* **`#item.<key>`**: 特定の列セルの表示内容をカスタマイズできます。こちらも`<key>`はヘッダーのキー名です。例えば`<template #item.price="{ item }">￥{{ item.price.toLocaleString() }}</template>`のように書くと、価格データに通貨表記やフォーマットを適用して表示できます。各行ごとの指定列セルのみ書き換えたい場合に便利です。
* **`#item`**: 行全体の表示をカスタマイズします。このスロットを使用すると、その行のHTML構造全体を自由に描画できます（ただし`#item.<key>`スロットよりも優先度が低い/高い点に注意。Vuetifyのドキュメントによれば、スロットの適用順位は `body > item > item.<name>` となっており、広域なものほど上書きされやすくなります）。通常は個別セルカスタマイズで足りない場合に用います。
* **`#no-data`**: `items`が空で表示するデータがない場合に表示する内容をカスタマイズできます。デフォルトメッセージではなく独自のメッセージやイラストを表示したい場合に使用します。
* **`#no-results`**: `search`フィルタの結果がゼロ件だった場合の表示をカスタマイズします。例えば「該当する商品が見つかりません」というメッセージを表示するなど、ユーザーへのフィードバックを自由に定義できます。
* **`#body`**: テーブルボディ全体のレンダリングをカスタマイズできます。`#item`スロットと似ていますが、より広域なため通常はあまり使用しません。
* **`#bottom`**: テーブルのフッター部分をカスタマイズできます。Vuetify 3ではページネーションUI（件数切り替えやページボタン）はデフォルトでテーブル下部に表示されますが、これを完全に独自実装に置き換えたい場合、`<template #bottom></template>`と空にしてデフォルトフッターを非表示にし、自前のページネーションUIを配置することが可能です。

加えて、**行選択や展開**に関する特殊なスロットもあります。例えば`item.data-table-select`スロットで行選択用チェックボックスの見た目を差し替えたり、`item.data-table-expand`スロットで展開行（詳細表示部分）の内容を定義できます。商品一覧では必要に応じて、行をクリックした際に詳細パネルを表示する場合などに`item.data-table-expand`を活用できます。

**v-pagination**コンポーネントはスロットによるカスタマイズは多くありませんが、一部用意されています。

* **`#prev` / `#next`**: 前へ・次へボタンの内容をカスタマイズできます。例えばデフォルトの矢印アイコンをテキスト「前へ」に変える、といったことが可能です。
* **`#first` / `#last`**: 最初・最後へ移動するボタンの内容をカスタマイズできます。ただし、これらを有効にするには前述の`show-first-last-page`プロップを`true`に設定する必要があります（有効でない場合、このスロットにテンプレートを定義しても表示されません）。

## 主なイベント

### v-data-table の主なイベント

* **@click\:row**: 行がクリックされたときに発火します。引数には `(item, index)` など該当行のデータオブジェクトやインデックスが渡されます。商品一覧で行クリックにより詳細ページに遷移したり編集画面を開く場合に、このイベントを利用して処理を実行できます。
* **@update\:items-per-page**: `items-per-page`（1ページあたり件数）が変更された時に発火します。デフォルトのフッターにある「件数切替（Items per page）」ドロップダウンでユーザーが値を変更した際などにこのイベントが発生し、新しい件数が渡されます。必要に応じてその値を保持したり、サーバ再問い合わせに利用します。
* **@update\:options**: **v-data-table-server専用**のイベントですが、v-data-tableでもオプションオブジェクトをバインドしている場合に利用できます。ページ番号・件数・ソートなど「テーブルの表示オプション」が変化した際に発火し、`{ page, itemsPerPage, sortBy, sortDesc, ... }`といったオブジェクトが渡されます。v-data-table-serverではこのイベントにデータ取得処理を紐付けることで、ユーザー操作に応じたサーバ再問い合わせを実現します（詳細は後述の使用パターン参照）。
* **@item-selected**: 行が選択（チェック）されたときに発火します。選択状態になったアイテム、あるいは選択解除されたアイテムが引数で渡されます。`show-select`利用時に、選択項目を監視して別途処理したい場合に使います。
* **@toggle-select-all**: ヘッダーの「全選択」チェックボックスがクリックされた際に発火します。選択状態（すべて選択されたか解除されたか）が引数で渡されるので、一括選択／解除時の処理を入れたい場合に利用します。
* **@item-expanded**: 行の展開（詳細表示の開閉）が行われた際に発火します。展開対象の行オブジェクトが渡されます。

この他、**@page-count**というイベントもあります。Vuetify 2ではテーブルからページ総数を取得するのに使われましたが、Vuetify 3のv-data-tableではサーバデータの場合`server-items-length`ではなくv-data-table-serverを使う設計になったため、あまり直接使うケースは減っています。代わりに`items-length`を指定した場合（v-data-table-server）には、v-paginationに直接総...ケースは減っています。代わりに、サーバサイドのページネーションでは**v-data-table-server**コンポーネント側で`items-length`（総件数）を指定し、テーブルが持っていない全体の件数情報を補います。これによりVuetify側で総ページ数を把握でき、正しいページネーションUI（v-pagination）を表示できます。

### v-pagination のイベント

v-pagination自体には明示的なイベントはありませんが、`v-model`を使用することでページ番号の変更を親コンポーネント側で検知できます。例えば`v-model="page"`としておけば、ユーザーがページをクリックした際に`page`の値が更新されます（これは内部的に`@update:modelValue`イベントによるものです）。v2系では`@input`イベントでページ番号を受け取っていましたが、v3では基本的に`v-model`で扱えば問題ありません。

## よくある使用パターンとコード例（外部APIとの連携も含む）

商品一覧でのデータテーブル利用パターンとして、**(1) 全データを一括取得してクライアント側でページネーションする方法**と、**(2) ページごとにサーバからデータを取得する方法**があります。

**(1) クライアントサイドページネーション:**  商品数が少ない場合や、全データをまとめて取得しても問題ない場合は、単純にAPIから全商品データを取得し、それをv-data-tableの`items`に渡して表示します。v-data-tableは内部でページネーション・ソート・検索を処理してくれるため、特別なコードを書かずに基本機能を利用できます。例えば以下のようになります。

```vue
<template>
  <v-data-table :headers="headers" :items="products" :search="search"
                class="elevation-1"
                :items-per-page="10" :page.sync="page">
    <template #top>
      <!-- 検索ボックスや追加ボタン等 -->
      <v-text-field v-model="search" label="検索" class="mx-4" placeholder="商品名で検索"/>
    </template>
  </v-data-table>
</template>

<script>
export default {
  data: () => ({
    products: [],      // 全商品データ
    headers: [ /* ヘッダー定義 (key, title 等) */ ],
    search: "",
    page: 1
  }),
  mounted() {
    // マウント時に全商品を取得
    fetch("https://api.example.com/products")
      .then(res => res.json())
      .then(data => { this.products = data.items })
  }
}
</script>
```

上記では、`mounted`フック内で全商品のデータを取得し、`products`にセットしています。v-data-tableは`items`に与えた配列を自動的にページ分割表示し、デフォルトフッターにページネーションUI（「Items per page」やページ切替ボタン）が表示されます。検索ボックスを`#top`スロットに配置し、`search`プロップにバインドすることで、入力したキーワードで`products`を絞り込むことができます。

**(2) サーバサイドページネーション:**  商品数が非常に多い場合や、常に最新のデータをサーバから取得したい場合は、ページ変更やソート操作のたびにAPIを呼び出す方式が適しています。Vuetify 3ではこの用途に**v-data-table-server**コンポーネントの使用が推奨されています。v-data-table-serverはユーザー操作（ページ変更、ソート変更など）のたびに`@update:options`イベントを発火し、ハンドラに現在のページやソート情報を渡してくれるため、それを使ってAPIを呼び出し、取得データと総件数をテーブルに反映できます。以下はその実装例です。

```vue
<template>
  <v-data-table-server :headers="headers" :items="products" :items-length="totalItems"
                       :loading="loading" class="elevation-1"
                       @update:options="onOptionsUpdate">
    <template #top>
      <v-text-field v-model="search" label="検索" class="mx-4" @input="onSearch" />
    </template>
    <!-- フッターはデフォルトのページネーションUIが表示される -->
  </v-data-table-server>
</template>

<script>
export default {
  data: () => ({
    products: [],      // 現在のページの商品データ
    totalItems: 0,     // 商品の総件数
    headers: [ /* ヘッダー定義 */ ],
    search: "",
    loading: false
  }),
  methods: {
    // ページ・ソート・検索変更時に呼ばれるハンドラ
    async onOptionsUpdate(options) {
      const { page, itemsPerPage, sortBy } = options  // 受け取ったオプション
      this.loading = true
      // ソートキーと順序の決定（指定なければデフォルトキー）
      const sortKey = sortBy?.[0]?.key || 'name'
      const sortOrder = sortBy?.[0]?.order || 'asc'
      // APIリクエスト（検索クエリも含める）
      const res = await fetch(`https://api.example.com/products?page=${page}&perPage=${itemsPerPage}&sort=${sortKey}&order=${sortOrder}&query=${this.search}`)
      const data = await res.json()
      this.products = data.items        // 現在ページのデータ
      this.totalItems = data.totalCount // 総件数を更新
      this.loading = false
    },
    // 検索文字列が変わったら1ページ目から再読み込み
    onSearch() {
      // 現在optionsは自動で更新される（searchは直接optionsに含まれないため手動でページ=1から再取得）
      this.onOptionsUpdate({ page: 1, itemsPerPage: 5, sortBy: [] })
    }
  }
}
</script>
```

上記コードでは、`v-data-table-server`に対して`@update:options="onOptionsUpdate"`を指定しています。これによりユーザーがページを切り替えたりソートを変更する度に`onOptionsUpdate`メソッドが呼ばれ、現在のページ番号やソート情報が引数で渡されます。メソッド内ではその情報を用いて対応するAPIエンドポイント（例：`/products?page=...&perPage=...`）にリクエストを送り、結果として返ってきた現在ページのデータと総件数をそれぞれ`products`と`totalItems`にセットします。これによりテーブルには新しいページのデータが表示され、また`totalItems`の変更によってページネーションの総ページ数も自動更新されます。`items-length`プロップに総件数を渡すことで、内部のページネーションが正しく機能し、全ページ数に基づいたナビゲーションが表示されます。

なお、この例では検索ボックスの入力に合わせて`onSearch`メソッドでページをリセットし再検索しています。実装上は検索クエリも`options`に含めて管理することもできますが、単純化のため別途ハンドリングしています。

**v-paginationコンポーネントを直接使う方法:**  上記のようにv-data-tableのデフォルト機能やv-data-table-serverを用いれば、内部でページネーションUIが表示されます。しかし、レイアウトの都合でページネーションをテーブル外に置きたい場合や、独自のページネーション制御を行いたい場合には、`v-pagination`を明示的に使用することも可能です。例えばデフォルトのフッターを非表示にし（`<template #bottom></template>`を利用）、その代わりにコンポーネント下部に`<v-pagination v-model="page" :length="pageCount" :total-visible="7">`を配置するといった実装が考えられます。こうすることでページネーションUIを自由に配置・デザインでき、ページ番号の変化は`page`データの変化としてキャッチしてAPIを呼ぶ等の制御を行います。もっとも、基本的には内蔵のページネーションで十分なケースが多いでしょう。

## 応用テクニック（ページネーション、ソート、検索、レスポンシブ対応）

### ページネーションのカスタマイズ

データテーブルのページネーションはデフォルトではテーブル下部のフッターに「Items per page」ドロップダウンと左右のページ移動ボタン、およびページ番号表示が組み合わさったUIとして提供されます。このUIは自動生成されますが、要件に応じてカスタマイズ可能です。例えば:

* **表示件数の選択肢変更:** デフォルトでは`5, 10, 25, 50, All`（Allは全件表示）といった選択肢が用意されていますが、`items-per-page-options`プロップで独自の配列を渡すことで変更できます。例えば`:items-per-page-options="[10, 20, 50]”`とすると10件、20件、50件のみ選択可能になります（「All」を含めたい場合は`{ title: 'All', value: -1 }`のようなオブジェクトで指定）。
* **「All（全件）」オプション:** 全件表示オプションも上記のように設定できます。Vuetify 3では`-1`が特別な値として全件表示を意味するため、`items-per-page-options`に`{ title: 'All', value: -1 }`を含めることでドロップダウンに「All」が表示され選択可能になります。
* **フッターの非表示・独自UI:** 既述のとおり、`#bottom`スロットを空にすることでデフォルトフッターを消し、自前のページネーションUIを配置できます。その際、v-paginationコンポーネントと組み合わせてページ切替を制御します。
* **先頭・末尾ページボタン:** v-data-table内蔵のページネーションでも`showFirstLastPage`相当の設定はデフォルトで有効になっています（Vuetify 3ではデフォルトで最初・最後ボタンが表示される仕様です。ただしテーマによってはアイコンが表示される形になります）。v-paginationを自前配置する場合は前述の`show-first-last-page`プロップで制御してください。

### ソート機能の活用

v-data-tableは列単位のソートを簡単に扱えます。ソートを有効にしたい列のヘッダー定義に`sortable: true`（デフォルトでtrue）を指定すると、その列ヘッダーをクリックすることで昇順・降順・非ソートを順に切り替えられます。デフォルトのソート順を設定したい場合は、v-data-tableに`sort-by`と`sort-desc`を渡します。例えば最初から価格降順にしたい場合、`:sort-by="['price']"`と`:sort-desc="[true]"`を指定します。ソート状態が変更されると、内部的にデータ配列が並び替えられて再表示されます。サーバサイドページネーションの場合、ソート変更時に`@update:options`で渡される`options.sortBy`配列を見てサーバにクエリを送る必要があります（先述コード例参照）。

**複数列ソート:** デフォルトでは一度にソートできる列は一つですが、`multi-sort`プロップを`true`にするとShiftキーを押しながら複数の列ヘッダーをクリックして複合ソートが可能になります。例えば商品名と価格の両方でソートした結果を見たい場合に有用です。また、`must-sort`を`true`にすると常に何らかのソートが適用された状態となり（ソートの解除ができない）、データの並び順が不定にならないよう強制できます。

**カスタムソート:** 標準では文字列はアルファベット順・数値は大小順でソートされますが、独自ロジックが必要な場合（例えば商品コードを特殊な順序で並べたい等）は、items配列を事前に並び替えてから渡すか、またはVuetifyの`custom-sort`プロップを利用できます。`custom-sort`に関数を渡すと、ソート処理をその関数でオーバーライド可能です。ただし一般的な用途では標準機能＋サーバサイドソート連携で事足りるでしょう。

### 検索とフィルタリング

v-data-tableの`search`プロップは、単一のテキスト入力で全行をフィルタリングする簡易検索機能です。例えば商品一覧で商品名や説明に検索キーワードが含まれるかどうかで絞り込みたい場合、`v-model="search"`をバインドした入力フィールドを用意するだけで実現できます。デフォルトでは全ての列の値が対象になりますが、検索対象のフィールドを限定したい場合は`filter-keys`プロップにキー名の配列を渡します。例えば`filter-keys="['name', 'description']"`とすれば、商品名と説明のみを検索対象にします。

**カスタムフィルター:** `search`のマッチング動作をカスタマイズしたい場合、`custom-filter`プロップで関数を提供できます。この関数では、引数に各アイテムと検索文字列が渡されるので、独自の判定ロジックを実装してtrue/falseを返します。たとえば部分一致ではなく前方一致にしたい、複数キーワードに対応したい、といった場合に利用可能です。

なお、複雑なフィルターUI（例えば列ごとにドロップダウンでカテゴリー別に絞り込む等）を実現する場合は、テーブル外にフィルター用の入力UIを設置し、その値に基づいて`items`配列を自前でフィルタリングしてからv-data-tableに渡す方がシンプルなこともあります。Vuetifyの機能と組み合わせつつ、要件に応じて柔軟に実装してください。

### レスポンシブ対応

データテーブルは画面サイズが小さい場合に表示しきれなくなることがあります。Vuetify 2では自動的に「モバイルビュー」としてカード形式にレイアウトを切り替える機能がありましたが、Vuetify 3.4時点ではモバイル用レイアウトが未実装で、そのまま縮小表示されてしまう状態でした。しかし**Vuetify 3.6.0**でモバイル対応が復活し、`mobile`プロップと`mobile-breakpoint`プロップでテーブルをモバイルモードに切り替えることができるようになりました。`mobile-breakpoint`はモバイルビューに切り替える画面幅を指定し（デフォルト600pxや任意のpx値）、`mobile`を強制的にtrue/falseに設定することで手動でモードを固定することも可能です。

モバイルモードでは、各行がカード状またはリスト状に縦並びで表示され、列見出しが各データの前にラベルとして付与されるレイアウトになります（Vuetify 2の挙動に準拠）。これにより小さな画面でも横スクロールなしに情報を閲覧できます。

それ以外のレスポンシブ対応策としては、スタイル調整でテーブルに横スクロール（`overflow-x: auto`）を付与し、小画面ではテーブル全体をスクロール可能にする方法があります。また、表示する列を絞る（不要な列は画面幅によって非表示にする）工夫も有効です。例えばVuetifyの表示用ユーティリティ（`v-show="$vuetify.display.smAndDown"`など）を使い、小画面では特定列のテンプレートを非表示にするといった対応が考えられます。

もし商品一覧の情報量が多くモバイルでの閲覧が難しい場合、思い切ってテーブルではなく**カードリスト形式**に切り替えることも検討してください。Vuetifyのグリッドシステムとv-cardを組み合わせて、モバイル時は1列リスト、PC時は表形式に近いグリッド表示、といったレスポンシブデザインも可能です。

## よくある落とし穴や注意点

* **Vuetify 2からの移行におけるプロップ名変更:** 前述のようにヘッダー定義の`text`→`title`、`value`→`key`への変更、`item-key`プロップの廃止（`item-value`に変更）などがあります。移行時に古いプロップ名のままでは正しく動作しないため注意してください。
* **デフォルトの表示件数に注意:** Vuetify 3のv-data-tableはデフォルトで5件ずつの表示になっています。そのため特に`items-per-page`を指定しないと「なんだかデータが全部表示されない？」と戸惑うかもしれません。必要に応じて`items-per-page`を明示設定するか、ユーザーにとって適切な値に調整しましょう（例: 10件表示など）。
* **大量データの扱い:** 数千件を超えるような非常に大きなデータ集合をクライアント側で扱う場合、全件を一度に`items`に渡すとパフォーマンスが低下する可能性があります。そのような場合はサーバサイドページネーションを検討すべきです。またVuetify 3.4以降では**VDataTableVirtual**コンポーネント（仮想スクロールによるパフォーマンス改善）が利用可能で、何万件ものデータでも一部のみをレンダリングして高速にスクロール表示できます。用途に応じて適切なコンポーネントを選択してください。
* **フッターやページネーションのカスタマイズ廃止点:** Vuetify 2で提供されていた`hide-default-footer`プロップはVuetify 3では削除されています。そのためフッターを非表示にしたい場合は上述のようにスロットを使う必要があります。同様に、v-data-tableの`footer-props`もv3では推奨されず、直接`items-per-page-options`等のプロップで指定する形式に変わっています。アップグレード時にはこれらの変更点に留意してください。
* **server-items-lengthの扱い:** v-data-table単体では`server-items-length`プロップが使えなくなりました。代わりにv-data-table-serverを使う設計になっているため、サーバデータの総件数は`<v-data-table-server :items-length="...">`のように渡します。誤ってv-data-tableに`server-items-length`を指定してもうまく機能しない点に注意が必要です。
* **スロットの優先順位:** v-data-tableのスロットは名前によって適用範囲と優先順位があります。例えば`#item<列名>`スロットを定義するとその列のセル表示はすべてそのスロット内容で上書きされます。一方で`#item`スロットは行全体のレイアウトを差し替えますが、個別の`#item.<列名>`がある場合はそれが優先されます。カスタマイズの際に意図しないスロットの競合がないよう留意してください。
* **レスポンシブ対応のバージョン差異:** 先述のとおりVuetify 3.5以前ではモバイル用レイアウトが機能していなかったため、独自対応が必要でした。3.6で公式対応が入ったとはいえ、プロジェクトで使用しているVuetifyのバージョンによって挙動が異なる可能性があります。バージョンアップ時の変更ログ（特にv3.6.0の内容）を確認し、必要に応じて`mobile-breakpoint`設定などを調整してください。

以上、Vuetify 3におけるv-data-tableおよびv-paginationコンポーネントの基礎から応用までをまとめました。商品一覧の表示にあたっては、まず基本的なpropsで必要な機能を有効化し、標準機能で足りない部分はイベントやスロットで拡張する方針がおすすめです。適切にページネーションやソートを実装して、ユーザーが快適に商品一覧を閲覧・操作できるUIを構築してください。

