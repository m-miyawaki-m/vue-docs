了解しました。Vuetify 3 の表示制御・通知系コンポーネント（v-dialog、v-snackbar、v-tooltip）について、これまでと同様の形式で研究テンプレートを作成します。調査完了後に順次お届けしますので、しばらくお待ちください。


# Vuetify 3 表示制御・通知コンポーネント研究テンプレート

## ダイアログ（v-dialog）

### 基本説明と主な用途

v-dialogコンポーネントは、特定のタスクに関する重要な情報をユーザーに伝えたり、意思決定を促したりする場面で使用されるモーダルウィンドウです。ボタンなどの操作で画面上にポップアップ表示され、メニューに似た動作をします。ただしメニューと異なり、v-dialogはプログラムから開閉を完全に制御できるため、たとえばアクション後も自動で閉じずユーザーの明示的な操作まで開いたままにするといった柔軟な制御が可能です。主にユーザーからの確認（確認ダイアログ）や入力フォーム、詳細情報の表示などに用いられます。

### 主な Props 一覧

* **v-model** (Boolean) – ダイアログの表示状態を制御します。バインドした変数が`true`で表示、`false`で非表示となります。内部的には`model-value`プロパティと`update:modelValue`イベントで実現されています。
* **activator** (String / Element) – ダイアログを開くトリガー要素を指定します。例えば`activator="parent"`とすると親要素（例: `<v-btn>`）がクリックされた際にダイアログが開きます。また、`"#myButton"`のようにCSSセレクタ文字列を指定すると、そのIDを持つ要素がクリックされたときにダイアログが開きます。activatorスロットを使わない場合の代替手段です。
* **persistent** (Boolean) – モーダル外（スクラム領域）をクリックしたりESCキーを押した際にダイアログを閉じないようにします。ユーザーの明示的な操作でのみ閉じさせたい場合に設定します。persistent有効時に外部をクリックするとデフォルトではダイアログが軽く揺れる「バウンス」アニメーションが発生します。
* **no-click-animation** (Boolean) – persistent使用時のバウンスアニメーションを無効にします。ユーザーがダイアログ外をクリックした際にコンテンツが揺れる演出を止めたい場合に利用します。
* **width / max-width** (String / Number) – ダイアログコンテンツの横幅を指定します。例えば`width="500"`や`max-width="80%"`のようにピクセルまたはパーセンテージ指定が可能です。デフォルトでは適度な幅になりますが、画面幅いっぱいに広げたい場合は`max-width="100%"`とします。
* **fullscreen** (Boolean) – ダイアログを画面全体（フルスクリーン）で表示します。モバイル端末など小画面で利用する際に便利です。`fullscreen`時は通常背景のスクラムは非表示（透明）になるため、必要に応じて`persistent`と組み合わせて利用します。
* **scrollable** (Boolean) – ダイアログ内のコンテンツが画面高さを超える場合に、内部でスクロールできるようにします。長大なリストやフォームを含む場合に指定し、ダイアログ内でのスクロールを有効化します。指定しない場合、コンテンツが大きすぎるとダイアログ自体が画面外にはみ出す可能性があります。
* **scrim** (Boolean/String) – ダイアログ背面のオーバーレイ（スクラム）の表示を制御します。デフォルトでは半透明の黒が表示されますが、`:scrim="false"`で非表示にしたり、`scrim="#ff000080"`のようにカラーコードや色名を渡して背景色と不透明度を調整できます。
* **eager** (Boolean) – ダイアログを遅延レンダリングせず常にDOMにマウントします。通常、ダイアログは表示要求があるまでDOMに存在しませんが、トランジションの問題回避やサーバサイドレンダリングでのプレレンダリングに利用します（必要な場合のみ）。
* **transition** (String) – ダイアログ表示/非表示時のトランジション効果を変更します。デフォルトはフェードや拡大縮小を組み合わせた専用のトランジションですが、`transition="dialog-bottom-transition"`のように他のトランジション名を指定可能です。独自にCSSを定義してトランジションをカスタマイズすることもできます。

### 利用可能な Slots

* **default** – ダイアログ内部に表示するコンテンツを定義します。通常、ダイアログ内にはカード（`<v-card>`）やシート（`<v-sheet>`）などを配置し、その中にタイトルやメッセージ、ボタンなどの要素をレイアウトします。
* **activator** – ダイアログを開くためのアクティベータ要素をカスタマイズするためのスロットです。スロットスコープから提供される`props`（または`{ on, attrs }`）をボタンなどにバインドすることで、クリック時にダイアログが開く要素を自由に配置できます。activatorスロットを使用する場合、上記のactivatorプロパティは不要です。

### 主な Events

* **@update\:modelValue** – `v-model`（`model-value`）が変化した際に発火します。ダイアログが開閉する際に呼び出されるイベントで、引数には新しいBoolean値（true/false）が渡されます。通常は`v-model`でバインディングすれば充分なので、手動でリスナーを指定する場面は多くありませんが、親コンポーネントで開閉を検知したい場合に利用します。
* **@click\:outside** – ダイアログの外側（スクラム部分）がクリックされた時に発火します。通常、ダイアログ外クリック時はダイアログが閉じますが（persistent時は閉じずバウンスするだけ）、このイベントを使うことで外側クリックに対する独自処理を挟んだり、persistentダイアログを手動で閉じる処理を実装できます。例えば`<v-dialog v-model="dialog" persistent @click:outside="onOutsideClick">`のように使います。
* **@keydown** (イベント修飾子付き) – ダイアログが表示されている間のキー押下を処理したい場合、通常は最上位の`v-overlay`に対して`@keydown.stop`などとします（例えばEscキーで閉じるカスタム処理等）。Vuetifyが内部でEscキーを処理していますが、独自に上書きしたい場合にキーダウンイベントを利用する方法があります。直接のv-dialogのイベントとしては定義されていませんが、必要ならダイアログ内容にフォーカスを移し、そこでキーイベントをキャプチャします。

### よくある使用パターンとコード例

**パターン1: ボタン内部に埋め込んで使用** – ボタン要素の中に`v-dialog`を子要素として配置し、`activator="parent"`を指定する方法です。これにより、そのボタンをクリックするとダイアログが開くようになります。制御用のデータ変数（例えば`dialog`）を用意し、`v-model`にバインドします（trueで開く、falseで閉じる）。ダイアログ内には内容を配置し、閉じるためのボタンで`dialog`変数をfalseに設定します。

```vue
<template>
  <v-btn color="primary">
    ダイアログを開く
    <v-dialog v-model="dialog" activator="parent" width="400">
      <v-card>
        <v-card-title>タイトル</v-card-title>
        <v-card-text>ここにダイアログの内容を配置</v-card-text>
        <v-card-actions>
          <v-btn color="primary" @click="dialog = false">閉じる</v-btn>
        </v-card-actions>
      </v-card>
    </v-dialog>
  </v-btn>
</template>

<script setup>
import { ref } from 'vue'
const dialog = ref(false)
</script>
```

上記のように記述すると、ボタンをクリックしたときに`dialog`が`true`に変わり、ダイアログが表示されます。閉じるボタンで`dialog = false`とすることでダイアログを閉じています。この方法ではHTML上でボタンとダイアログが親子関係になっており、簡潔に実装できるのが利点です。

**パターン2: トリガー要素とダイアログを分離** – ダイアログを開くボタンと`v-dialog`コンポーネントを別々に配置し、ボタンのクリックハンドラ内でデータ変数を操作する方法です。activatorを使わず、自分でイベントを管理することで、より明示的な制御が可能です。

```vue
<template>
  <v-btn color="primary" @click="dialog = true">ダイアログを開く</v-btn>

  <v-dialog v-model="dialog" width="400" persistent>
    <v-card>
      <v-card-title>確認</v-card-title>
      <v-card-text>本当に実行しますか？</v-card-text>
      <v-card-actions>
        <v-btn color="secondary" @click="dialog = false">キャンセル</v-btn>
        <v-btn color="primary" @click="execute">OK</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>
</template>

<script setup>
import { ref } from 'vue'
const dialog = ref(false)
const execute = () => {
  // 実行処理
  dialog.value = false  // 実行後にダイアログを閉じる
}
</script>
```

こちらではボタンの`@click`で`dialog`を`true`に設定してダイアログを開いています。ダイアログには`persistent`を指定し、キャンセルボタンかOKボタンで明示的に`dialog`を`false`にしない限り閉じないようにしています。OKボタンでは何らかの処理（`execute`関数）を実行した後にダイアログを閉じています。

**パターン3: ネストしたダイアログ** – ダイアログ内からさらに別のダイアログを開くような場合、状態管理が複雑になります。基本的にはそれぞれ別の`v-model`で管理し、必要に応じて一方を閉じてから他方を開く処理を記述します。例えば「詳細」ダイアログ内から「編集」ダイアログを開く場合、詳細ダイアログのボタンで詳細ダイアログを閉じ(`detailDialog = false`)、同時に編集ダイアログのフラグをtrueに設定する、といった対応になります。複数のダイアログが同時に開いてしまうと背面のスクラムが競合するため、基本的には1つずつ開くよう制御するのが安全です。

### 応用テクニック（状態管理・タイミング制御）

* **グローバルなダイアログ管理**: アプリ全体で使う汎用ダイアログを1つ用意し、状態をストア（例えばPiniaやVuexのストア）で管理する方法があります。ストアに`dialogMessage`や`dialogVisible`といった状態を持たせ、任意のコンポーネントからストアを更新してダイアログを開く実装です。App.vueなどに汎用`<v-dialog>`を置き、ストアの状態にバインドしておくことで、どこからでもダイアログを表示できます。このとき、ダイアログに表示する内容（メッセージやボタンの挙動）もストア経由で渡すか、あるいはダイアログ内で`<slot>`や`is`プロパティを使ってコンポーネントを動的に切り替えると柔軟です。
* **コンポーネントAPIを使ったダイアログ**: Vuetify公式ではありませんが、Promiseベースでダイアログの結果を受け取るユーティリティも存在します（例えば`vuetify-dialog-promise`等）。これらを用いると`await`でユーザーの選択結果を待つようなコードが書けます。自作する場合は上記ストア管理を応用し、`confirm()`関数呼び出しで内部的にストアの`dialogVisible`をtrueにして、OK/キャンセルでPromiseをresolve/rejectする、といった実装になります。
* **開いた際にフォーカスを当てる**: ダイアログを開いた直後に特定の入力フィールドにフォーカスを当てたい場合、`v-dialog`には自動フォーカス制御の機能はないため、自前で対応します。手順としては、対象の入力に`ref`を付け、ダイアログの`@update:modelValue`でtrue（表示された）を受け取った際に`nextTick`でその入力に対して`focus()`を呼ぶ方法があります。またはダイアログ内コンポーネントのマウント完了を`mounted`フックで検知しフォーカスすることもできます。
* **Teleporation先の変更**: `v-dialog`は内部的にポータル（Teleport）で描画され、通常はアプリ直下に挿入されます。`attach`プロパティ（もしくは`teleport`プロパティ）を使用すると、ダイアログのコンテンツ描画先を指定可能です。例えば`attach="#modals"`とすると、`id="modals"`の要素内にダイアログDOMが挿入されます。特殊なレイアウトで特定の要素内にダイアログを収めたい場合や、逆に親要素のCSSによる制約（overflowやz-index）を避けるためにbody直下に強制的に描画したい場合に有用です。
* **表示タイミングの調整**: 複数のダイアログを順次表示する場合や、ページ遷移直後に自動的にダイアログを表示する場合、タイミングの工夫が必要です。例えばページロード時にモーダルを出す場合、親コンポーネントのmountedフック内で`dialog = true`とするだけでなく、場合によっては`nextTick`や`setTimeout`で僅かに遅延させると確実に表示できることがあります（初期描画と競合しないようにするため）。

### よくある落とし穴や注意点

* **ダイアログを閉じ忘れる**: persistentを付けたダイアログは外部クリックで閉じないため、必ずキャンセルや閉じる操作を用意しておく必要があります。閉じるボタンの実装を忘れるとユーザーが閉じられなくなります。また、非persistentの場合も、確認ダイアログなどユーザーの応答を待つ用途では勝手に閉じると困るため、用途に応じてpersistentを適切に設定してください。
* **複数ダイアログの競合**: 画面上に複数のダイアログを同時に表示すると、背面のスクラムやESCキー操作が競合する場合があります。基本的には一度に1つのダイアログに限定し、別のダイアログを開くときは既存のものを閉じるようにしましょう（必要なら前述の状態管理テクニックで自動的に一つだけ開くよう制御する）。特にダイアログ内から別のダイアログを開く際は順序に注意が必要です。
* **ラップせずにactivatorを使った場合の注意**: activatorに要素のセレクタ文字列（例: "#myBtn"）を指定する方法では、その要素が存在しない場合や後でDOMに追加される場合に機能しません。また、activatorで指定した要素には自動で`aria-haspopup="dialog"`や`aria-expanded`属性が付与されますが、自前で実装する場合はアクセシビリティ属性も考慮してください。
* **スタイルの干渉**: ダイアログの内容が親要素のCSS（特にpositionやoverflow）によって一部隠れてしまうケースがあります。Vuetify 3ではダイアログはポータル描画されるため基本的に画面全体を覆いますが、念のため親要素に`position: relative; overflow: visible;`でないと見切れる可能性に注意しましょう。問題が発生する場合、前述のattachプロパティで`attach="body"`とすると直下に描画され干渉を避けられます。
* **スクロール関連**: ダイアログ表示中は基本的に背景ページのスクロールは抑制されます。内容が長くなる場合は`scrollable`を使ってダイアログ内スクロールにするべきですが、もし指定しないで長大コンテンツを表示すると画面からはみ出した部分が見えなくなる恐れがあります。また、モバイルデバイスでfullscreenダイアログを使う場合でも、内部コンテンツがあふれる場合は個別にCSSを調整してスクロール可能にする必要があります。

---

## スナックバー（v-snackbar）

### 基本説明と主な用途

v-snackbarコンポーネントは、ユーザーに短いメッセージを一時的に通知するためのポップアップです。アプリの処理結果（例: 保存成功、エラーメッセージなど）を画面の隅に数秒間表示してフィードバックを提供します。スナックバーは位置を画面下部や上部に指定でき、一定時間経過後に自動的に消えるのが特徴です。ユーザーの操作を妨げない軽量な通知手段として、フォーム送信後の完了メッセージ、Undo操作の提供、ネットワークエラーの通知などに汎用的に使われます。

### 主な Props 一覧

* **v-model** (Boolean) – スナックバーの表示/非表示を制御します。`true`で表示開始、`false`で非表示（もしくは閉じる）状態となります。例えば、フォーム送信成功時に`snackbar=true`とし、一定時間後に`false`に戻すことでスナックバーを表示できます。
* **timeout** (Number) – 自動的にスナックバーを非表示にするまでの待機時間（ミリ秒）です。デフォルトは 5000ms（5秒）程度に設定されています。`timeout="3000"`のように指定すると約3秒で閉じ、`:timeout="-1"`とすると自動で閉じなくなります（ユーザー操作で閉じるまで表示されたまま）といった制御が可能です。**注意:** Vuetify 3では`timeout`値を変更すると内部のタイマーがリセットされ、常に最新の値でカウントダウンし直す仕様です。
* **location** (String) – スナックバーの表示位置を指定します。例えば`"bottom"`（画面下部）や`"top"`（画面上部）を指定できます。さらに左右の位置指定として`"start"`（左）や`"end"`（右）を含めることもでき、例えば`location="top end"`とすると画面右上に表示されます。指定しない場合はデフォルトの位置（通常は画面下部中央または下部左寄せ）に表示されます。
  （※Vuetify 3.8以降では複数のスナックバーを扱う際に便利な`v-snackbar-queue`コンポーネントが追加されており、自動で位置を調整しつつ順番にメッセージを表示できます。）
* **color** (String) – スナックバーの背景色を設定します（文字色は自動で適切に選択されます）。たとえば`color="red"`や`color="success"`のようにVuetifyのテーマカラーや任意の色コードを指定可能です。デフォルトではテーマの`surface`カラー（通常は暗めのグレー）となっています。状況に応じて成功時は緑、エラー時は赤など色分けすると視認性が高まります。
* **multi-line** (Boolean) – スナックバーの高さを拡張し、複数行のテキストを表示できるようにします。通常、スナックバーは1行程度の高さですが、`multi-line`を有効にするとテキストを折り返して複数行にわたって表示します。テキスト量が多い場合や画面横幅が狭いモバイル環境で役立ちます。
* **vertical** (Boolean) – スナックバー内のコンテンツ配置を縦方向にスタックします。具体的には、メッセージとアクション（ボタン）が上下に並ぶレイアウトになります。`multi-line`テキストを表示する際、デフォルトではテキストとボタンが横並びになるためレイアウトが崩れることがありますが、`vertical`を指定するとボタンが下側に配置され見やすくなります。(`vertical`と`multi-line`は併用されることが多いです。)
* **elevation** (Number) – スナックバーの影（シャドウ）の深さを指定します。デフォルトでは適度なElevationが付与されていますが、`elevation="0"`で影を無くしたフラットなデザインに、逆に大きな数値を指定するとより濃い影になります。デザインガイドラインに応じて調整可能です。
* **rounded** (Boolean/String) – スナックバーの角を丸くするかどうか、またはその半径を指定します。`rounded`単独で丸みを付け、`rounded="xl"`などVuetify定義のサイズや具体的なpx値で細かく指定できます。一般的にスナックバーは少し角丸にすることが多いでしょう。
* **text** (Boolean) – **（Vuetify 2からの移行向け）** スナックバーの背景を透明にし、文字色のみを指定の色に適用します。Vuetify 3では非推奨の可能性がありますが、`text`プロップはv-btn等と一貫したスタイル指定用として存在するかもしれません。通常は`color`だけで十分です。
* **timer** (Boolean/String) – **（Vuetify 3.4 新規）** スナックバーの表示残り時間を示すプログレスバーを表示します。`timer=true`で有効になり、既定では青（`info`テーマカラー）色のバーがスナックバー下部に徐々に減少する形で描画されます。文字列で色名（例: `"deep-purple"`）やカラーコードを指定すると、その色のプログレスバーになります。タイマーは`timeout`プロップの値に連動して進行し、スナックバーが閉じるまでの残り時間をユーザーに視覚的に示します。

### 利用可能な Slots

* **default** – スナックバー内に表示するメッセージや任意のコンテンツを指定します。単純なテキストメッセージだけでなく、HTML要素や他のVueコンポーネントを埋め込むことも可能です（ただしあまり複雑なUIを入れるとスナックバーの目的から外れるため注意）。
* **actions** – スナックバーに表示するアクションボタン用のスロットです。通常、スナックバーには「閉じる」や「元に戻す (Undo)」といった短いアクションを配置できます。`v-slot:actions`内に<v-btn>などのボタンを記述すると、スナックバーの右側（またはvertical時は下側）に配置されます。複数のボタンを入れることも可能です。

### 主な Events

* **@update\:modelValue** – スナックバーの表示状態が変化した際に発火します。引数はBooleanで、`false`になったタイミングでスナックバーが閉じられたことを検知できます（タイムアウトやユーザーによる閉じる操作いずれでも）。特別な`@close`イベントなどは用意されていないため、スナックバーが消えたタイミングで何か処理をしたい場合はこのイベントを利用したり、もしくは`watch`でバインド変数を監視します。
* **@click\:outside** – （通常使用しません）スナックバーは他のオーバーレイと異なり、画面の隅に現れる通知であるため「外側クリック」で明示的に閉じるケースはあまりありません。しかし、スナックバー自体は`v-overlay`を継承しているため`@click:outside`イベントは存在します。スナックバーの表示中にユーザーが他の場所をクリックしたことをトリガーに閉じるといった特殊な挙動を実装したい場合に検討します。ただし通常は`timeout`で自動消去するか、アクションボタンで閉じるのが一般的です。

### よくある使用パターンとコード例

**パターン1: 単純な通知メッセージ** – ある操作に対するフィードバックとして短いメッセージを表示し、数秒後に自動で閉じる基本的な使い方です。例えばフォームの保存ボタンを押した後、「保存しました」というスナックバーを表示するケースです。`timeout`を適切に設定することで自動的に消えるようにし、必要ならユーザーが即座に閉じられるよう「閉じる」ボタンも付けます。

```vue
<template>
  <v-btn color="primary" @click="showSnackbar">データを保存</v-btn>

  <v-snackbar v-model="snack.visible" :color="snack.color" :timeout="snack.timeout" :location="snack.location">
    {{ snack.message }}
    <template #actions>
      <v-btn text @click="snack.visible = false">閉じる</v-btn>
    </template>
  </v-snackbar>
</template>

<script setup>
import { reactive } from 'vue'
const snack = reactive({
  visible: false,
  message: '',
  color: 'grey-darken-3',
  timeout: 3000,
  location: 'bottom'
})
const showSnackbar = () => {
  snack.message = '保存しました'
  snack.color = 'green'
  snack.timeout = 5000
  snack.visible = true  // スナックバー表示
}
</script>
```

上記ではボタン押下時に`snack`オブジェクトの各種プロパティを設定し、`visible`（v-modelでバインド）がtrueになることでスナックバーが表示されます。`timeout`を5秒に設定しているため、5秒後に自動で`visible`がfalseとなりスナックバーが消えます。また、ユーザーがすぐ閉じたい場合のために「閉じる」ボタン（テキストスタイルのv-btn）を`actions`スロットに配置しています。なお、`location="bottom"`としているので画面下部に表示されます（デフォルトも下部中央です）。

**パターン2: エラーメッセージやUNDO操作** – スナックバーはエラー通知や「取り消し(Undo)」操作の提供によく使われます。例えば削除ボタン押下時に「アイテムを削除しました。取り消す?»というメッセージを出し、`actions`に「元に戻す」ボタンを配置するケースです。ユーザーがすぐにUndoを押せるよう、`timeout`をやや長め（例えば10000ms）に設定し、押したらスナックバーを閉じて実際のUndo処理を実行します。また、エラーの場合は`color="red"`にして視覚的に注意喚起するなど工夫します。

**パターン3: 複数メッセージのキューイング** – 迅速に連続して複数の通知を出す必要がある場合、`v-snackbar-queue`コンポーネントを活用できます。Vuetify 3.8から正式に利用可能になった機能で、内部にキュー（配列）を持ち順番にスナックバーを表示します。または自前で実装する場合、例えば配列`messages`にメッセージオブジェクトを溜め、先頭を表示→一定時間後に削除→次を表示、という処理をタイマーと組み合わせて行います。複数のスナックバーを同時に表示すると重なって読めなくなるので、このように一つずつ表示するのが基本です。

### 応用テクニック（状態管理・タイミング制御）

* **グローバル通知機能の実装**: スナックバーはアプリ全域で使う「グローバルな通知」として実装されることが多いです。Piniaなどで状態`snackbar`を管理し、どのコンポーネントからでも`store.snackbar.show(message, options)`のように呼び出せるユーティリティ関数を用意します。内部で`v-snackbar`と紐付いた状態（メッセージ、色、表示フラグ等）を更新することで画面上に通知が出る仕組みです。この際、連続表示に対するキュー処理もまとめて実装しておくと便利です。
* **表示継続時間の調整**: `timeout`プロップで表示時間を調整できますが、ユーザーがマウスオーバーしている間は消えないようにしたい場合があります。その場合、スナックバーに`@mouseenter="延長処理"`と`@mouseleave="再開処理"`を付け、ホバー時に一時的に`timeout`を停止または延長する工夫も可能です。ただしVuetify標準ではそこまで細かな制御は提供されていないため、必要ならカスタムで実装します（例えばホバー時は`timeout=-1`に変更し、離れたら残り時間を計算して再設定する等）。
* **レスポンシブな位置変更**: モバイル画面などでは下部にナビゲーションバーがある場合、スナックバーがそれと重なってしまうことがあります。Vuetifyでは自動では避けてくれないため、自分でブレークポイントに応じて`location`やスタイルを変更します。例えば`$vuetify.display.smAndDown`を使ってモバイルでは`location="top"`に切り替える、あるいはスナックバーに`style="margin-bottom: 56px"`（ナビ分の高さ）を当てるなどの対策があります。
* **カスタムトランジション**: Vuetify 3のスナックバーは標準トランジションが設定されていますが、独自のアニメーションを付けたい場合は`transition`プロップにVueのトランジション名を指定し、対応するCSSを用意します。例えばフェードインだけにしたい場合`transition="fade-transition"`とし、自前で`.fade-transition-enter-active`などのCSSを定義します（Vuetifyの組み込みトランジションも利用可）。一部Vuetifyのバージョンではトランジションが正しく動作しない不具合も報告されていましたが、`eager`プロップを付けて遅延マウントを避けることで改善することがあります。

### よくある落とし穴や注意点

* **表示されない/すぐ消える**: `v-snackbar`を使用する際によくあるミスは、`v-model`に渡す変数を用意していない、もしくはfalseのままにしていることです。ボタンをクリックしても`snackbar=true`にする処理を入れ忘れると表示されません。また、`timeout`を0や極端に短い値にすると一瞬で閉じてしまいユーザーが認識できない可能性があります。意図的に0（自動閉じなし）にする場合は、閉じるボタンを必ず用意しましょう。
* **重複表示の問題**: 複数のスナックバーを同時に表示すると互いに重なってしまい、どれも読めなくなります。もし複数の通知を並べて表示したいなら、位置をずらすCSSカスタマイズが必要です。しかし推奨はせず、前述のようにキューイングして一つずつ表示するか、どうしても同時複数表示が必要な場合は`location`を使って異なる場所（例: 右下と左下）に出すように調整します。
* **メッセージ更新時の動作**: スナックバー表示中に内容（テキストや色など）を変更した場合、`timeout`タイマーがリセットされることに留意してください。例えば5秒タイマーで表示中に新しいメッセージを同じスナックバーで表示し直すと、そこから再度5秒カウントされます。逆に、短時間で連続して同じスナックバーを使い回すと前のタイマーが継続してしまい意図せずすぐ閉じる、といった問題はVuetify 3では解消されています。この仕様を踏まえ、連続表示する際は同じコンポーネントインスタンスを使い回す方がシンプルです（タイマーは自動リセットされるため）。
* **Undoボタンの実装ミス**: Undo（取り消し）操作をスナックバーで提供する場合、ボタンを押さなかったときに備えて既定の動作を実行する必要があります。例えば「10秒以内にUndoが押されなければ本当に削除する」処理です。これを実現するには、スナックバー表示時にタイマー（`setTimeout`）を仕掛け、10秒後に削除処理を走らせ、Undoボタンが押された場合はそのタイマーをキャンセルするといったパターンになります。スナックバー自体の`timeout`とは別にアプリケーションロジック上のタイマー管理が必要になる点に注意してください。
* **モバイルでの動作**: ホバーをトリガーとするUIであるため、ツールチップ同様スナックバーもモバイルでは挙動が異なります。もっとも、スナックバーはクリック（タップ）で明示的に表示させるものなので、大きな問題にはなりにくいですが、画面幅によってはテキストが長い場合に折り返されてレイアウトが崩れることがあります（verticalプロップの使い忘れなど）。レスポンシブ対応やテキスト長に応じたスタイル調整をテストしましょう。

---

## ツールチップ（v-tooltip）

### 基本説明と主な用途

v-tooltipコンポーネントは、ボタンやアイコンなどにマウスオーバーした際に補足情報の小さな吹き出し（ヒント）を表示するためのコンポーネントです。ユーザーに追加説明を提供したり、アイコンの意味を明示したりする用途で使われます。通常はホバー時に自動表示され、フォーカス時にも表示されるためアクセシビリティ面でも有用です。例えばボタンにツールチップで「保存」とラベルを出す、略語にマウスを当てると完全な単語を表示する、といったケースで利用できます。

### 主な Props 一覧

* **v-model** (Boolean) – ツールチップの表示状態を手動制御するためのバインディングです。通常は指定不要（ホバーやフォーカスで自動表示）ですが、プログラム的にツールチップを表示/非表示したい場合に利用します。`true`で表示、`false`で非表示となります。`open-on-hover=false`かつ`open-on-click=false`に設定した場合、このv-modelによる制御のみで表示できます。
* **text** (String) – ツールチップに表示するテキストを直接指定するプロパティです。簡単なテキストだけ表示する場合、スロットで子要素として書く代わりに`text="説明文"`とすることができます。内部的にはdefaultスロットにその文字列を配置するのと同じ効果になります。
* **activator** (String / Element) – ツールチップの対象となる要素を指定します。`v-dialog`等と同様、`activator="parent"`とするとツールチップ要素の親要素が対象となり、ホバー時にツールチップが表示されます。CSSセレクタ文字列（例: `"#infoIcon"`）を指定して任意の要素をアクティベータにすることもできます（activatorスロットを使わない場合の代替）。Vuetify 3の仕様上、このプロパティで親を指定できるのはボタン、div、span、p等の一部要素に限られます。
* **location** (String) – ツールチップが表示される位置を指定します。例えば`"top"`, `"bottom"`, `"start"`（左）, `"end"`（右）などの値を組み合わせて用います。単一の値の場合、暗黙的に反対方向は中央合わせになります。例: `location="bottom"`ならターゲット要素の下中央に表示、`location="top start"`ならターゲット要素の上左に表示されます。デフォルトでは`bottom`（下中央）です。
  加えて、Vuetifyはツールチップが画面端に収まらない場合に自動で位置を反転させるなどの調整は**基本的に行いません**。必要であればレスポンシブに`location`を切り替えたり、スタイルで微調整してください。
* **open-on-hover** (Boolean) – ホバー時にツールチップを表示するかを指定します。デフォルトは`true`で、マウスオーバーで表示/マウスアウトで非表示となります。`false`にするとホバーでは表示されなくなります。通常、モバイルデバイスではhoverが無いので、自動的にこの挙動は適用されず、代わりにタップで表示する形になります。
* **open-on-click** (Boolean) – クリック時にツールチップを表示するかを指定します。デフォルトは`false`です。`true`にすると、対象要素をクリックした際にツールチップが表示され、もう一度クリックすると非表示になります。モバイルではこのプロパティを有効にすることでタップで明示的にツールチップを開閉させる運用が可能です。なお、open-on-clickを有効にした場合でも、既定では外部をクリックしても自動では閉じない点に注意が必要です（後述のイベントで対応可能）。
* **open-on-focus** (Boolean) – フォーカス時（キーボード操作でターゲットにフォーカスが当たった場合）にツールチップを表示するかを指定します。デフォルトは`true`で、キーボードユーザーにもヒントを提供します。`false`にするとフォーカス時に表示されなくなりますが、アクセシビリティの観点から無効にする理由はあまりないでしょう。
* **close-delay** / **open-delay** (Number) – ツールチップを非表示/表示するまでの遅延時間をミリ秒で指定します。`open-delay`を例えば500にすると、ホバーしてから0.5秒経過しないと表示されません。`close-delay`も同様に指定できます。ホバーが一瞬当たっただけで出てほしくない場合や、ホバーアウト時にすぐ消えると読めない場合に、これらの値を調整してユーザー体験を向上させます。
* **persistent** (Boolean) – ツールチップ表示中に他の場所をクリックしても自動では閉じないようにします。通常、open-on-clickで開いたツールチップは再度クリックするまで表示されたままですが、persistentを付けると明示的に閉じるまで表示を維持します（デフォルトではツールチップにフォーカスが移ると外部クリックでも閉じませんので、このプロパティの効果は限定的です）。むしろツールチップの場合、open-on-click時に外部クリックで閉じてほしい場面が多いですが、その際は次のイベント処理が必要です。
* **theme** (String) – Vuetifyのテーマ切替用プロパティです。`light`または`dark`を指定してコンポーネント単位でテーマを強制できます。通常は継承されるため指定は不要です。ツールチップの見た目（背景が暗めでテキストが白等）はテーマにより自動決定されます。

### 利用可能な Slots

* **default** – ツールチップに表示する内容を定義します。典型的には単なるテキストを直接記述しますが、必要に応じてHTML構造や他のコンポーネントも配置できます（アイコンや画像を含めるなど）。ただし内容が複雑になると視認性に影響するため、基本は短いテキストに留めるのが望ましいです。
* **activator** – ツールチップの対象要素を明示的に指定するスロットです。他のコンポーネントと同様に、スロットスコープ引数から`props`（または`on`,`attrs`）を取り出し、ターゲット要素に`v-bind`と`v-on`で付与します。activatorプロパティを使わない場合にこのスロットを使用します。例として、ツールチップを特定のアイコンに対して適用したい場合に`<v-tooltip> <template #activator="{ props }"><v-icon v-bind="props">...</v-icon></template> ... </v-tooltip>`のように書きます。

### 主な Events

* **@update\:modelValue** – ツールチップの表示状態が変化した際に発火します。手動でv-model制御している場合や、open-on-clickでトグル動作させている場合に、このイベントで表示/非表示のタイミングを捉えることができます。
* **@click\:outside** – ツールチップ表示中に、ツールチップ本体およびそのターゲット要素以外の場所がクリックされた際に発火します。特に`open-on-click`を有効にしている場合、デフォルトでは外をクリックしても閉じませんが、このイベントを利用して明示的に`v-model`の値をfalseにすることで、外部クリックでツールチップを閉じる実装が可能です。例: `<v-tooltip v-model="showTip" open-on-click :open-on-hover="false" @click:outside="showTip=false">...</v-tooltip>`.
* **@mouseenter** / **@mouseleave** – activator要素上でのマウスエンター/リーブをキャッチしたい場合に使います。通常これらはVuetify内部でハンドルされツールチップの開閉に使われていますが、カスタム動作を追加したい場合に利用可能です（例えばログを取るなど）。イベントハンドラ内で`event.stopPropagation()`すると既定の挙動に影響する可能性があるため注意が必要です。

### よくある使用パターンとコード例

**パターン1: アイコンに対するツールチップ** – 情報アイコンやヘルプアイコンにマウスを乗せると説明文を表示する基本的な例です。Vuetifyでは`v-btn`コンポーネント（アイコンボタン）を使ってアイコンを表示することが多いため、その中に`v-tooltip activator="parent"`を配置するのがシンプルです。

```vue
<template>
  <v-btn icon>
    <v-icon>mdi-help-circle</v-icon>
    <v-tooltip activator="parent" location="top">
      これを押すとヘルプを表示します
    </v-tooltip>
  </v-btn>
</template>
```

上記では、アイコンボタンの親子関係にツールチップを配置し`activator="parent"`とすることで、そのボタンに対してホバーするとツールチップが表示されます。locationを`"top"`にしているため、ボタンの上側に吹き出しが表示されます。ユーザーがボタンにフォーカスを当てた場合（Tabキーで移動など）も同様に表示されます。

**パターン2: テキストに対するツールチップ** – 文章中の専門用語や略語に対して、マウスを重ねると説明を出すケースです。`<span>`や`<div>`で対象テキストを囲み、その中にツールチップコンポーネントを配置して親要素をactivatorに指定します。例えば「SQL」という文字にカーソルを当てると「Structured Query Language」と表示するような実装です。

```vue
<template>
  <p>
    このデータベースには 
    <span class="has-tooltip">
      SQL
      <v-tooltip activator="parent" location="bottom">
        Structured Query Language の略
      </v-tooltip>
    </span>
    を使用しています。
  </p>
</template>
```

このように書くと、「SQL」の部分にホバーしたときだけツールチップが表示されます。Spanにクラス`.has-tooltip`を付けていますが、これはスタイル調整用で必須ではありません。なお、inline要素でも問題なく動作しますが、親子関係がしっかり構築されていないと機能しない点に注意しましょう（上記のように直近の親子であればOK）。

**パターン3: クリックで表示するツールチップ** – モバイル端末向けなど、ホバーできない環境ではクリック（タップ）でツールチップを表示させる運用も考えられます。例えばテーブルのセルをタップすると詳細情報のツールチップを出し、もう一度タップすると消える、といったケースです。実装には`open-on-click`を利用します。また、外部をタップしたら消したい場合は前述の`@click:outside`イベントで対応します。以下は簡単な例です。

```vue
<template>
  <v-btn @click="showTip = !showTip">現在の状態</v-btn>
  <v-tooltip v-model="showTip" open-on-click :open-on-hover="false" location="bottom">
    データは最新です（クリックで閉じる）
  </v-tooltip>
</template>

<script setup>
import { ref } from 'vue'
const showTip = ref(false)
</script>
```

この例ではボタンをクリックすると`showTip`がtrueになりツールチップが表示されます。open-on-clickをtrueにしているため、本来ならボタン自体のクリックでトグルされるところですが、あえて`open-on-hover="false"`とし、自前で制御しています。こうすることで、再度ボタンをクリックした時や他の場所をクリックした時にも`showTip`を操作する自由度があります（単純なopen-on-click=trueの場合、Activatarボタンのクリックだけで開閉するため細かな挙動制御が難しいためです）。モバイルではこのようにクリック（タップ）ベースのツールチップ表示を検討すると良いでしょう。

### 応用テクニック（状態管理やタイミング制御の工夫）

* **複数ターゲットへの同一ツールチップ**: 特定のツールチップ内容を複数要素で共有したい場合、activatorプロパティに共通のセレクタを指定することで可能です。ただし通常は要素ごとにツールチップを定義する方がシンプルです。もし一つのコンポーネントインスタンスで複数のターゲットに対応させたい場合、カスタム指令（自作のv-tooltipディレクティブ）を利用して汎用化する方法も考えられます。
* **ディレクティブによる使用**: Vuetify 2では`v-tooltip`ディレクティブが提供されていましたが、Vuetify 3ではコンポーネントのみになっています。ディレクティブ風に使いたい場合、自前でホバー時に要素を追従するコンポーネントを表示するdirectiveを作成することも可能ですが、かなり高度な実装になります（位置計算やスクロール対応など）。
* **ツールチップのスタイル変更**: デフォルトでは濃いグレーの背景に白文字のスタイルですが、カスタムCSSで`.v-tooltip`や内部の`.v-overlay__content`をターゲットにスタイルを上書きできます。例えばCSSで`.v-tooltip.v-overlay--active .v-overlay__content { background-color: blue; }`のように指定すれば背景を青に変更できます。ただしVuetifyのテーマ機能を活用し、`class="bg-blue white--text"`をツールチップコンポーネントに付ける方法もあります。tooltip自体には`color`プロップがないため、手軽な色変更はテキストのみ（テーマに依存）となりますが、上述の`class`指定で対応可能です。
* **disabled状態への対応**: ボタンが`disabled`になっている場合、その要素にはホバーイベントが発生しません（ポインターイベントが無効化されるため）。このため、無効化されたボタンに対してツールチップを表示したい場合は一工夫必要です。典型的には、そのボタンをラップする`<div>`を作り、そのdivにツールチップを適用します。ボタン自体にはマウスイベントが伝わらないものの、親のdivには伝わるためツールチップが表示できます。スタイル的にボタンとピッタリ重ねるために`position: relative`なラップ要素を用意し、その中にdisabledボタンとツールチップコンポーネントを配置する、といった方法です。
* **大量のツールチップのパフォーマンス**: ツールチップを多用する場合、例えば長いリストの各行にアイコン+ツールチップがあるようなケースでは、非表示時でもそれぞれが`v-overlay`として存在するため若干性能に影響があります。必要に応じてスクロールに応じた遅延描画（表示領域内のみ生成）を検討してください。ただし数十個程度であれば問題になるケースは少ないでしょう。

### よくある落とし穴や注意点

* **モバイルデバイスでの挙動**: ツールチップは本質的にマウスホバー主体のUIなので、タッチデバイスでは扱いにくい点に注意が必要です。特にopen-on-hoverがデフォルト有効なため、タップしてもすぐには表示されず、「長押し」扱いでようやく表示されることがあります。しかし長押しは別途ブラウザのコンテキストメニュー動作と競合する可能性があり、ユーザビリティが低下します。解決策として、モバイル判定時には代わりにopen-on-clickを有効にし、タップで表示・タップ外で非表示にする（先述のパターン3）など運用を切り替えることが多いです。場合によってはモバイルではツールチップ自体を非表示にする（代替手段を用意する）選択もあります。
* **activatorの指定ミス**: `activator="parent"`を指定する場合、必ずツールチップコンポーネントをターゲット要素の直下の子要素として配置してください。親子関係が成り立っていないと機能しません。同様に、activatorにセレクタ文字列を使う場合は、その要素が確実に存在しユニークであることを確認しましょう。セレクタに該当する要素がないとツールチップは表示されません。
* **外部クリックで閉じない**: open-on-clickでツールチップを使用した場合、ユーザーがツールチップ以外の場所をクリックしてもそのまま表示され続ける点に注意が必要です。対策として前述した`@click:outside`イベントで明示的に閉じる処理を入れることが望ましいです。そうしないと、ユーザーが別の操作を始めてもツールチップが画面に残り続け、邪魔になる可能性があります。
* **表示内容が長すぎる**: ツールチップの内容が長文になりすぎると、ユーザーが読み切る前にマウスが外れて消えてしまったり、画面端で見切れたりします。ツールチップはあくまで短い補足に留め、詳細な説明が必要な場合は代わりにモーダルダイアログや説明用の別UIを検討した方が良いでしょう。どうしても長文を入れる場合、`close-delay`を長めに設定し、ユーザーが外れたあともしばらく表示を残すなどの工夫が必要です。
* **重複表示の注意**: 近接した要素に複数のツールチップを配置している場合、マウスが移動する際に次々とツールチップが現れ、「点滅」するように感じられることがあります。ユーザー体験を損なわないよう、レイアウト上あまりツールチップを乱用しすぎないことも重要です。また、ツールチップが開いている間に別のツールチップを開くと前のものは自動で閉じます（同時に複数のツールチップは表示されない設計）ので、一度に一つしか表示されないとはいえ、短時間に連続して切り替わる状況は避けるのが無難です。
