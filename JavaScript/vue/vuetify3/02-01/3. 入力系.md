了解しました。Vuetify 3 の入力系コンポーネント（v-text-field、v-select、v-form）について、前回と同様の形式で研究テンプレートを作成します。特に v-select は動的セレクトに注目して調査を進めます。

調査完了後に順次ご報告いたしますので、しばらくお待ちください。


# Vuetify 3 の入力コンポーネント研究テンプレート

## v-text-field（テキストフィールド）

### 基本説明と主な用途

`v-text-field`はテキスト入力用の基本コンポーネントで、`v-input`と`v-field`を組み合わせた多用途なフィールドです。ユーザーに一行の文字入力を提供し、フォームやダイアログで広く使われます。例えば名前やメールアドレス、パスワードなどの入力に利用できます。ラベルやプレースホルダ、各種アイコン、バリデーション表示など多数の機能を備えており、見た目のバリエーションも柔軟に変更できます。

### 主な Props 一覧

* **model-value / v-model** (`any`型): 入力のバインド値です。ユーザーの入力内容がここに反映されます（双方向バインディング）。文字列として扱われる点に注意してください（詳細は後述）。
* **label** (`string`型): フィールド上部に表示されるラベルテキスト。未入力時はフィールド内に表示され、入力時またはフォーカス時に上に浮かび上がるラベルとなります。
* **placeholder** (`string`型): 入力フィールド内に表示するヒントテキスト。入力が空の間だけ表示され、入力されると消えます。
* **type** (`string`型): HTMLの`<input>`タイプを指定します（例: `"text"`・`"password"`・`"email"`・`"number"`など）。ただし`type="number"`にしてもバインド値は文字列として扱われます（後述の注意点参照）。
* **variant** (`string`型): 見た目のバリエーションを指定します。 `"outlined"`（枠線あり）、`"underlined"`（下線のみ）などが利用でき、未指定時はデフォルトの塗りつぶしスタイル（**filled**）になります。例えば`variant="underlined"`なら下線のみのシンプルなスタイル、`variant="outlined"`なら枠で囲まれたスタイルになります。
* **clearable** (`boolean`型): `true`にすると入力内容を消去するクリアアイコン（✕）が表示されます。クリアアイコンはデフォルトで`$vuetify.icons.clear`の設定（通常はmdi-clear）になっており、**clear-icon**プロップで変更可能です。
* **prefix** / **suffix** (`string`型): 入力欄内の先頭または末尾に表示する固定文字列を指定します。ユーザーがテキスト入力を開始すると、その文字列が入力内容の前後に表示されます。例えば通貨記号や単位を表示する用途に便利です（※表示のみで実際の入力値には含まれません）。
* **prepend-icon** / **append-icon** / **append-outer-icon** (`string`型): 入力フィールドの内側左端・内側右端・外側右端に表示するアイコンを指定します（Material Iconsや自前のmdiアイコン名を文字列で指定）。例えば`prepend-icon="mdi-magnify"`のようにするとテキストフィールドの左側に検索アイコンが表示されます。 これらのアイコンはユーザーがクリック可能で、クリック時に後述のイベントが発火します。
* **disabled** (`boolean`型): `true`にすると入力を無効化し、ユーザーは編集できなくなります。スタイル的には淡色になりクリックできない状態になります。
* **readonly** (`boolean`型): `true`にすると入力値の表示はできますが編集はできません（フォーム送信時には値は送出）。ユーザーからの入力を禁止しつつ値だけ見せたい場合に利用します。
* **rules** (`Array`): 入力値のバリデーション用関数や条件を配列で渡します。各要素は現在の値を引数に取り、`true`（または何も返さない）なら検証成功、エラーメッセージ文字列なら検証失敗とみなされます。複数ルールを指定すると全てチェックされ、失敗した最初のルールのメッセージが表示されます。
* **error** / **error-messages** (`boolean` または `string/string[]`): 手動でエラー状態を制御するためのプロップです。`error`を`true`にすると強制的にエラースタイル（赤枠など）になります。`error-messages`に文字列または文字列配列を渡すと、`rules`によらずそのメッセージをエラーとして表示します。
* **counter** (`number|string`): 文字カウンタを表示します。数値を指定すると「現在の文字数/最大値」の形式で入力文字数を表示します（カウンタ自体は文字数制限を強制はせず表示のみ行います）。例: `counter="20"`とすると「0/20」のように表示され、入力が増えると「5/20」のようにリアルタイム更新されます。
* **hint** (`string`): 入力フィールドの下部に表示する補足テキスト。フォーカス時に表示され、ユーザーに追加説明を与える用途に使われます。`persistent-hint`（`boolean`）を併用すると未フォーカス時でもヒントを常時表示します。デフォルトではフォーカスを外すとヒントは消えます。
* **messages** (`string|string[]`): 常に表示するメッセージを指定します。エラーではないがユーザーに伝えたい補足情報やヒントを、フォーカス状態に関係なく表示したい場合に使います。文字列配列で複数行表示も可能です。`error-messages`との併用に注意してください（`error-messages`が優先されます）。
* **hide-details** (`boolean`または`"auto"`): メッセージやヒント表示部分（詳細部分）を非表示にします。`true`なら常に隠し、`"auto"`なら表示すべきメッセージがない時に自動で隠します。例えば縦の余白を詰めてコンパクトにしたいときに`hide-details="auto"`を指定します。
* **loading** (`boolean`型): `true`にするとフィールドにロード中状態のインジケータを表示します。既定ではテキストフィールド右端に小さな直線のローディングバーが表示されます（デフォルトスロットを使用してカスタムローダーに差し替え可能）。
* **density** (`string`型): コンポーネントの高さ（密度）を調整します。`"comfortable"`や`"compact"`を指定するとフィールドの高さが低くなり、フォームをコンパクトにできます（デフォルトは`"default"`で標準の高さ）。

### 利用可能な Slots

* **default** スロット: テキストフィールドの中身をカスタマイズするためのスロットです。通常は使用しませんが、このスロットに独自の入力要素を入れると、v-text-field標準の入力と置き換えることも可能です（高度な用途）。例えば特殊な入力UIを埋め込む場合に使います。
* **label** スロット: `<template #label>`でラベル部分をカスタマイズできます。プレーンなテキストではなくアイコン付きのラベルや装飾をしたい場合に利用します。デフォルトでは`label`プロップの文字列が表示されますが、このスロットを使うとHTMLを含めた自由な内容をラベルとして表示可能です。
* **prepend** / **append** / **append-outer** スロット: 対応する位置に表示するコンテンツをカスタムするスロットです。`prepend`はフィールド内の先頭、`append`はフィールド内の最後尾、`append-outer`はフィールドの外側右端（通常はクリアボタンやメニュー開閉ボタンが来る位置）にあたります。それぞれ対応する`...-icon`プロップより高度なカスタムが可能です。例えば`prepend`スロットにカレンダーアイコン用の`v-icon`コンポーネントを置いてクリック時に日付ピッカーを表示するといった用途があります。
* **counter** スロット: 文字数カウンタ部分をカスタマイズできます。標準では`counter`プロップで指定した形式で文字数/最大数が表示されますが、このスロットを用いて独自の表示（例: 単位付きの文字数など）に変更できます。
* **details** スロット: 入力フィールド下部のメッセージ表示部分をまとめて差し替えるスロットです。エラーメッセージやヒントの表示領域全体を自前のレイアウトや内容に変えたい場合に利用します。

### 主な Events

* **@update\:modelValue**: ユーザー入力によりバインド値が変更されたときに発火します。引数として新しい入力値（文字列）が渡されます。これはVueの`v-model`の仕組みに対応するイベントで、内部では入力の`input`イベントに相当します。
* **@click\:prepend** / **@click\:append** / **@click\:append-outer**: 対応するアイコン（またはスロット部分）がクリックされたときに発火します。例えば`prepend-icon`を設定している場合、ユーザーがそのアイコンをクリックすると`click:prepend`イベントが発生します。これらのイベントは**アイコンをプロップで指定している場合のみ**有効で、スロットでカスタムした場合は発火しない点に注意が必要です。
* **@click\:clear**: `clearable`プロップによって表示されるクリア（✕）ボタンがクリックされ、入力内容がクリアされると発火します。クリア操作に対して追加の処理をしたい場合に利用できます（※クリア自体は内部で自動処理されます）。
* **@focus** / **@blur**: フィールドにフォーカスが当たった時、およびフォーカスが外れた時に発火します。通常明示的にドキュメントされていませんが、`<input>`要素のネイティブイベントがバブリングしてきます。特別な実装をしなくても`<v-text-field @focus="...">`でフォーカスイベントをキャッチ可能です。\*\*（注）\*\*Vuetify 3では`.native`修飾子は不要です。
* **@keydown** / **@keypress** / **@keyup**: キーボードイベントも同様にネイティブイベントが発火します。Enterキー検知などに使えます。ただしEnterキーでフォーム送信する場合は後述のv-formの仕組みを使う方が一般的です。

### よくある使用パターンとコード例

* **基本的なテキスト入力**: 最もシンプルな利用方法は`v-model`でデータとバインドすることです。例えばユーザーが入力した名前を即時にデータに反映するには以下のように書きます。

  ```vue
  <template>
    <v-text-field label="名前" v-model="userName" placeholder="お名前を入力してください" />
    <div>こんにちは、{{ userName }} さん！</div>
  </template>
  <script setup>
  import { ref } from 'vue';
  const userName = ref('');
  </script>
  ```

  上記ではテキストフィールドに文字を入力すると`userName`に即時反映され、下の挨拶文にもリアクティブに表示されます。

* **必須入力やバリデーションの利用**: `rules`プロップに関数を設定して入力内容を検証できます。例えば「必須入力」のルールと「文字数は5文字以上」のルールを設定した例です。

  ```vue
  <v-text-field
    label="ユーザーID"
    v-model="userId"
    :rules="[v => !!v || '必須項目です', v => v.length >= 5 || '5文字以上必要です']"
    counter="5"
    outlined
    required
  />
  ```

  ルール配列内の最初の関数`v => !!v || '必須項目です'`は値が空ならエラーメッセージを返し、そうでなければtrueを返します。二つ目は長さチェックです。`required`属性を併用するとアクセシビリティ的にも必須フィールドであることがマークアップ上明示されます。`counter="5"`により現在の入力文字数/5 が表示されます（5を超えるとカウンタは赤色になります）。

* **プレフィックス/サフィックスの利用**: 入力値に単位や定型文字を付与する場合、`prefix`や`suffix`が便利です。

  ```vue
  <v-text-field
    label="金額"
    v-model="price"
    prefix="￥"
    suffix="円"
    type="number"
  />
  ```

  上記フィールドでは、常に入力欄の左に「￥」記号、右に「円」という単位が表示されます。ユーザーが数値を入力すると例えば「￥1234円」のように見えますが、`price`に入るのは`"1234"`という文字列のみです（￥や円は含まれません）。

* **アイコンの活用**: 検索ボックスなどではテキストフィールドにアイコンを入れると分かりやすくなります。例えば先頭に検索アイコン、末尾にクリアボタンを持つフィールドは次のように実装できます。

  ```vue
  <v-text-field
    v-model="keyword"
    label="キーワード検索"
    prepend-icon="mdi-magnify"
    clearable
    @click:prepend="onSearch"  <!-- prependのアイコンクリックで検索実行 -->
  />
  ```

  `prepend-icon`で虫眼鏡アイコンを表示し、そのクリックイベント（`click:prepend`）で検索処理`onSearch`を呼び出しています。`clearable`により入力があればクリア✕アイコンが表示され、クリックで`keyword`が空になります。

* **フォーム内でのEnterキー送信**: 単一の`v-text-field`でEnterキー押下時に処理をしたい場合は、`v-form`と組み合わせる方法が一般的です（詳細は後述のv-form参照）。例えば以下のようにフォームで囲んでEnterキー送信をハンドリングできます。

  ```vue
  <v-form @submit.prevent="sendMessage">
    <v-text-field v-model="message" label="メッセージを入力" />
    <v-btn type="submit">送信</v-btn>
  </v-form>
  ```

  これでテキストフィールドにフォーカス中にEnterを押すか送信ボタンを押すと`sendMessage`メソッドが呼ばれ、`@submit.prevent`によりページリロードを防いでSPA内で処理できます。

### 応用テクニック

* **パスワード入力の表示切替**: パスワード入力欄で「表示/非表示」をトグルするのは典型的なユースケースです。`append-icon`とイベントを活用して次のように実装できます。

  ```vue
  <v-text-field
    v-model="password"
    label="パスワード"
    :type="showPwd ? 'text' : 'password'"
    :append-icon="showPwd ? 'mdi-eye-off' : 'mdi-eye'"
    @click:append="showPwd = !showPwd"
    placeholder="パスワードを入力"
  />
  ```

  データに`showPwd: false`を用意しておき、クリックでtrue/falseを反転しています。`showPwd`が`true`なら入力タイプをテキストに、そうでなければパスワード隠しにし、アイコンも切り替えています。これにより目のアイコンを押すたびにパスワードの可視化をトグルできます。

* **入力内容に応じた動的スタイル**: スロットやリアクティブバインディングを使えば入力内容に応じて見た目を変えることも可能です。例えばプレースホルダを動的に変更したり、suffixに動的値を表示することもできます。以下は入力値が変化するとsuffixに残り文字数を表示する例です。

  ```vue
  <v-text-field
    v-model="text"
    label="コメント"
    :suffix="`${100 - text.length}文字残り`"
    :counter="100"
    :rules="[v => v.length <= 100 || '100文字以内です']"
  />
  ```

  このようにプレースホルダやsuffixにテンプレートリテラルをバインドすると、データに応じて即時に表示内容が変わります。

* **高度なカスタム（入力要素の差し替えなど）**: `v-text-field`の`default`スロットに独自の入力要素を入れると、標準のテキストボックスを丸ごと置き換えることができます。例えばモノスペースフォントのエディタ（Monaco Editorなど）をフィールド内に埋め込みつつ、Vuetifyのフォーム制御だけ利用する、といった高度なコンポーネントを作れます。この場合、自前でフォーカスや値の受け渡しを制御する必要がありますが、Vuetifyのレイアウト・ラベル表示ロジックを再利用できます。

### よくある落とし穴や注意点

* **カラー指定が反映されない**: `v-text-field`では直接`color`プロップでテキストやボーダーの色を変更できない場合があります。Vuetify 3では親要素のテーマや背景色に応じて入力フィールドのラベルや下線の色が自動決定される仕組みのため、`color="red"`のように指定しても期待通りにはならないことがあります。例えば背景がダークの場合、自動でラベル等が明色になります。独自の色を強制したい場合は、クラスを当ててCSSで指定する必要があります。
* **数値入力の型に関する誤解**: `<v-text-field type="number">`とすると数値専用の入力になるものの、得られる`v-model`値は**文字列**です。たとえユーザーが「123」と入力しても`"123"`という文字列がバインドされます。このため、数値として扱いたい場合は文字列から数値への変換が必要です（Vueの修飾子はComposition APIでは使えないので、自前で`Number()`変換するなどします）。Vuetify 3には専用の`v-number-input`コンポーネントが用意されており、数値型のバリデーションやステッパーUIなどが必要な場合は`v-number-input`の利用も検討してください。
* **イベントの挙動**: Vuetify 2から移行した場合、`@input`や`@change`イベントが使えなくなって戸惑うことがあります。Vuetify 3では基本的に`v-model`（`update:modelValue`イベント）で値を追跡し、`change`イベントは発生しません。値の変化を検知する場合は`watch`で`v-model`変数を監視するか、`@update:modelValue`を使用してください。また、フォーカスやキーハンドリングは`.native`が不要になった反面、コンポーネント自体がイベントをエミットしないケースもあります。例えば`@blur`などは使えますが、内部で明示的に`this.$emit('blur')`しているわけではなくネイティブイベントとして伝搬している点に注意しましょう（カスタムコンポーネントを作る際も同様です）。
* **レイアウト上の注意**: テキストフィールドはデフォルトで横幅いっぱいに広がります。親要素の幅次第で大きさが決まるため、横に複数並べたい場合は`v-col`でカラム幅を指定するか、親にスタイルで幅を与える必要があります。そのままでは画面幅一杯に伸びる点に留意してください。
* **その他**: マスク（入力書式制限）機能はVuetify 3本体にはありません。例えば電話番号や日付など特定のフォーマットを強制したい場合、別途外部ライブラリ（例えば[maska](https://github.com/bevacqua/cleave.js)や自作の入力制御）を組み込む必要があります。また、自動補完をオフにする場合は`<v-text-field autocomplete="off">`のように標準属性を指定できますが、ブラウザによって効かない場合もあります。

---

## v-select（セレクトボックス）

### 基本説明と主な用途

`v-select`は標準的なHTMLの`<select>`要素を強化したコンポーネントで、クリックするとドロップダウンリストが表示され、その中から項目を一つ（または複数）選択できます。典型的にはフォームでの選択入力に使われ、`v-form`と組み合わせて使用されます。画面上での配置によってドロップダウンが上方向に開いたり下方向に開いたりといった挙動も自動で制御されます。例えば都道府県の選択やユーザーの役割選択など、あらかじめ用意した選択肢からユーザーに選ばせる場面で利用します。

### 主な Props 一覧

* **model-value / v-model** (`any`型): 選択された値です。単一選択の場合は選択肢に対応する値、複数選択（**multiple**使用時）の場合は選択値の配列になります。値の型は`items`に与えた配列の内容に依存します。
* **items** (`Array`): セレクトボックスに表示する選択肢のリストを指定します。文字列や数値の配列、あるいはオブジェクトの配列が利用できます。基本的な使い方では`['Option1', 'Option2', ...]`のような文字列配列を渡します。オブジェクトを渡す場合は後述の**item-title**や**item-value**でどのプロパティを表示・値とするか指定する必要があります。
* **item-title** (`string` または `function`): オブジェクト配列を`items`に渡した場合、各オブジェクトのどのプロパティを表示用テキストとするかを指定します。デフォルトは`"title"`プロパティです。例えば`item-title="name"`とすれば各オブジェクトの`name`プロパティ値が選択肢の表示に使われます。関数を渡すことでオブジェクトから動的に文字列を組み立てることも可能です。
* **item-value** (`string` または `function`): オブジェクト配列の場合に各オブジェクトのどのプロパティを実際の選択値とするか指定します。デフォルトは`"value"`プロパティです。例えば`item-value="id"`とすると各オブジェクトの`id`プロパティの値が`v-model`に格納されます。文字列だけでなく関数で計算させることもできます。**（注）**: item-valueを指定しない場合、デフォルト`"value"`プロパティが無ければオブジェクト全体が選択値として使われます。
* **return-object** (`boolean`型): こちらを`true`にすると、選択値としてオブジェクト自体を返すようになります。デフォルトは`false`で、`item-value`で指定したプロパティ値のみが返されます。オブジェクト全体が必要な場合に`return-object`を利用します（`item-value`の指定は無視されます）。
* **multiple** (`boolean`型): 複数選択を可能にします。`true`にするとチェックボックス付きのドロップダウンになり、複数の項目を選択できます。`v-model`の値は配列となり、複数の選択値（または選択オブジェクト）が格納されます。
* **chips** (`boolean`型): 選択された項目をチップ（タグ）表示にします。通常、複数選択時に有効にすると選択項目がテキストボックス内に丸いチップスタイルで表示され、個々に削除（アン選択）するUIが付与されます。単一選択時にも指定可能で、その場合選択値がチップ状に表示されます。
* **closable-chips** (`boolean`型): `chips`と併用して使います。`true`にするとチップに閉じる（×）ボタンがつき、クリックでその項目を選択解除できます。デフォルトは`false`（チップ表示のみで×はない）です。
* **label** (`string`型): テキストフィールドと同様、セレクトボックスのラベルを指定します。未選択時やフォーカス時に表示され、選択肢が選ばれるとフィールド上部にフローティングラベルとして残ります。
* **placeholder** (`string`型): 選択されていないときに表示するガイドテキストです。例えば「選択してください...」のような内容を指定できます。何か選択されるとプレースホルダは非表示になります。
* **variant** (`string`型): 外観スタイルを指定します。`v-select`も`v-text-field`と同様に`variant="outlined"`や`"underlined"`などが利用できます。デフォルトは`filled`スタイルです（Vuetify 3では`solo`スタイルもあります）。例: `variant="outlined"`にすると枠線表示のドロップダウンになります。
* **menu-props** (`object`): セレクトのドロップダウンメニュー（内部では`v-menu`コンポーネント）に渡すプロパティです。例えば`:{ menu-props: { maxHeight: '300px' }}`のように書くとメニューの最大高さを300pxに制限できます。`closeOnContentClick`や`openOnHover`など`v-menu`がサポートするオプションを指定可能です。特にカスタム`item`スロットを使う場合、`menu-props="{ closeOnContentClick: true }"`を指定しておくと選択肢クリック時にメニューが閉じるようになります。
* **no-data-text** (`string`型): `items`が空配列の場合に表示するテキストを指定します。デフォルトは「No data available」（英語）ですが、例えば`no-data-text="データがありません"`のようにするとローカライズできます。`hide-no-data`を指定するとデータ無しメッセージ自体を表示しません。
* **prepend-icon** / **append-icon** (`string`型): フィールド部分の左側または右側に表示するアイコンを指定します。`v-text-field`の場合と用途は同じです。例えば`prepend-icon="mdi-account"`でユーザアイコンをラベル左に表示するなどできます。
* **append-outer-icon** (`string`型): フィールド外右端のアイコンを差し替えます。通常、`v-select`ではデフォルトでプルダウンを示す▼のアイコン（mdi-menu-down）がこの位置に表示されています。`append-outer-icon`を指定するとこのデフォルトアイコンが置き換わります（例えば独自の矢印アイコンなどに変更可能）。
* **disabled** / **readonly**: これらも`v-text-field`同様に使用できます。`disabled`は選択自体をできなくし（プルダウンも開かない）、`readonly`はプルダウンは開けますが選択状態を変えられなくなります（表示用途）。

### 利用可能な Slots

* **item** スロット: ドロップダウンの各選択項目の表示内容をカスタマイズできます。`<template #item="{ item, props }">`のように定義し、中で`v-list-item`などを用いて`item`オブジェクトの内容を自由に描画できます。たとえばオブジェクトに含まれる画像URLを<img>タグで表示したり、テキストにアイコンを添えたりといったカスタムが可能です。**重要**: このスロットを使う場合、提供される`props`オブジェクトを`v-list-item`にバインドする必要があります。後述の注意点参照。
* **selection** スロット: テキストフィールド部分（選択済みの表示部分）をカスタマイズできます。`<template #selection="{ item, index }">`のようにし、選択された各`item`の描画を定義します。複数選択時には選択ごとにチップやカスタム表示を行いたい場合に便利です。例えば選択項目をチップではなく単にテキストで区切り表示したい場合、このスロットで実現可能です。
* **prepend-item** / **append-item** スロット: ドロップダウンの先頭および末尾に任意の内容を差し込むためのスロットです。例えば`prepend-item`に「全て選択」チェックボックスやリストヘッダを配置したり、`append-item`に「その他...」リンクを配置する、といった使い方ができます。
* **no-data** スロット: `items`が空の場合に表示する内容をカスタムできます。デフォルトでは`no-data-text`の文字列が表示されますが、スロットを用いることでスピナーを表示したり、データ追加用のボタンを設置したりできます。
* **dropdown** スロット: ドロップダウンそのものをカスタムしたい場合に使われます。通常は使用しませんが、メニュー表示全体を自前で組み立てたい高度な場合にこのスロットが提供されています。

### 主な Events

* **@update\:modelValue**: 選択値が変化したときに発火します。`v-model`と連携しており、選択された新しい値（もしくは値の配列）が引数として渡されます。単一選択では例えば`"Option1"`など、複数選択では選択された値の配列が来ます。
* **@change**: Vuetify 3では`v-select`において明示的な`change`イベントは基本的に使用しません（`update:modelValue`で代替）。Vue自体の`@change`修飾子（修正: Vue3では`.lazy`修飾子）は使用できますが、特別な理由がない限り`v-model`を通じて値を監視するのが通例です。
* **@click\:append-outer**: デフォルトではプルダウンアイコン(▼)が`append-outer`に表示されており、これがクリックされるとドロップダウンを開閉します。このイベントを捕捉することで独自の振る舞いをさせることもできますが、通常は自動開閉に任せます。`append-outer-icon`を自前のアイコンに変えた場合、そのクリックもこのイベントで拾えます。
* **@blur** / **@focus**: テキストフィールド部分のフォーカスの入り切りイベントです。これも`v-text-field`同様、ネイティブイベントとして利用可能です。`v-select`ではフォーカスが外れた際にデフォルトでメニューが閉じたりします。
* **@keydown**等: 必要であればキーボード操作も検知できます。例えばエンターキーで確定させたい場合などに利用します。

### よくある使用パターンとコード例

* **基本的なドロップダウン選択**: 文字列の配列を`items`に渡す最も簡単な例です。

  ```vue
  <template>
    <v-select :items="['赤','青','緑','黄']" label="色を選択" v-model="color" />
    <p>選択色: {{ color }}</p>
  </template>
  <script setup>
  import { ref } from 'vue';
  const color = ref('');
  </script>
  ```

  ドロップダウンをクリックすると「赤/青/緑/黄」のリストが表示され、一つ選ぶと`color`にその文字列が格納されます。選択された値はラベル部分に表示され、未選択時にはラベルが中に表示されます。

* **オブジェクト配列の利用**: より複雑なデータを扱う場合、オブジェクトの配列を渡して表示名と実際の値を分けられます。例えば以下のようにIDと名前のオブジェクトを扱うケースです。

  ```vue
  <v-select
    :items="userOptions"
    item-title="name"
    item-value="id"
    label="ユーザー選択"
    v-model="selectedUserId"
  />
  ```

  ```js
  setup() {
    const selectedUserId = ref(null);
    const userOptions = ref([
      { id: 1, name: '山田太郎' },
      { id: 2, name: '鈴木花子' },
      { id: 3, name: '佐藤三郎' }
    ]);
    return { selectedUserId, userOptions };
  }
  ```

  ここでは各オブジェクトの`name`を表示に、`id`を選択結果の値にしています。例えば「鈴木花子」を選べば`selectedUserId`には`2`が入り、表示上は「鈴木花子」と見えます。**補足**: `item-title`や`item-value`を指定しない場合、デフォルトで`title`プロパティと`value`プロパティが使われます。それ以外のキー名を使う場合は必ず指定しましょう。さもないと選択肢に`[object Object]`と表示されることがあります。

* **複数選択とチップ表示**: `multiple`を指定すると複数選択できます。例えば役割を複数選ぶような場合です。

  ```vue
  <v-select
    :items="['管理者','編集者','閲覧者']"
    label="役割を選択"
    v-model="roles"
    multiple
    chips
    closable-chips
  />
  ```

  これによりチェックボックス付きのドロップダウンになり、複数項目にチェックを入れられます。選択済み項目はフィールド内にチップ（タグ）として表示され、各チップの×をクリックするとその項目だけ選択解除（除去）できます。`roles`には選択された文字列の配列が入ります（例: `['管理者','閲覧者']`）。

* **選択肢の動的生成**: `items`はリアクティブデータにできるため、動的に選択肢を更新できます。例えば他の入力内容に応じて候補を変える場合や、APIから取得したデータで選択肢を埋める場合です。

  ```vue
  <v-select :items="prefectures" label="都道府県" v-model="pref" />
  <v-btn @click="loadPrefectures">都道府県データ取得</v-btn>
  ```

  ```js
  setup() {
    const pref = ref('');
    const prefectures = ref([]);
    const loadPrefectures = async () => {
      const res = await fetch('/api/prefs');
      prefectures.value = await res.json(); // 例: ["北海道","青森県",...]
    };
    return { pref, prefectures, loadPrefectures };
  }
  ```

  初期状態で`prefectures`が空でも、ボタン押下でAPIレスポンスをセットすればドロップダウンの内容が更新されます。Vuetify側でリストを監視しており、自動的に表示が変わります。**no-data**メッセージを出したくない場合は`hide-no-data`を付けておくと良いでしょう。

* **カスタム項目表示**: `item`スロットを使うと選択肢の描画を自由にできます。例えば各ユーザーにアイコン画像がある場合の例です。

  ```vue
  <v-select :items="users" v-model="user" label="ユーザー">
    <template #item="{ item, props }">
      <v-list-item v-bind="props">
        <v-list-item-avatar><v-img :src="item.avatar" /></v-list-item-avatar>
        <v-list-item-title>{{ item.name }}</v-list-item-title>
      </v-list-item>
    </template>
    <template #selection="{ item }">
      <v-avatar size="24" class="mr-1"><v-img :src="item.avatar" /></v-avatar>
      {{ item.name }}
    </template>
  </v-select>
  ```

  まず`item`スロットでは`v-list-item`を用い、そのまま`v-bind="props"`でVuetifyから提供されるpropsを渡しています。これにより選択状態のハイライトやクリック挙動が保証されます。内部で各`item`の`avatar`（URL）と`name`を表示しています。さらに`selection`スロットで、選択済み表示部分も画像付きでカスタムしています。このようにして、選択肢・選択済表示の両方を柔軟にレイアウトできます。

### 応用テクニック

* **動的フィルタリング (検索)**: ユーザーが入力したテキストで候補をフィルタリングするには、`v-autocomplete`コンポーネントの使用が推奨されます。`v-select`自体には入力によるフィルタ機能はありませんが、`v-autocomplete`は`v-select`を拡張してテキスト入力と候補のフィルタ表示を可能にしたものです。大量のデータからの検索候補絞り込みや非同期ローディングによるサジェストは`v-autocomplete`や`v-combobox`（新規値入力も可能なコンボボックス）を検討してください。
* **グループ化された選択肢**: リストの中で選択肢をグループ分けしたい場合、Vuetify 3では`items`配列内でオブジェクトに子リストを持たせる形で対応できます。例えば`{ header: 'フルーツ' }`のような見出しオブジェクトや、`{ title: 'りんご', children: [...] }`のように`children`プロパティを持たせることで入れ子のリストを作れます（Vuetify 2から仕様変更がありました）。これを用いると、ドロップダウン内に区切り線や見出しを含む階層的なメニューを構築できます。
* **カスタムの「全選択/全解除」**: 複数選択時に「全て選択」や「全て解除」を実装したい場合、`prepend-item`または`append-item`スロットにチェックボックスやボタンを配置して実装できます。例えば`prepend-item`に「\<v-list-item @click="selectAll">全選択</v-list-item>」を入れ、`selectAll`メソッド内で`v-model`の配列に全`items`の値を設定すればOKです。また、デフォルトの**select-all**機能はありませんが、このようにスロットとメソッドで対応可能です。
* **選択項目数の表示**: 複数選択で項目数が多い場合、選択済みのチップが増えすぎて収まりきらないことがあります。そのような場合、`selection`スロットでカスタム表示に切り替え、例えば「3項目を選択中...」とテキストでまとめて表示することも可能です（`index`を利用して先頭2件はチップ表示し、3件目以降は「+ n more」と表示する等）。これはUX向上のテクニックの一つです。

### よくある落とし穴や注意点

* **オブジェクト項目の未設定**: `items`にオブジェクト配列を渡す際、`item-title`や`item-value`を正しく指定しないと、ドロップダウンに`[object Object]`という文字列が表示されてしまいます。Vuetifyのデフォルトでは`item-title='title'`を参照するため、オブジェクトに`title`プロパティがない場合はこの現象が起きます。必ず適切なキー名を設定しましょう。
* **カスタム項目スロットでの選択不可問題**: `#item`スロットを使って独自レイアウトの項目を定義すると、そのままでは選択が機能しなくなることがあります。これはVuetifyが提供する`props.onClick`などのハンドラが適用されないためです。対策として、先述したように\*\*`v-bind="props"`\*\*で提供されるプロパティをまるごと`v-list-item`等に渡すか、少なくとも`@click="props.onClick"`を指定して内部で呼び出す必要があります。これを忘れると項目をクリックしても値が選択状態に反映されないので注意してください。
* **メニューの高さとスクロール**: 選択肢が非常に多い場合、デフォルトではドロップダウンメニューは画面に収まる高さで自動調整されスクロール可能になります。ただし必要に応じて`menu-props="{ maxHeight: '400px' }"`のように上限高さを指定できます。また、メニューが画面端にかかる場合、自動で表示方向（上開き/下開き）が切り替わりますが、強制的に下方向に開きたい場合などは`menu-props="{ nudgeY: 0 }"`など高度な設定が必要になるケースもあります。
* **未選択時の値**: `v-select`の`v-model`は、未選択状態では`null`（もしくは空文字列）になります。オプションを選ぶとその値型（文字列や数値、オブジェクト）になりますが、初期値`null`との型不一致に注意してください。例えば数値IDを選ぶセレクトでは、data初期値を`null`ではなく`0`や`undefined`にしておくと型エラーを防げる場合があります。
* **複数選択のデフォルト値**: `multiple`を使用した場合、`v-model`の初期値は**空配列**にしておきましょう。`null`だと型が異なりバインディングが正しく機能しません。また、初期からいくつか選択状態にしたい場合はその配列に値を入れておけば、その項目がチェックされた状態で表示されます。
* **ドロップダウン外クリック**: ユーザーがドロップダウンを開いたまま画面の他の部分をクリックするとメニューは閉じます。この挙動は通常期待通りですが、メニュー内に特殊なUIを入れている場合（例えば検索ボックスを内蔵した複雑なメニュー）には注意が必要です。必要なら`menu-props="{ closeOnContentClick: false }"`とし、メニュー内クリックでは閉じないようにできます。
* **コンボボックスとの違い**: `v-combobox`は`v-select`に手入力で新規値を追加する機能を加えたコンポーネントです。ユーザーにリストから選ばせつつ、リストにない値も入力させたい場合は`v-combobox`を使用します。単純な選択のみなら`v-select`で十分ですが、必要に応じてコンボボックスやオートコンプリートとの使い分けを検討してください。

---

## v-form（フォームコンテナ）

### 基本説明と主な用途

`v-form`はフォーム入力要素をグルーピングし、一括でのバリデーション管理や状態管理を容易にするコンポーネントです。HTMLの<form>要素に似た役割を果たし、内部に配置したすべての入力コンポーネント（`v-text-field`や`v-select`など）の検証状態をまとめて扱うことができます。主な用途は**フォームのバリデーション**です。`v-form`自体には見た目上の表示はなく、子の入力要素の容器として機能します。Enterキーでの送信やリセット、全体の有効/無効制御なども担います。

### 主な Props 一覧

* **model-value / v-model** (`boolean|null`型): フォーム全体のバリデーション状態を示す値です。子の入力に基づき\*\*すべて有効なら`true`、無効な入力があれば`false`、まだ検証が行われていなければ`null`\*\*となります。例えば必須項目が未入力のまま一度も触れていなければ`null`ですが、`validate()`を呼ぶと`false`になる、といった挙動をします。`v-model`を使ってこの値をデータとバインドすることで、フォームが有効か無効かをリアクティブに取得できます。
* **disabled** (`boolean`型): `true`にするとフォーム内のすべての入力コンポーネントが一括で**無効化**されます。個別に各コンポーネントに`disabled`を指定しなくても、フォーム親側でまとめて操作できる便利なプロップです。例えば送信完了後に全フィールドを読み取り専用にしたい場合などに使います。
* **readonly** (`boolean`型): こちらもフォーム内のすべての入力を**読み取り専用**にします。`disabled`との違いは、スタイルが異なる（通常はグレーアウトしない）点と、フォーム送信時には値が送られる点です。フォーム全体を閲覧モードにしたい場合に便利です。
* **fast-fail** (`boolean`型): 検証の実行方法を制御します。デフォルト`false`では全てのルールを評価しますが、`true`にすると**最初のルール違反で残りのチェックをスキップ**します。多数のルールがある場合にパフォーマンス向上や不要なエラーメッセージの抑制に役立ちます。例えば複数のバリデーションを順序付けたい場合に使用します。
* **validate-on** (`string|Array`型): どのタイミングでフィールドのバリデーションを行うかを設定できます（Vuetify 3.xの特定バージョンで導入）。デフォルトでは`blur`（フォーカスを外れた時）と`change`（入力値変化時）ですが、このプロップで`input`や`submit`に変更可能です。例えば`validate-on="submit"`にすると`validate()`を呼ぶかフォーム送信時までエラー表示しない、という挙動になります。
* **lazy-validation** (`boolean`型): Vuetify 2に存在したプロップですが、Vuetify 3ではフォームは基本的に遅延検証（=未操作フィールドは未検証）となっており、このプロップは使用されなくなりました。そのため特に指定しなくても「未触れるまでは`model-value`が`null`のまま」という動きになります。

### 利用可能な Slots

* **default** スロット: フォーム内に配置するコンテンツ用のスロットです。通常、ここに`v-text-field`や`v-select`、ボタンなどフォーム要素を配置します。`v-form`自体はレイアウト要素ではないので見た目を調整したい場合は内部で`v-row`や`v-col`、`v-container`などを使って下さい。
* 特別な named slot はありません。基本的にフォームはコンテナとして機能するだけなので、スロットは`default`一つです。

### 主な Events

* **@submit**: フォームが送信された時に発火します。これはネイティブフォームのsubmitイベントに対応しており、`<v-form>`に`@submit.prevent`ハンドラを付けることでEnterキー押下や送信ボタン（type="submit"）クリック時の標準動作をキャンセルしつつ、自分のメソッドを実行できます。例えば`@submit.prevent="saveData"`のように使用します。**注意**: 実際のフォーム同様、`type="submit"`のボタンかEnterキーによるsubmitしか発火しないので、独自の送信UIの場合は手動でメソッドを呼ぶか、`submit()`メソッドを参照してください。
* **@reset**: `<form>`要素同様に、`type="reset"`のボタンなどでフォームリセットイベントが発生すると呼ばれます。Vuetifyではこのイベントを利用するより、後述の`reset()`メソッドを使ってプログラマチックにリセットすることが多いです。
* **@update\:modelValue**: 内部のいずれかの子コンポーネントの検証状態が変わり、フォーム全体の有効/無効状態が変化した時に発火します。すなわち`valid`（modelValue）が`null`→`false`や`false`→`true`になるタイミングで呼ばれます。引数として`true`/`false`/`null`が渡ります。`v-model`を使っていればこのイベントを直接扱う必要はあまりありません。

### よくある使用パターンとコード例

* **フォームの基本的な使い方**: フォーム全体を`<v-form>`で括り、内部に入力フィールドやボタンを配置します。送信ボタンでバリデーションしてから送信する例を示します。

  ```vue
  <template>
    <v-form ref="form" v-model="isValid" @submit.prevent="submitForm">
      <v-text-field v-model="form.name" label="名前" :rules="[v => !!v || '必須です']" required />
      <v-text-field v-model="form.email" label="Email" :rules="[v => /.+@.+\..+/.test(v) || 'メールアドレスを入力']" />
      <v-select v-model="form.role" :items="roles" label="役割" :rules="[v => !!v || '選択してください']" />
      <div class="mt-2">
        <v-btn type="submit" :disabled="!isValid">送信</v-btn>
        <v-btn type="button" @click="resetForm">リセット</v-btn>
      </div>
    </v-form>
  </template>
  <script setup>
  import { ref, reactive } from 'vue';
  const form = reactive({ name: '', email: '', role: null });
  const roles = ['管理者','一般ユーザー'];
  const isValid = ref(null);
  const submitForm = () => {
    // 送信処理（バリデーション済みなので isValid が true の場合のみ呼ばれる）
    alert(`送信: ${JSON.stringify(form)}`);
  };
  const resetForm = () => {
    // フォームリセット
    form.name = ''; form.email = ''; form.role = null;
    // v-formコンポーネントの組み込みメソッド resetValidation() を呼んでエラーメッセージ非表示化
    formRef.value.resetValidation();
  };
  const formRef = ref();
  </script>
  ```

  ここでは`v-form`に`v-model="isValid"`を指定し、フォーム全体が有効かどうかを`isValid`で管理しています。送信ボタンの`disabled`に`!isValid`をバインドすることで、無効な間はボタンを押せないようにしています。また、送信ボタンは`type="submit"`としているのでフォームの@submitイベントが発火し、`submitForm`が呼ばれます。リセットボタンでは`resetForm`内でフォームオブジェクトを初期化しつつ、`resetValidation()`メソッドでエラー表示もリセットしています。**ポイント**: `v-form`の`ref`経由で組み込みメソッド`resetValidation()`や`validate()`が使えます。

* **プログラムからバリデーション実行**: フォーム送信前にJS側でチェックしたい場合、`validate()`メソッドを使います。例えば上記の送信処理を以下のようにも書けます。

  ```js
  const submitForm = () => {
    const formEl = formRef.value;
    if (formEl?.validate() === true) {
      // 全て検証OKの場合のみ送信処理
      sendData(form);
    }
  };
  ```

  `validate()`はVuetify 3では**Promise**を返すようになっており、`await formEl.validate()`と書いて結果を待つこともできます。単純な同期処理であれば上記のように戻り値の真偽で判断できます。`validate()`は全子要素の`rules`を評価し、全て通れば`true`、一つでも失敗すれば`false`を返します。フォームの`model-value`（`isValid`にバインドした値）もこの時更新されます。

* **フォームのリセット**: 上述の`resetValidation()`は全子コンポーネントのエラー状態をクリアします。加えて各フィールドの値自体を初期値に戻す場合、データオブジェクトを再初期化するか、`v-form`に組み込みの`reset()`メソッドも利用できます。`reset()`は各子の`v-model`を初期値（ページロード時もしくは直近の`.reset()`呼び出し時の値）に戻す機能です。例えば`formRef.value.reset()`とすれば、`reset()`呼び出し時点で覚えた初期値に巻き戻ります。手動で値をクリアするのと異なり、直近のユーザー入力で変更された初期値もリセット対象になる点が便利です。

* **子コンポーネントのカスタムバリデーション**: フォーム内にはVuetify標準の入力コンポーネント以外にも、自作のカスタムコンポーネントを含めることができます。その場合、カスタムコンポーネント側でVuetifyの検証インターフェースに対応する必要があります。具体的には`provide()`/`inject()`で`FormItem` injectionを受け取り、`isValid`や`resetValidation`、`validate`メソッドを持たせるなどです。これは高度な実装になりますが、Vuetifyのソースを見ると参考になります（`useForm()`コンポーザブルが鍵です）。一般的な用途では、自作コンポーネント内でVuetifyの入力コンポーネントを使っていれば自動的に対応できます。

### よくある落とし穴や注意点

* **`model-value`の扱い**: フォームの`v-model`でバインドされる値は上記のとおり`boolean`または`null`です。初期状態では`null`であることに注意してください。例えば`isValid`をデバッグ表示すると、何も操作しない間は`null`となります。これは\*\*「未検証」\*\*を意味します。`validate()`を一度呼ぶか、ユーザーが一度でも入力してblurすれば`true`か`false`に変わります。したがって、フォーム送信可否の判断に使う場合は単純に`true/false`だけでなく`null`も考慮する必要があります（上記例ではボタンdisabledに`!isValid`を使っていますが、`null`はtruthyではないため問題なく「無効扱い」になります）。
* **lazyな検証タイミング**: Vuetify 3ではデフォルトで**遅延検証**（lazy validation）です。つまり各フィールドはユーザーが触れるまではエラーを表示しません。これはユーザー体験として適切ですが、開発者がうっかり「必須フィールドなのに`isValid`がfalseになっていない？」と混乱する原因になります。触れていない必須フィールドがある場合でも`isValid`は`null`のままなので、意図的に`validate()`を呼ぶか、`validate-on`プロップを調整しないと検証されません。**対策**: フォーム送信時に確実に`validate()`を呼ぶ、もしくは`validate-on="blur"`（デフォルト）なので各フィールドでblurさせるようガイドする、など。
* **ネストしたフォーム**: HTML同様、フォームの入れ子は基本的に非推奨です。`v-form`内に別の`v-form`を入れるとイベントハンドリングやバリデーションの伝播が意図通りに動かない可能性があります。どうしても必要な場合は`form`要素ではなく`fieldset`や`div`で代替することを検討してください。
* **パフォーマンス**: 非常に多数の入力を含むフォーム（例えば50項目以上）では、毎フレームのバリデーションチェックが負荷になるケースがあります。その際は`fast-fail`を`true`にして無駄なチェックを省略したり、`validate-on="submit"`として入力中のリアルタイム検証をオフにすることでパフォーマンスを向上できます。特にカスタムルールで重い処理（サーバー問い合わせ等）をしている場合は注意が必要です。
* **ファイルアップロードフォーム**: `<v-form>`はネイティブフォーム要素として動作しますが、ファイルアップロード（<form enctype="multipart/form-data">）の場合、通常のSPAでは直接扱わずAPI経由で送ることが多いでしょう。`v-file-input`などを使ってファイルを選択し、バリデーションすることは可能ですが、`<v-form>`に`enctype`属性などを付与してネイティブフォーム送信するとVuetifyの利点を活かせません。ファイルは`v-file-input`の`v-model`から`FormData`にappendしてfetchで送るなど、別途ハンドリングしましょう。
* **ブラウザの自動補完**: フォーム内の入力についてブラウザのオートコンプリートが働く場合があります。例えば以前入力した住所がドロップダウンで出てくる等です。Vuetifyの`v-form`として制御はできず、各`v-text-field`に`autocomplete`属性を付ける対応になります（`autocomplete="new-password"`など適切な値を設定）。場合によってはブラウザ側機能を完全には抑制できないことも覚えておいてください。

以上、Vuetify 3における`v-text-field`、`v-select`、`v-form`の基本から応用までをまとめました。それぞれ豊富なプロパティと拡張性を持つコンポーネントなので、要件に合わせて適切に組み合わせて活用してください。各コンポーネントの詳細は公式ドキュメントも参照すると更に深く理解できます。
