### **1. JavaScriptの基本**

#### **JavaScriptとは**
JavaScriptは、ウェブブラウザで動作するプログラミング言語で、主に以下の目的で使用されます。
- **フロントエンド開発**: Webページの動的な更新、ユーザーインタラクションの処理
- **バックエンド開発**: Node.jsを利用したサーバーサイドプログラミング
- **モバイル・デスクトップアプリ開発**: React Native, Electron などを活用

#### **JavaScriptの実行環境**
JavaScriptのコードは主に以下の環境で実行できます。

1. **ブラウザ**
   - JavaScriptは、ブラウザのエンジン（V8, SpiderMonkey など）で実行されます。
   - `<script>` タグを用いてHTML内に直接記述することができます。
   - 例:
     ```html
     <script>
       console.log("Hello, JavaScript!");
     </script>
     ```

2. **Node.js**
   - JavaScriptをサーバーサイドで実行するためのランタイム環境。
   - `node` コマンドでJavaScriptコードを実行できます。
   - 例:
     ```sh
     node -e "console.log('Hello, Node.js!')"
     ```

#### **JavaScriptの基本的な書き方**
JavaScriptのコードは、ブラウザやNode.jsで実行され、主に以下の構文で記述されます。

1. **コンソール出力**
   - `console.log()` を使ってデバッグ情報を表示
   ```js
   console.log("Hello, World!");
   ```

2. **コメント**
   - 一行コメント (`//`)
   - 複数行コメント (`/* ... */`)
   ```js
   // これは一行コメント
   /*
     これは
     複数行コメント
   */
   ```

3. **セミコロン（`;`）**
   - JavaScriptではセミコロンは省略可能だが、エラーを防ぐために明示的に記述するのが推奨される。
   ```js
   console.log("Hello"); // セミコロンあり
   console.log("World")  // セミコロンなしでも動くが推奨されない
   ```

#### **変数と定数 (`var`, `let`, `const`)**
JavaScriptには変数を宣言する方法が3つあります。

1. **`var`（古い宣言方法）**
   - **関数スコープ**
   - `var` はブロックスコープを持たず、意図しない動作を引き起こす可能性があるため、基本的に使用しない。
   ```js
   var x = 10;
   console.log(x);
   ```

2. **`let`（推奨）**
   - **ブロックスコープ**
   - 再代入可能
   ```js
   let y = 20;
   console.log(y);
   y = 30; // 再代入可能
   console.log(y);
   ```

3. **`const`（推奨）**
   - **ブロックスコープ**
   - 再代入不可（変更できない定数）
   ```js
   const z = 50;
   console.log(z);
   // z = 60; // エラー
   ```

#### **スコープの違い**
```js
if (true) {
  var a = "varの変数";
  let b = "letの変数";
  const c = "constの変数";
}
console.log(a); // varの変数（関数スコープのため外でも使える）
console.log(b); // エラー（ブロックスコープ）
console.log(c); // エラー（ブロックスコープ）
```
- `var` は関数スコープでブロック外でもアクセス可能
- `let` と `const` はブロックスコープでブロック外ではアクセス不可

#### **まとめ**
| 宣言方法 | スコープ | 再代入 | 推奨/非推奨 |
|----------|---------|--------|------------|
| `var`    | 関数スコープ | 可能 | ❌ 非推奨 |
| `let`    | ブロックスコープ | 可能 | ✅ 推奨 |
| `const`  | ブロックスコープ | 不可 | ✅ 推奨 |

JavaScriptでは、`let` や `const` を使うのが推奨されます！


### **2. データ型と型変換**

JavaScriptのデータ型は大きく **「プリミティブ型」** と **「オブジェクト型」** に分けられます。  
また、型の判定や型変換の方法についても理解しておくと、バグを防ぎやすくなります。

---

## **🟢 1. プリミティブ型（基本データ型）**
プリミティブ型は **単一の値を持つ** 型で、**参照型ではない** ため、値が直接保持されます。

| 型名         | 説明 |
|-------------|------|
| **`string`** | 文字列（例: `"Hello"`, `'World'`） |
| **`number`** | 数値（例: `123`, `3.14`） |
| **`boolean`** | 真偽値（`true` or `false`） |
| **`null`** | `null`（意図的に「何もない」値） |
| **`undefined`** | `undefined`（未定義の値） |
| **`symbol`** | 一意な識別子（ES6で追加） |
| **`bigint`** | 超大きな整数（ES11で追加） |

### **📌 例**
```js
let str = "Hello";       // 文字列型 (string)
let num = 42;            // 数値型 (number)
let isTrue = true;       // 真偽型 (boolean)
let empty = null;        // null（明示的な無）
let notDefined;          // undefined（未定義）
let uniqueKey = Symbol(); // Symbol型
let bigNumber = 9007199254740991n; // BigInt型
```

#### **⚠ `null` と `undefined` の違い**
```js
let a = null;       // 意図的に「何もない」と設定
let b;              // 変数を宣言したが、値を設定していない（undefined）

console.log(a);     // null
console.log(b);     // undefined
```

---

## **🟢 2. オブジェクト型**
オブジェクト型は **複数の値や機能を持つデータ型** です。

| 型名         | 説明 |
|-------------|------|
| **`Object`** | キーと値のペアを持つデータ構造 |
| **`Array`** | 順序付きリスト |
| **`Function`** | 関数 |

### **📌 例**
```js
let obj = { name: "Alice", age: 25 }; // オブジェクト
let arr = [1, 2, 3, 4, 5];            // 配列（実はオブジェクト）
function greet() {                     // 関数（Function型）
  console.log("Hello!");
}
```

#### **📌 オブジェクトと配列の動作**
```js
let person = { name: "Bob", age: 30 };
console.log(person.name); // "Bob"

let numbers = [10, 20, 30];
console.log(numbers[1]); // 20
```

---

## **🟢 3. 型の判定**
JavaScriptでは **動的型付け** なので、変数の型を調べる必要があることがあります。

### **📌 `typeof` を使う**
```js
console.log(typeof "Hello");     // "string"
console.log(typeof 42);          // "number"
console.log(typeof true);        // "boolean"
console.log(typeof undefined);   // "undefined"
console.log(typeof null);        // "object"（JavaScriptのバグ）
console.log(typeof Symbol());    // "symbol"
console.log(typeof 9007199254740991n); // "bigint"
console.log(typeof {});          // "object"
console.log(typeof []);          // "object"
console.log(typeof function(){});// "function"
```
**⚠ `typeof null` が `"object"` なのは歴史的なバグ** ですが、現在も修正されていません。

---

### **📌 `instanceof` を使う**
- **オブジェクトの型を判定** する際に使う。
- **配列やカスタムオブジェクトの判定に便利**。

```js
console.log([] instanceof Array);    // true
console.log({} instanceof Object);   // true
console.log(function(){} instanceof Function); // true
console.log(new Date() instanceof Date); // true
```

---

## **🟢 4. 型変換（暗黙的・明示的）**
JavaScriptでは **自動的に型変換（暗黙的変換）** されることがありますが、意図的に変換することもできます（明示的変換）。

---

### **📌 1. 暗黙的な型変換**
```js
console.log("5" + 2);  // "52"  → 数値が文字列に変換される
console.log("5" - 2);  // 3     → 文字列が数値に変換される
console.log(true + 1); // 2     → true は 1 に変換
console.log(false + 1);// 1     → false は 0 に変換
console.log("5" * "2");// 10    → 両方数値に変換
```

---

### **📌 2. 明示的な型変換**
JavaScriptでは、`Number()`, `String()`, `Boolean()` などの関数を使って **型を明示的に変換** できます。

#### **📌 文字列 → 数値**
```js
console.log(Number("123"));   // 123
console.log(parseInt("123px")); // 123（文字を削除して数値変換）
console.log(parseFloat("3.14")); // 3.14
console.log(+ "123");        // 123（+ 演算子で変換）
```

#### **📌 数値 → 文字列**
```js
console.log(String(123));    // "123"
console.log((123).toString()); // "123"
```

#### **📌 文字列/数値 → 真偽値**
```js
console.log(Boolean(1));     // true
console.log(Boolean(0));     // false
console.log(Boolean("hello")); // true
console.log(Boolean(""));    // false
console.log(Boolean(null));  // false
```

---

## **🎯 まとめ**
| 型の種類 | 例 |
|---------|----|
| **プリミティブ型** | `string`, `number`, `boolean`, `null`, `undefined`, `symbol`, `bigint` |
| **オブジェクト型** | `Object`, `Array`, `Function` |
| **型判定** | `typeof`, `instanceof` |
| **暗黙的な型変換** | `"5" + 2 → "52"`, `"5" - 2 → 3` |
| **明示的な型変換** | `Number("123")`, `String(123)`, `Boolean(1)` |

---

JavaScriptの型は **動的に変化する** ので、意図しない型変換が起きないように気をつけよう！🚀

### **3. 演算子（Operators）**
JavaScriptには多くの演算子があり、**計算・比較・論理処理** などに使われます。  
ここでは、よく使う演算子をカテゴリ別に解説します。

---

## **🟢 1. 算術演算子（Arithmetic Operators）**
| 演算子 | 説明 | 例 |
|--------|------|----|
| `+` | 加算（数値の足し算 / 文字列の結合） | `5 + 3 // 8` |
| `-` | 減算 | `5 - 3 // 2` |
| `*` | 乗算 | `5 * 3 // 15` |
| `/` | 除算 | `10 / 2 // 5` |
| `%` | 剰余（余り） | `10 % 3 // 1` |
| `**` | 累乗（ES6から導入） | `2 ** 3 // 8` |

### **📌 例**
```js
console.log(5 + 3);   // 8
console.log(10 - 4);  // 6
console.log(6 * 7);   // 42
console.log(10 / 2);  // 5
console.log(10 % 3);  // 1
console.log(2 ** 3);  // 8
```

---

## **🟢 2. 比較演算子（Comparison Operators）**
| 演算子 | 説明 | 例 | 結果 |
|--------|------|----|------|
| `==` | 値が等しい（型変換あり） | `"5" == 5` | `true` |
| `===` | 値と型が等しい（厳密比較） | `"5" === 5` | `false` |
| `!=` | 値が異なる（型変換あり） | `"5" != 5` | `false` |
| `!==` | 値と型が異なる（厳密比較） | `"5" !== 5` | `true` |
| `>` | より大きい | `10 > 5` | `true` |
| `<` | より小さい | `10 < 5` | `false` |
| `>=` | 以上 | `10 >= 10` | `true` |
| `<=` | 以下 | `5 <= 10` | `true` |

### **📌 `==` vs `===` の違い**
```js
console.log("5" == 5);  // true  （型変換が行われる）
console.log("5" === 5); // false （型が異なるため）
```

---

## **🟢 3. 論理演算子（Logical Operators）**
| 演算子 | 説明 | 例 | 結果 |
|--------|------|----|------|
| `&&` | AND（両方が `true` のとき `true`） | `true && false` | `false` |
| `||` | OR（どちらかが `true` のとき `true`） | `true || false` | `true` |
| `!` | NOT（真偽値を反転） | `!true` | `false` |

### **📌 例**
```js
console.log(true && false);  // false
console.log(true || false);  // true
console.log(!true);          // false
```

---

## **🟢 4. ビット演算子（Bitwise Operators）**
**数値を2進数として扱い、ビット単位で演算を行う**。

| 演算子 | 説明 | 例 (`5 = 101`, `3 = 011`)| 結果 |
|--------|------|----------------|------|
| `&` | AND（両方のビットが `1` のとき `1`） | `5 & 3` → `101 & 011` | `001 (1)` |
| `|` | OR（どちらかのビットが `1` のとき `1`） | `5 | 3` → `101 | 011` | `111 (7)` |
| `^` | XOR（どちらか片方のビットが `1` のとき `1`） | `5 ^ 3` → `101 ^ 011` | `110 (6)` |
| `~` | NOT（ビットを反転） | `~5` | `-6` |
| `<<` | 左シフト（ビットを左にずらす） | `5 << 1` | `10` |
| `>>` | 右シフト（符号を保持） | `5 >> 1` | `2` |
| `>>>` | 右シフト（符号なし） | `-5 >>> 1` | `2147483645` |

### **📌 例**
```js
console.log(5 & 3);  // 1
console.log(5 | 3);  // 7
console.log(5 ^ 3);  // 6
console.log(~5);     // -6
console.log(5 << 1); // 10
console.log(5 >> 1); // 2
console.log(-5 >>> 1); // 2147483645
```

---

## **🟢 5. 代入演算子（Assignment Operators）**
| 演算子 | 説明 | 例 |
|--------|------|----|
| `=` | 代入 | `x = 10` |
| `+=` | 加算して代入 | `x += 5` → `x = x + 5` |
| `-=` | 減算して代入 | `x -= 3` → `x = x - 3` |
| `*=` | 乗算して代入 | `x *= 2` → `x = x * 2` |
| `/=` | 除算して代入 | `x /= 2` → `x = x / 2` |
| `%=` | 剰余を代入 | `x %= 3` → `x = x % 3` |

### **📌 例**
```js
let x = 10;
x += 5;  // x = x + 5 → 15
x -= 3;  // x = x - 3 → 12
x *= 2;  // x = x * 2 → 24
x /= 4;  // x = x / 4 → 6
x %= 5;  // x = x % 5 → 1
console.log(x); // 1
```

---

## **🟢 6. 三項演算子（Ternary Operator）**
三項演算子は、`if` 文の簡略版です。

| 演算子 | 説明 | 例 |
|--------|------|----|
| `条件 ? 真の場合 : 偽の場合` | 条件に応じた値を返す | `score > 50 ? "合格" : "不合格"` |

### **📌 例**
```js
let score = 80;
let result = score > 50 ? "合格" : "不合格";
console.log(result); // "合格"
```

---

## **🎯 まとめ**
| 演算子 | 説明 | 例 |
|--------|------|----|
| **算術演算子** | `+`, `-`, `*`, `/`, `%`, `**` | `5 + 3 // 8` |
| **比較演算子** | `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=` | `"5" == 5 // true` |
| **論理演算子** | `&&`, `||`, `!` | `true && false // false` |
| **ビット演算子** | `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>` | `5 & 3 // 1` |
| **代入演算子** | `=`, `+=`, `-=`, `*=`, `/=`, `%=` | `x += 5` |
| **三項演算子** | `条件 ? 真 : 偽` | `score > 50 ? "合格" : "不合格"` |

演算子を理解して、効率的なコードを書こう！🚀

### **4. 制御構文（Control Structures）**
JavaScriptの制御構文には、**条件分岐**・**ループ**・**ループ制御** などがあります。

---

## **🟢 1. 条件分岐（if, else if, else, switch）**
条件に応じて処理を切り替える方法です。

### **📌 `if`, `else if`, `else`**
基本的な条件分岐は `if` 文を使います。

```js
let score = 85;

if (score >= 90) {
    console.log("Aランク");
} else if (score >= 70) {
    console.log("Bランク");
} else if (score >= 50) {
    console.log("Cランク");
} else {
    console.log("Dランク");
}
```
**✅ 実行結果**
```
Bランク
```

---

### **📌 `switch` 文**
- **複数の条件を簡潔に記述** できる（`if-else` の代わり）。
- `break` を書かないと次の `case` も実行される。

```js
let rank = "B";

switch (rank) {
    case "A":
        console.log("100点");
        break;
    case "B":
        console.log("80点");
        break;
    case "C":
        console.log("60点");
        break;
    default:
        console.log("評価なし");
}
```
**✅ 実行結果**
```
80点
```

---

## **🟢 2. 繰り返し（ループ）**
### **📌 `for` ループ**
**繰り返し処理の基本**。初期値・条件・増減を指定。

```js
for (let i = 0; i < 5; i++) {
    console.log("ループ回数:", i);
}
```
**✅ 実行結果**
```
ループ回数: 0
ループ回数: 1
ループ回数: 2
ループ回数: 3
ループ回数: 4
```

#### **📝 `for` を使った配列のループ**
```js
let fruits = ["Apple", "Banana", "Cherry"];
for (let i = 0; i < fruits.length; i++) {
    console.log(fruits[i]);
}
```
**✅ 実行結果**
```
Apple
Banana
Cherry
```

---

### **📌 `while` ループ**
条件が `true` の間、繰り返す。

```js
let count = 0;
while (count < 3) {
    console.log("カウント:", count);
    count++;
}
```
**✅ 実行結果**
```
カウント: 0
カウント: 1
カウント: 2
```

---

### **📌 `do...while` ループ**
- **最初の1回は必ず実行される**。
- `while` との違いは、**条件を後で判定する** こと。

```js
let num = 0;
do {
    console.log("実行:", num);
    num++;
} while (num < 3);
```
**✅ 実行結果**
```
実行: 0
実行: 1
実行: 2
```

---

## **🟢 3. ループ制御（break, continue）**
ループの流れを変更する特別な制御文。

### **📌 `break`（ループを抜ける）**
- `break` を使うと **ループを途中で終了** できる。

```js
for (let i = 0; i < 10; i++) {
    if (i === 5) {
        console.log("5で停止");
        break;
    }
    console.log(i);
}
```
**✅ 実行結果**
```
0
1
2
3
4
5で停止
```

---

### **📌 `continue`（スキップ）**
- `continue` を使うと **特定の条件でループの処理をスキップ** できる。

```js
for (let i = 0; i < 5; i++) {
    if (i === 2) {
        console.log("2をスキップ");
        continue;
    }
    console.log(i);
}
```
**✅ 実行結果**
```
0
1
2をスキップ
3
4
```

---

## **🎯 まとめ**
| 構文 | 説明 |
|------|------|
| `if, else if, else` | 条件によって処理を分岐する |
| `switch` | `if-else` の代替（複数のケースに対応） |
| `for` | **繰り返し処理の基本** |
| `while` | 条件が `true` の間、ループ |
| `do...while` | **1回は必ず実行** されるループ |
| `break` | **ループを途中で抜ける** |
| `continue` | **処理をスキップして次のループへ** |

---

制御構文を使いこなせば、効率的なプログラムが書ける！🚀

### **5. 関数（Functions）**
JavaScriptの関数は、**コードを再利用し、処理を整理する** ための重要な要素です。

---

## **🟢 1. 関数の定義（`function` キーワード）**
関数を定義するには `function` キーワードを使います。

### **📌 通常の関数定義**
```js
function greet(name) {
    console.log("こんにちは、" + name + "さん！");
}

// 関数の呼び出し
greet("太郎"); 
```
**✅ 実行結果**
```
こんにちは、太郎さん！
```

### **📌 戻り値を持つ関数**
関数内で `return` を使うと、値を返すことができます。

```js
function add(a, b) {
    return a + b;
}

let sum = add(3, 5);
console.log(sum); // 8
```

---

## **🟢 2. 無名関数とアロー関数（`() => {}`）**
関数には **「名前のある関数」** と **「無名関数」** があります。

### **📌 無名関数**
- 変数に関数を代入して使うことができる。

```js
const greet = function(name) {
    console.log("こんにちは、" + name + "さん！");
};

greet("花子");
```

---

### **📌 アロー関数（`() => {}`）**
- **短縮記法で関数を定義** できる。
- `this` の扱いが異なる（詳細は後述）。

```js
const greet = (name) => {
    console.log("こんにちは、" + name + "さん！");
};

greet("次郎");
```

**✅ 1行なら `{}` 省略可能**
```js
const square = x => x * x;
console.log(square(4)); // 16
```

**✅ 引数なしのアロー関数**
```js
const hello = () => console.log("Hello, World!");
hello();
```

---

## **🟢 3. 関数の引数とデフォルト引数**
関数に **デフォルトの引数** を設定することができます。

```js
function greet(name = "ゲスト") {
    console.log("こんにちは、" + name + "さん！");
}

greet();       // こんにちは、ゲストさん！
greet("太郎"); // こんにちは、太郎さん！
```

**✅ アロー関数でもデフォルト引数を使える**
```js
const greet = (name = "ゲスト") => console.log(`こんにちは、${name}さん！`);
greet(); // こんにちは、ゲストさん！
```

---

## **🟢 4. スコープ（`var`, `let`, `const` の違い）**
JavaScriptの変数には **スコープ（有効範囲）** があり、関数の外からアクセスできるかどうかが異なります。

| キーワード | スコープ | 再代入 | 特徴 |
|-----------|---------|------|------|
| `var` | **関数スコープ** | 可能 | グローバル変数になりやすい（推奨されない） |
| `let` | **ブロックスコープ** | 可能 | ループや関数の中でのみ有効 |
| `const` | **ブロックスコープ** | 不可 | 定数（再代入できない） |

---

### **📌 `var` の問題点**
`var` は関数スコープのため、ブロック `{}` の影響を受けず、**意図せず上書きされる** ことがある。

```js
if (true) {
    var x = 10;
}
console.log(x); // 10（外からアクセスできる！）
```

### **📌 `let` と `const` の正しい使い方**
```js
if (true) {
    let y = 20;
}
console.log(y); // エラー（y はブロックスコープ）
```

```js
const z = 30;
z = 40; // エラー（再代入不可）
```

---

## **🟢 5. クロージャ（Closure）**
クロージャとは、**関数が外部の変数を記憶し、関数外からアクセスできる仕組み** のこと。

### **📌 クロージャの例**
```js
function counter() {
    let count = 0; // 外部変数（閉じ込められる）
    
    return function() {
        count++;
        console.log("現在のカウント:", count);
    };
}

const countUp = counter(); 
countUp(); // 現在のカウント: 1
countUp(); // 現在のカウント: 2
```
**🔹 ポイント**
- `counter()` が実行されると、`count` 変数が作成される。
- `return function()` の中では、`count` にアクセス可能。
- `countUp` を呼び出すたびに、`count` の値が更新される。

---

## **🎯 まとめ**
| 概要 | 説明 |
|------|------|
| **関数の定義** | `function` キーワードで作成 |
| **無名関数** | 関数名なしで変数に代入 |
| **アロー関数** | `() => {}` で短縮記法 |
| **デフォルト引数** | `function greet(name = "ゲスト")` |
| **スコープ** | `var`（関数スコープ） vs `let/const`（ブロックスコープ） |
| **クロージャ** | **関数が外部の変数を記憶** し続ける |

関数を活用して、効率的なコードを書こう！🚀

# **6. オブジェクトと配列（Objects & Arrays）**
JavaScript では **オブジェクト** と **配列** を使ってデータを管理します。  
どちらも **データのコレクションを扱う** ために重要な構造です。

---

## **🟢 1. オブジェクトの作成と操作 (`{ key: value }`)**
オブジェクトは **キーと値のペア（`key: value`）** で構成されるデータ型です。

### **📌 オブジェクトの作成**
```js
let person = {
    name: "太郎",
    age: 25,
    job: "エンジニア"
};

console.log(person.name); // "太郎"
console.log(person["age"]); // 25
```

---

### **📌 オブジェクトの操作**
#### **🔹 値の追加**
```js
person.city = "東京";
console.log(person); // {name: "太郎", age: 25, job: "エンジニア", city: "東京"}
```

#### **🔹 値の更新**
```js
person.age = 26;
console.log(person.age); // 26
```

#### **🔹 値の削除**
```js
delete person.job;
console.log(person); // {name: "太郎", age: 26, city: "東京"}
```

---

## **🟢 2. 配列の作成と操作 (`[]`, `.push()`, `.pop()`, `.shift()`, `.unshift()`)**
配列は **順序付きのデータ構造** で、複数の値を格納できます。

### **📌 配列の作成**
```js
let fruits = ["Apple", "Banana", "Cherry"];
console.log(fruits[0]); // "Apple"
```

---

### **📌 配列の操作**
#### **🔹 `push()`（末尾に追加）**
```js
fruits.push("Grapes");
console.log(fruits); // ["Apple", "Banana", "Cherry", "Grapes"]
```

#### **🔹 `pop()`（末尾を削除）**
```js
fruits.pop();
console.log(fruits); // ["Apple", "Banana", "Cherry"]
```

#### **🔹 `unshift()`（先頭に追加）**
```js
fruits.unshift("Mango");
console.log(fruits); // ["Mango", "Apple", "Banana", "Cherry"]
```

#### **🔹 `shift()`（先頭を削除）**
```js
fruits.shift();
console.log(fruits); // ["Apple", "Banana", "Cherry"]
```

---

## **🟢 3. オブジェクトと配列の反復**
データを効率的に処理するには、**ループや組み込みメソッド** を活用します。

---

### **📌 `for...in`（オブジェクトのキーを取得）**
```js
let person = { name: "太郎", age: 25, city: "東京" };

for (let key in person) {
    console.log(key + ": " + person[key]);
}
```
**✅ 実行結果**
```
name: 太郎
age: 25
city: 東京
```
---

### **📌 `for...of`（配列の値を取得）**
```js
let colors = ["Red", "Green", "Blue"];

for (let color of colors) {
    console.log(color);
}
```
**✅ 実行結果**
```
Red
Green
Blue
```
---

### **📌 `map()`（すべての要素を変換して新しい配列を作る）**
```js
let numbers = [1, 2, 3, 4, 5];
let squared = numbers.map(num => num ** 2);
console.log(squared); // [1, 4, 9, 16, 25]
```

---

### **📌 `filter()`（条件に合う要素だけ抽出）**
```js
let scores = [80, 45, 90, 50, 70];
let passed = scores.filter(score => score >= 60);
console.log(passed); // [80, 90, 70]
```

---

### **📌 `reduce()`（配列の値を累積計算）**
```js
let numbers = [1, 2, 3, 4, 5];
let sum = numbers.reduce((total, num) => total + num, 0);
console.log(sum); // 15
```

---

## **🎯 まとめ**
| 操作 | メソッド | 例 |
|------|---------|----|
| **オブジェクトの追加** | `obj.key = value` | `person.city = "東京"` |
| **オブジェクトの削除** | `delete obj.key` | `delete person.age` |
| **配列の末尾に追加** | `.push()` | `fruits.push("Grapes")` |
| **配列の末尾を削除** | `.pop()` | `fruits.pop()` |
| **配列の先頭に追加** | `.unshift()` | `fruits.unshift("Mango")` |
| **配列の先頭を削除** | `.shift()` | `fruits.shift()` |
| **オブジェクトのループ** | `for...in` | `for (let key in obj) {}` |
| **配列のループ** | `for...of` | `for (let item of arr) {}` |
| **配列の変換** | `.map()` | `arr.map(x => x * 2)` |
| **配列のフィルタ** | `.filter()` | `arr.filter(x => x > 5)` |
| **配列の累積計算** | `.reduce()` | `arr.reduce((sum, x) => sum + x, 0)` |

オブジェクトと配列を活用すれば、データを柔軟に扱える！🚀

# **7. ES6+ の機能**
ES6（ECMAScript 2015）以降、JavaScript は大幅に強化され、**より書きやすく、保守しやすく** なりました。  
ここでは、特によく使われる **ES6+ の機能** を解説します。

---

## **🟢 1. テンプレートリテラル（Template Literals）**
バッククォート（`` ` ``）を使い、変数を埋め込んだり、改行を含めた文字列を簡単に書ける。

### **📌 使い方**
```js
const name = "太郎";
const age = 25;

const message = `こんにちは、${name} さん！あなたは ${age} 歳です。`;
console.log(message);
```
✅ **`${}` を使って変数や式を埋め込める！**

---

## **🟢 2. 分割代入（Destructuring Assignment）**
配列やオブジェクトから **値を簡単に取り出せる**。

### **📌 配列の分割代入**
```js
const fruits = ["Apple", "Banana", "Cherry"];
const [first, second] = fruits;

console.log(first);  // "Apple"
console.log(second); // "Banana"
```

### **📌 オブジェクトの分割代入**
```js
const person = { name: "花子", age: 30, city: "東京" };
const { name, age } = person;

console.log(name); // "花子"
console.log(age);  // 30
```

✅ **関数の引数にも使える！**
```js
function display({ name, age }) {
    console.log(`${name} さんは ${age} 歳です。`);
}

display(person);
```

---

## **🟢 3. スプレッド演算子（`...`）**
**配列やオブジェクトを展開・コピー** するのに便利。

### **📌 配列の展開**
```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1, 4, 5];

console.log(arr2); // [1, 2, 3, 4, 5]
```

### **📌 オブジェクトのコピー**
```js
const obj1 = { name: "Alice", age: 25 };
const obj2 = { ...obj1, city: "Osaka" };

console.log(obj2); // { name: "Alice", age: 25, city: "Osaka" }
```

---

## **🟢 4. デフォルトパラメータ**
関数の引数にデフォルト値を設定できる。

```js
function greet(name = "ゲスト") {
    console.log(`こんにちは、${name} さん！`);
}

greet();       // "こんにちは、ゲスト さん！"
greet("太郎"); // "こんにちは、太郎 さん！"
```

✅ **オブジェクトの分割代入と組み合わせると強力！**
```js
function createUser({ name = "名無し", age = 20 } = {}) {
    console.log(`${name} さん (${age}歳)`);
}

createUser({ name: "花子", age: 30 }); // "花子 さん (30歳)"
createUser(); // "名無し さん (20歳)"
```

---

## **🟢 5. `let` / `const` とブロックスコープ**
- **`let`**：再代入可能だが、ブロックスコープを持つ
- **`const`**：再代入不可（定数）

```js
if (true) {
    let x = 10;
    const y = 20;
    console.log(x, y); // OK
}
console.log(x, y); // エラー（ブロック外）
```

✅ **`const` でもオブジェクトのプロパティは変更できる！**
```js
const user = { name: "太郎" };
user.name = "次郎"; // OK（オブジェクトの変更は可能）

// user = { age: 25 }; // ❌ エラー（再代入はできない）
```

---

## **🟢 6. `Map` / `Set` オブジェクト**
**`Map`（キーと値のペア）** や **`Set`（重複を許さないコレクション）** も使いやすくなった。

### **📌 `Map` の使い方**
```js
const userMap = new Map();
userMap.set("太郎", 25);
userMap.set("花子", 30);

console.log(userMap.get("太郎")); // 25
console.log(userMap.has("花子")); // true
```

### **📌 `Set` の使い方**
```js
const uniqueNumbers = new Set([1, 2, 2, 3, 3, 4]);
console.log([...uniqueNumbers]); // [1, 2, 3, 4]
```

---

## **🟢 7. 非同期処理（`Promise`, `async/await`）**
JavaScript の非同期処理が大幅に強化された。

---

### **📌 `Promise`（非同期処理を管理する）**
```js
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("データ取得完了！");
    }, 2000);
});

fetchData.then(data => console.log(data)); // 2秒後に "データ取得完了！"
```

---

### **📌 `async/await`（非同期処理を簡単に書ける）**
```js
async function fetchData() {
    return "データ取得完了！";
}

fetchData().then(data => console.log(data));
```

---

### **📌 `await` を使った API 呼び出し**
```js
async function getUser() {
    const response = await fetch("https://jsonplaceholder.typicode.com/users/1");
    const user = await response.json();
    console.log(user);
}

getUser(); // ユーザー情報を取得
```

---

# **🎯 まとめ**
| 機能 | 説明 |
|------|------|
| **テンプレートリテラル** | 文字列中に変数を埋め込める（`` `Hello, ${name}!` ``） |
| **分割代入** | 配列・オブジェクトの値を簡単に取得 |
| **スプレッド演算子** | 配列・オブジェクトの展開 |
| **デフォルトパラメータ** | 関数の引数にデフォルト値を設定 |
| **`let` / `const`** | `let` はブロックスコープ、`const` は再代入不可 |
| **`Map` / `Set`** | キー・値ペアの管理、重複なしのコレクション |
| **`Promise`** | 非同期処理を管理するオブジェクト |
| **`async/await`** | 非同期処理を簡単に書ける |

---

**ES6+ の機能を活用すると、コードがシンプルで効率的になる！** 🚀


# **8. クラスとオブジェクト指向（Object-Oriented Programming, OOP）**
ES6 以降、JavaScript は **オブジェクト指向プログラミング（OOP）** をサポートする `class` 構文を導入しました。  
これにより、より整理されたコードを書けるようになりました。

---

## **🟢 1. クラス（`class`, `constructor`, `extends`, `super`）**
クラスはオブジェクトを作るための **設計図** です。

### **📌 基本のクラス**
```js
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    introduce() {
        console.log(`こんにちは、私は ${this.name} です。${this.age} 歳です。`);
    }
}

const person1 = new Person("太郎", 25);
person1.introduce();
```
**✅ 実行結果**
```
こんにちは、私は 太郎 です。25 歳です。
```

**🔹 `constructor()` とは？**
- **コンストラクタ（`constructor`）はクラスの初期化処理を行う特殊なメソッド**
- `new Person("太郎", 25)` を実行すると `constructor` が呼ばれ、`this.name` や `this.age` が設定される

---

### **📌 クラスの継承（`extends`, `super`）**
親クラス（スーパークラス）から機能を引き継ぐことができる。

```js
class Employee extends Person {
    constructor(name, age, job) {
        super(name, age); // 親クラスの `constructor` を呼び出す
        this.job = job;
    }

    work() {
        console.log(`${this.name} は ${this.job} の仕事をしています。`);
    }
}

const emp1 = new Employee("花子", 30, "エンジニア");
emp1.introduce();
emp1.work();
```
**✅ 実行結果**
```
こんにちは、私は 花子 です。30 歳です。
花子 は エンジニア の仕事をしています。
```

---

## **🟢 2. メソッドとプロパティ**
### **📌 メソッド**
クラス内の関数は **メソッド** と呼ばれる。

```js
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} は鳴いています。`);
    }
}

const dog = new Animal("犬");
dog.speak(); // "犬 は鳴いています。"
```

---

### **📌 ゲッター・セッター（`get`, `set`）**
**プロパティを取得 (`get`)、設定 (`set`) するメソッド**

```js
class Rectangle {
    constructor(width, height) {
        this.width = width;
        this.height = height;
    }

    get area() {
        return this.width * this.height;
    }

    set size(value) {
        this.width = value;
        this.height = value;
    }
}

const rect = new Rectangle(10, 5);
console.log(rect.area); // 50

rect.size = 7; // 幅と高さを 7 に変更
console.log(rect.area); // 49
```
✅ **プロパティのように `rect.area` で取得できる！**

---

## **🟢 3. `this` キーワードの挙動**
`this` は **オブジェクト自身を指すキーワード** だが、関数の種類によって挙動が異なる。

### **📌 クラス内の `this`**
```js
class Car {
    constructor(brand) {
        this.brand = brand;
    }

    showBrand() {
        console.log(`この車は ${this.brand} です。`);
    }
}

const myCar = new Car("Toyota");
myCar.showBrand(); // "この車は Toyota です。"
```

### **📌 `this` の注意点**
通常の関数の `this` は呼び出し元のオブジェクトを指すが、  
**アロー関数の `this` は親の `this` を引き継ぐ**。

```js
class Counter {
    constructor() {
        this.count = 0;
    }

    start() {
        setInterval(() => {
            this.count++; // アロー関数なので `this` は `Counter` を指す
            console.log(this.count);
        }, 1000);
    }
}

const counter = new Counter();
counter.start();
```
✅ `setInterval` のコールバック内で `this` を保持できる！

---

## **🟢 4. 静的メソッド（`static`）**
- **インスタンス化せずに直接呼び出せるメソッド**
- **ユーティリティ関数** などに使う

```js
class MathUtils {
    static add(a, b) {
        return a + b;
    }
}

console.log(MathUtils.add(5, 3)); // 8
```
✅ **`new MathUtils()` をせずに `MathUtils.add()` を直接呼び出せる！**

---

## **🟢 5. プロトタイプ（Prototype）**
- JavaScript は **プロトタイプベースのオブジェクト指向**
- **クラスの本質はプロトタイプの仕組みを利用したもの**
- **クラスを使わずに `prototype` を直接拡張することも可能**

### **📌 `prototype` を使ったメソッド定義**
```js
function User(name) {
    this.name = name;
}

User.prototype.sayHello = function() {
    console.log(`こんにちは、${this.name} です！`);
};

const user1 = new User("次郎");
user1.sayHello(); // "こんにちは、次郎 です！"
```

**🔹 プロトタイプのメリット**
- **すべてのインスタンスが `sayHello()` を共有する**
- **メモリ効率が良い**

---

# **🎯 まとめ**
| 概念 | 説明 |
|------|------|
| **クラス** | `class` を使ってオブジェクトの設計図を作る |
| **コンストラクタ** | `constructor()` で初期化 |
| **クラスの継承** | `extends`, `super` で親クラスを継承 |
| **メソッド** | クラス内の関数 |
| **ゲッター/セッター** | `get`, `set` でプロパティの取得・設定 |
| **`this` の挙動** | アロー関数は `this` を親スコープから引き継ぐ |
| **静的メソッド** | `static` をつけるとクラス名から直接呼び出せる |
| **プロトタイプ** | クラスを使わずに `prototype` を使って拡張できる |

---

**クラスを活用すれば、オブジェクト指向のコードがシンプルに書ける！** 🚀

# **9. 非同期処理（Asynchronous Programming）**
JavaScript は **シングルスレッド** のため、**時間のかかる処理（ネットワーク通信、タイマーなど）** を効率的に処理するために **非同期処理** を活用します。

---

## **🟢 1. コールバック関数（Callback Function）**
コールバック関数とは、**ある処理が完了したときに呼び出される関数** です。

### **📌 コールバック関数の基本**
```js
function fetchData(callback) {
    setTimeout(() => {
        console.log("データ取得完了");
        callback();
    }, 2000);
}

fetchData(() => {
    console.log("次の処理を実行");
});
```
**✅ 実行結果**
```
データ取得完了  （← 2秒後）
次の処理を実行
```
**🔹 問題点**
- **コールバックがネストすると可読性が悪くなる**（「コールバック地獄」）

### **📌 コールバック地獄（Callback Hell）の例**
```js
function step1(callback) {
    setTimeout(() => {
        console.log("ステップ1完了");
        callback();
    }, 1000);
}

function step2(callback) {
    setTimeout(() => {
        console.log("ステップ2完了");
        callback();
    }, 1000);
}

step1(() => {
    step2(() => {
        console.log("すべての処理が完了");
    });
});
```
**🔹 解決策 → `Promise` を使う！**

---

## **🟢 2. `Promise` オブジェクト**
**`Promise` は「未来の処理の完了・失敗を表すオブジェクト」** です。

### **📌 `Promise` の基本**
```js
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("データ取得成功");
    }, 2000);
});

fetchData.then(data => {
    console.log(data); // "データ取得成功"
});
```

**🔹 `then`, `catch`, `finally` の基本**
```js
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        let success = true;
        if (success) {
            resolve("データ取得成功");
        } else {
            reject("データ取得失敗");
        }
    }, 2000);
});

fetchData
    .then(data => {
        console.log("成功:", data);
    })
    .catch(error => {
        console.error("エラー:", error);
    })
    .finally(() => {
        console.log("処理完了");
    });
```
**✅ 実行結果**
```
成功: データ取得成功  （成功時）
処理完了

エラー: データ取得失敗  （失敗時）
処理完了
```

---

## **🟢 3. `async` / `await`**
`async` / `await` を使うと、**非同期処理を同期的に書ける** ようになります。

### **📌 `async` / `await` の基本**
```js
function fetchData() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve("データ取得成功");
        }, 2000);
    });
}

async function getData() {
    console.log("データ取得開始...");
    const data = await fetchData();
    console.log("取得結果:", data);
}

getData();
```
**✅ 実行結果**
```
データ取得開始...
（2秒後）
取得結果: データ取得成功
```
**🔹 `await` を使うメリット**
- `then()` を使わずに **同期処理のように記述できる**
- **可読性が向上する**

---

### **📌 `try...catch` でエラーハンドリング**
```js
function fetchData(success) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            success ? resolve("データ取得成功") : reject("データ取得失敗");
        }, 2000);
    });
}

async function getData() {
    try {
        console.log("データ取得中...");
        const data = await fetchData(false); // 失敗する
        console.log("取得結果:", data);
    } catch (error) {
        console.error("エラー:", error);
    } finally {
        console.log("処理完了");
    }
}

getData();
```
**✅ 実行結果（失敗時）**
```
データ取得中...
エラー: データ取得失敗
処理完了
```

---

## **🟢 4. `setTimeout` / `setInterval`**
### **📌 `setTimeout`（一定時間後に実行）**
```js
console.log("開始");

setTimeout(() => {
    console.log("2秒後に実行");
}, 2000);

console.log("終了");
```
**✅ 実行結果**
```
開始
終了
（2秒後）
2秒後に実行
```

---

### **📌 `setInterval`（一定間隔で実行）**
```js
let count = 0;
const timer = setInterval(() => {
    count++;
    console.log(`カウント: ${count}`);
    if (count === 5) clearInterval(timer);
}, 1000);
```
**✅ 実行結果**
```
カウント: 1
カウント: 2
カウント: 3
カウント: 4
カウント: 5
```
**🔹 `clearInterval(timer)` でループを停止できる！**

---

# **🎯 まとめ**
| 非同期処理 | 説明 |
|-----------|------|
| **コールバック関数** | 関数が完了したら別の関数を実行 |
| **`Promise`** | `then`, `catch`, `finally` を使って非同期処理を管理 |
| **`async` / `await`** | `Promise` をより簡潔に書ける |
| **`setTimeout`** | 一定時間後に実行 |
| **`setInterval`** | 一定間隔で繰り返し実行 |

---

### **🔹 どれを使うべき？**
✅ **シンプルな遅延処理** → `setTimeout`  
✅ **定期的な処理** → `setInterval`  
✅ **複数の非同期処理を管理** → `Promise`  
✅ **非同期処理をシンプルに書く** → `async` / `await`  

**非同期処理を活用して、スムーズなアプリを作ろう！** 🚀

# **10. エラーハンドリング（Error Handling）**
JavaScript では、エラーが発生したときにプログラムがクラッシュしないように、**適切にエラーハンドリングを行う** ことが重要です。  
ここでは、`try...catch`、`throw`、`finally` を活用したエラーハンドリングの方法を解説します。

---

## **🟢 1. `try...catch`（エラーをキャッチする）**
- **`try` ブロック内のコードを実行し、エラーが発生したら `catch` で処理する**
- **エラーが発生してもプログラムをクラッシュさせない**

### **📌 基本的な `try...catch`**
```js
try {
    let result = 10 / 0;
    console.log(result); // JavaScript では `Infinity` になるのでエラーにはならない
} catch (error) {
    console.log("エラーが発生しました:", error.message);
}
```
**✅ 実行結果**
```
Infinity
```
**🔹 `10 / 0` は JavaScript ではエラーにならない（`Infinity` になる）**

---

### **📌 実際にエラーが発生する場合**
```js
try {
    let data = undefined;
    console.log(data.name); // `data` が `undefined` なのでエラー発生
} catch (error) {
    console.log("エラー発生:", error.message);
}
```
**✅ 実行結果**
```
エラー発生: Cannot read properties of undefined (reading 'name')
```

---

## **🟢 2. `throw` キーワード（手動でエラーを発生させる）**
- **カスタムエラーを発生させる**
- **条件に応じてエラーを `throw` し、`catch` で処理する**

### **📌 `throw` を使ってカスタムエラーを投げる**
```js
function validateAge(age) {
    if (age < 0) {
        throw new Error("年齢は 0 以上である必要があります");
    }
    console.log(`年齢: ${age}`);
}

try {
    validateAge(-5);
} catch (error) {
    console.error("エラー:", error.message);
}
```
**✅ 実行結果**
```
エラー: 年齢は 0 以上である必要があります
```
**🔹 `throw` を使うことで、不正な入力を適切に処理できる！**

---

## **🟢 3. `finally` ブロック（必ず実行される処理）**
- **エラーの有無に関わらず、`finally` 内のコードは必ず実行される**
- **リソースの解放などに使う**

### **📌 `finally` の使い方**
```js
try {
    console.log("処理開始");
    let result = 10 / 2;
    console.log("結果:", result);
} catch (error) {
    console.log("エラー:", error.message);
} finally {
    console.log("処理終了（エラーの有無に関わらず実行）");
}
```
**✅ 実行結果**
```
処理開始
結果: 5
処理終了（エラーの有無に関わらず実行）
```

---

## **🟢 4. `async/await` と `try...catch`**
- **非同期処理（`async/await`）のエラーハンドリングにも `try...catch` が使える！**

### **📌 非同期処理のエラーハンドリング**
```js
async function fetchData() {
    try {
        let response = await fetch("https://jsonplaceholder.typicode.com/users/1");
        let user = await response.json();
        console.log("ユーザー情報:", user);
    } catch (error) {
        console.error("データ取得エラー:", error.message);
    } finally {
        console.log("処理完了");
    }
}

fetchData();
```
**✅ `try...catch` を使うことで、非同期処理のエラーも適切に処理できる！**

---

# **🎯 まとめ**
| 機能 | 説明 |
|------|------|
| **`try...catch`** | エラーをキャッチして処理を続行できる |
| **`throw`** | カスタムエラーを発生させる |
| **`finally`** | エラーの有無に関わらず最後に実行される |
| **`async/await` のエラーハンドリング** | `try...catch` を使って `await` のエラーを処理 |

---

**適切なエラーハンドリングを行えば、信頼性の高いコードが書ける！** 🚀



# **11. モジュール（Modules）**
JavaScript のモジュールシステムは、**コードを分割して管理しやすくする** ための仕組みです。  
ここでは **CommonJS（Node.js の標準）** と **ESModules（ES6+ の標準）** の違いを解説します。

---

## **🟢 1. `import` / `export`（ESModules）**
ES6 以降、JavaScript では **ESModules（ECMAScript Modules, ESM）** を標準でサポート。

✅ **メリット**
- **ファイルごとに分割できる**
- **ネームスペースの衝突を防げる**
- **ブラウザでも使える**

---

### **📌 `export`（エクスポート）**
ファイル内の関数・変数を **他のファイルから使えるようにする**。

#### **🔹 名前付きエクスポート（Named Export）**
`math.js`
```js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}
```

**✅ 複数の関数や変数をエクスポートできる！**

---

### **📌 `import`（インポート）**
他のファイルの関数・変数を **読み込む**。

#### **🔹 名前付きインポート**
`main.js`
```js
import { PI, add } from "./math.js";

console.log(PI);        // 3.14159
console.log(add(2, 3)); // 5
```
✅ **`{}` を使って、特定のエクスポートを選んでインポートできる！**

---

### **📌 `export default`（デフォルトエクスポート）**
**1つのデフォルト値をエクスポートする** 場合は `export default` を使う。

`math.js`
```js
export default function multiply(a, b) {
    return a * b;
}
```

✅ **デフォルトエクスポートは `{}` なしでインポートできる！**
`main.js`
```js
import multiply from "./math.js";

console.log(multiply(3, 4)); // 12
```

---

## **🟢 2. CommonJS（`require` / `module.exports`）**
CommonJS（CJS）は **Node.js の標準モジュールシステム**。

✅ **特徴**
- **サーバーサイドで広く使われている**
- **ESModules よりも `require()` の評価が即時に行われる**

---

### **📌 `module.exports` を使ったエクスポート**
`math.js`
```js
const PI = 3.14159;

function add(a, b) {
    return a + b;
}

module.exports = { PI, add };
```

---

### **📌 `require()` を使ったインポート**
`main.js`
```js
const math = require("./math");

console.log(math.PI);        // 3.14159
console.log(math.add(2, 3)); // 5
```
✅ **CommonJS では `require()` を使う！**

---

## **🟢 3. ESModules と CommonJS の違い**
| 比較 | ESModules (`import/export`) | CommonJS (`require/module.exports`) |
|------|----------------|------------------|
| **用途** | クライアント / Node.js | Node.js |
| **非同期 / 同期** | **非同期**（`import()` 動的インポートも可能） | **同期**（`require()` は即時実行） |
| **ブラウザ対応** | ✅ 直接使える | ❌ `require()` はブラウザ非対応 |
| **エクスポート** | `export {}` または `export default` | `module.exports = {}` |
| **インポート** | `import {}` または `import default` | `const mod = require()` |

✅ **Node.js では `ESModules` を使いたい場合 `package.json` に `type: "module"` を追加する**
```json
{
  "type": "module"
}
```
---

## **🟢 4. `import()` を使った動的インポート**
- **必要なときにモジュールを読み込む**
- **非同期処理 (`async/await`) で使える**

```js
async function loadModule() {
    const math = await import("./math.js");
    console.log(math.PI);
    console.log(math.add(2, 3));
}

loadModule();
```

✅ **動的インポートなら、不要なモジュールを遅延ロードできる！**

---

## **🎯 まとめ**
| 機能 | ESModules (`import/export`) | CommonJS (`require/module.exports`) |
|------|----------------|------------------|
| **使う環境** | クライアント・Node.js | Node.js |
| **エクスポート** | `export {}` / `export default` | `module.exports = {}` |
| **インポート** | `import {}` / `import()` | `require()` |
| **ブラウザ対応** | ✅ 可能 | ❌ 不可 |
| **動的インポート** | ✅ `import()` | ❌ 不可 |

---

**JavaScript のモジュールシステムを使いこなせば、より管理しやすいコードが書ける！** 🚀


# **12. ブラウザ関連の JavaScript**
ブラウザ環境では、JavaScript を使って **DOM 操作・イベント処理・データ保存・HTTP 通信** などが可能です。  
ここでは、**ブラウザ関連の重要な JavaScript 機能** を解説します。

---

## **🟢 1. DOM 操作（`document.querySelector`, `getElementById`）**
**DOM（Document Object Model）** は、HTML の構造を **JavaScript から操作するための仕組み** です。

---

### **📌 要素の取得**
| メソッド | 説明 | 例 |
|----------|------|----|
| `getElementById()` | `id` を指定して取得 | `document.getElementById("myId")` |
| `querySelector()` | CSS セレクタで取得（最初の要素） | `document.querySelector(".myClass")` |
| `querySelectorAll()` | CSS セレクタで全要素取得（NodeList） | `document.querySelectorAll("p")` |

---

### **📌 要素の取得と変更**
```html
<p id="text">変更前のテキスト</p>
<button onclick="changeText()">変更</button>

<script>
function changeText() {
    const element = document.getElementById("text");
    element.textContent = "変更後のテキスト";
}
</script>
```
✅ **ボタンをクリックするとテキストが変更される！**

---

## **🟢 2. イベントリスナー（`addEventListener`）**
**イベントリスナー** を使うと、**クリック・キー入力・スクロール** などのイベントに応じた処理を実行できる。

### **📌 `addEventListener()` の基本**
```html
<button id="btn">クリック</button>
<p id="message"></p>

<script>
document.getElementById("btn").addEventListener("click", function() {
    document.getElementById("message").textContent = "ボタンがクリックされました！";
});
</script>
```
✅ **ボタンをクリックするとメッセージが表示される！**

---

### **📌 `mouseover` や `keydown` イベント**
```js
document.querySelector("#btn").addEventListener("mouseover", () => {
    console.log("ボタンにマウスが乗った！");
});

document.addEventListener("keydown", (event) => {
    console.log(`キーが押された: ${event.key}`);
});
```
✅ **マウスやキーボードの操作も検知できる！**

---

## **🟢 3. ローカルストレージ / セッションストレージ**
**ブラウザにデータを保存する方法** として、`localStorage` と `sessionStorage` がある。

| ストレージ | 保存期間 | 説明 |
|-----------|--------|------|
| **`localStorage`** | **永続的**（手動で削除するまで） | データをブラウザに長期間保存 |
| **`sessionStorage`** | **セッション終了まで** | タブを閉じるとデータが消える |

---

### **📌 `localStorage` の使い方**
```js
// データを保存
localStorage.setItem("username", "太郎");

// データを取得
console.log(localStorage.getItem("username")); // "太郎"

// データを削除
localStorage.removeItem("username");

// 全データ削除
localStorage.clear();
```

✅ **ブラウザをリロードしても `localStorage` のデータは保持される！**

---

### **📌 `sessionStorage` の使い方**
```js
// データを保存
sessionStorage.setItem("sessionData", "一時データ");

// データを取得
console.log(sessionStorage.getItem("sessionData")); // "一時データ"

// タブを閉じると `sessionStorage` のデータは消える
```
✅ **`sessionStorage` はタブを閉じるとデータが消える！**

---

## **🟢 4. Fetch API（`fetch` での HTTP リクエスト）**
**`fetch()` を使うと、簡単に API からデータを取得できる。**

---

### **📌 `fetch()` を使った GET リクエスト**
```js
async function fetchData() {
    try {
        const response = await fetch("https://jsonplaceholder.typicode.com/users/1");
        const data = await response.json();
        console.log("ユーザー情報:", data);
    } catch (error) {
        console.error("データ取得エラー:", error);
    }
}

fetchData();
```
✅ **API からデータを取得し、コンソールに表示！**

---

### **📌 `fetch()` を使った POST リクエスト**
```js
async function postData() {
    try {
        const response = await fetch("https://jsonplaceholder.typicode.com/posts", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ title: "新しい投稿", body: "内容", userId: 1 })
        });

        const data = await response.json();
        console.log("投稿完了:", data);
    } catch (error) {
        console.error("エラー:", error);
    }
}

postData();
```
✅ **POST リクエストでデータを送信できる！**

---

## **🎯 まとめ**
| 機能 | 説明 |
|------|------|
| **DOM 操作** | `getElementById()`, `querySelector()` で HTML を取得・変更 |
| **イベントリスナー** | `addEventListener()` でボタンクリックやキー入力を監視 |
| **ローカルストレージ** | `localStorage` はデータを永続保存 |
| **セッションストレージ** | `sessionStorage` はタブを閉じると消える |
| **Fetch API** | `fetch()` で API からデータを取得・送信 |

---

**ブラウザ関連の JavaScript を活用すれば、動的な Web アプリが作れる！** 🚀

# **13. デバッグと開発ツール**
JavaScript のデバッグを効果的に行うために、**`console.log`、`debugger`、ブラウザの開発者ツール** を活用しましょう。

---

## **🟢 1. `console.log` の活用**
`console.log()` は **変数の値やプログラムの実行状況を確認する** ための基本的なデバッグ方法です。

---

### **📌 `console.log()` の基本**
```js
let name = "太郎";
console.log("名前:", name);
```
**✅ 実行結果（ブラウザのコンソール）**
```
名前: 太郎
```

---

### **📌 `console.log()` を使ったオブジェクトの表示**
```js
const user = { name: "花子", age: 30, city: "東京" };
console.log(user);
```
**✅ ブラウザのコンソールで `user` のプロパティが展開される**

---

### **📌 `console.table()`（オブジェクトや配列を表形式で表示）**
```js
const users = [
    { id: 1, name: "太郎", age: 25 },
    { id: 2, name: "花子", age: 30 },
    { id: 3, name: "次郎", age: 28 }
];

console.table(users);
```
**✅ 実行結果**
```
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
| 1  | 太郎   |  25 |
| 2  | 花子   |  30 |
| 3  | 次郎   |  28 |
+----+--------+-----+
```
✅ **データを見やすく表示できる！**

---

### **📌 `console.warn()` / `console.error()`（警告やエラーの表示）**
```js
console.warn("これは警告メッセージです！");
console.error("これはエラーメッセージです！");
```
✅ **ブラウザのコンソールで、警告は黄色、エラーは赤で表示される！**

---

## **🟢 2. `debugger` ステートメント**
- `debugger;` をコード内に記述すると、**その位置で実行が一時停止** し、開発者ツールのデバッガーが起動する。
- **変数の値や実行フローを確認するのに便利**。

### **📌 `debugger` の使用例**
```js
function testDebugger() {
    let x = 10;
    let y = 20;
    debugger;  // ここで実行が一時停止
    let sum = x + y;
    console.log("合計:", sum);
}

testDebugger();
```
✅ **ブラウザの開発者ツールで `x` や `y` の値を確認できる！**

---

## **🟢 3. ブラウザの開発者ツール**
**Google Chrome / Firefox / Edge / Safari などのブラウザには強力な開発者ツールが搭載されている！**

### **📌 開発者ツールの起動**
- **Windows / Linux**：`F12` または `Ctrl + Shift + I`
- **Mac**：`Cmd + Opt + I`

---

### **📌 主な機能**
| 機能 | 説明 |
|------|------|
| **Console** | `console.log()` の出力を確認 |
| **Elements** | HTML / CSS の構造を確認・変更 |
| **Network** | HTTP リクエストの確認（API のデバッグに便利） |
| **Sources** | JavaScript のデバッグ（`debugger` を使う） |
| **Application** | `localStorage` / `sessionStorage` / `cookie` の管理 |
| **Performance** | 実行速度やリソース消費を分析 |

---

### **📌 ブラウザの開発者ツールでデバッグ**
1. **`Sources` タブを開く**
2. **JavaScript ファイルを選択**
3. **ブレークポイントを設定（行番号をクリック）**
4. **コードを実行すると、ブレークポイントで停止**
5. **変数の値や実行フローを確認**

✅ **開発者ツールを活用すれば、デバッグが劇的に楽になる！**

---

## **🎯 まとめ**
| 機能 | 説明 |
|------|------|
| **`console.log()`** | 変数の値やオブジェクトを確認 |
| **`console.table()`** | 配列やオブジェクトを表形式で表示 |
| **`console.warn()` / `console.error()`** | 警告・エラーを表示 |
| **`debugger`** | コードの実行を一時停止してデバッグ |
| **開発者ツール** | ブラウザで `F12` / `Cmd + Opt + I` で開く |

---

**デバッグツールを活用して、バグを効率よく修正しよう！** 🚀